<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <style>
    <!--
	body {font: 10pt Verdana,Arial,Helvetica,sans-serif; background: white; color: black;}
	H1, H2 {text-align: center;}
	H3 {font-size: 1.17em; font-weight:bold; margin: 1em 0;}
	div.figure {margin: 0 10%; font-size: 8pt; text-align: justify;}
	div.figure img {display: block; margin: 10px auto;}
	table {border-collapse: collapse;}
	td, th {text-align: left; vertical-align: top;}
	th {border-bottom: 1px solid #555;}
	table.regex td:not(:last-child) {white-space: nowrap; font-family: monospace; padding-right: 1em;}
	table.regex td:not(:last-child) i {font-family: Verdana,Arial,Helvetica,sans-serif;}
	pre.dmcode {border: 1px solid #aaa; padding: 5px 10px; overflow-x: auto;}
	.DMk {color: #00f;}
	.DMs {color: #0af;}
	.DMc {color: #555;}
	.DMn {color: #500;}
	.DMpp {color: #0af;}
      -->
  </style>
  <script src="prettyref.js"></script>
  <title>DM Reference</title>
</head>
<body bgcolor=#ffffff text=#000000><div id=refbody>
<h1>DM Reference</h1>
<p>

<p>View the live web reference <a href="http://www.byond.com/docs/ref">here</a>.

<hr>

<a name=/DM>
<h2>DM language details</h2>

<p>The DM (Dream Maker) language uses a syntax similar to C/C++ to build
networked multi-user worlds.  This reference and the accompanying guide
discuss the structure and function of DM.

<hr>

<a name=/DM/cache>
<h2>cache</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/preprocessor/define/FILE_DIR>FILE_DIR definition</a>
<dd><a href=#/world/var/cache_lifespan>cache_lifespan var (world)</a>
<dd><a href=#/proc/fcopy_rsc>fcopy_rsc proc</a>
<dd><a href=#/proc/file>file proc</a>
<dd><a href=#/DM/icon>icons</a>
<dd><a href=#/DM/sound>sounds</a>
</dl>

<p>Files specified in single quotes are loaded (at compile time) into the
world cache file (ending in <code>.rsc</code>).  These are referred to as
resource files.  At runtime these files are downloaded by players into their
<code>byond.rsc</code> file for future use.  With the appropriate verbs or
through savefiles, players may also upload files into the world cache.

<p>If a resource file is not used for a long time, it will be automatically
removed from the cache file to save space.  If a cache file gets too bulky,
however, you may manually delete it and start from scratch.

<p>To make compilation faster and to make it easier to distribute code, the
compiler will use an existing cache file if possible.  That means you could
compile up a world, and send people the <code>.dm</code> and
<code>.rsc</code> files without any need to package all the individual
resource files.  It is also possible to include additional supplementary
<code>.rsc</code> files by using the <code>#include</code> statement.

<hr>

<a name=/DM/comment>
<h2>comment</h2>

<p>Comments may be used to explain code.  They can also be used to turn off a
line or block of code.  All text inside a comment is ignored by the compiler.

<p>The single line comment begins with <code>//</code> and runs to the end of
the line.

<p>The multi-line comment begins with <code>/*</code> and runs until
<code>*/</code>.

<p>Multi-line comments may be nested.

<h3>Example:</h3>
<xmp>
  // single line comment
  /*
     multi-line comment
  */
</xmp>

<hr>

<a name=/DM/garbage>
<h2>garbage collection</h2>

<p>At runtime, data objects are garbage collected.  That means data which
is no longer in use gets automatically deleted to free up system memory.
This applies to text strings, lists, savefiles, datum objects, and so on.

<p>The garbage collector works by using an efficient reference counting
system.  Once an item is no longer referenced by any variable, it gets
deleted.  For the most part, that frees you from having to think about memory
allocation, which is wonderful, especially in the case of text strings, which
tend to be allocated on the fly all over the place.

<p>There are a couple provisos that you should note.  One is that circular
references will never be deleted by the garbage collector.  By <em>circular
reference</em>, I mean a pair of objects with variables that point to each
other, or even an object with a variable that points to itself.  In rare
cases, you may even depend on this behavior.  When you are done with such
objects, you should either null out the circular reference, or you should
forcibly destroy each object with the <code>del</code> instruction.

<p>An object with running or sleeping procs is referenced by the
<code>src</code> variable of those procs and will therefore not be thrown out.

<p>Another note is that the <code>world.contents</code> list does not count as
a reference.  Otherwise, /mob and /obj objects would never be deleted, which
is not the case.  Note that objects which are contained by another object or
which contain objects themselves <em>are</em> referenced and will not be
deleted.  That means an object must be at <code>loc=null</code> with no
contents and, of course, no other references anywhere in order to get deleted
by the garbage collector.

<p>Mobs with a non-empty key and all objects with non-empty tags are also
immortal.

<p>Turfs and areas do not currently get garbage collected.

<p>When the world shuts down, all objects are destroyed, whether they are
referenced or not.  You don't have to worry about system memory getting
consumed by persistent objects.  That doesn't happen.

<p>In general, people who do not like reference counting garbage collection
should be happy that DM provides a <code>del</code> instruction, allowing you
to take charge and delete things whether they are referenced or not.  Another
nicety is that this automatically nulls out any existing references to the
object, so you don't end up with dangling references to a deleted object,
which can otherwise be a great source of instability and mysterious bugs.

<hr>

<a name=/DM/icon>
<h2>icons</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/preprocessor/define/FILE_DIR>FILE_DIR definition</a>
<dd><a href=#/DM/cache>cache</a>
<dd><a href=#/proc/flick>flick proc</a>
<dd><a href=#/icon>icon</a>
<dd><a href=#/atom/var/icon>icon var (atom)</a>
<dd><a href=#/atom/var/icon_state>icon_state var (atom)</a>
<dd><a href=#/image>image objects</a>
</dl>

<p>An icon file may be referenced by putting single quotes around the
filename.  The file extension determines the type of icon.  Currently
supported icon types are <code>.dmi</code>, <code>.bmp</code>, <code>.png</code>,
<code>.jpg</code>, and <code>.gif</code>.  To create dmi icons, use the Dream
Maker icon editor.  This allows you to make animations, 4 or 8 directional icons,
and icons with different states (such as "live" and "dead").

<h3>Example:</h3>
<xmp>
  mob
    icon = 'monster.dmi'
</xmp>

<p>You can also load icons into memory at run-time and manipulate the
graphical data to produce new icons dynamically.  This is done by creating an
<a href=#/icon>/icon</a> object.

<hr>

<a name=/DM/icon/arithmetic>
<h2>icon arithmetic</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/icon>icon proc</a>
<dd><a href=#/proc/icon_states>icon_states proc</a>
<dd><a href=#/DM/icon>icons</a>
<dd><a href=#/proc/rgb>rgb proc</a>
<dd><a href=#/proc/turn/icon>turn proc (applied to an icon)</a>
</dl>

<p>NOTE: the following "arithmetical" methods of icon manipulation are being
phased out in favor of the new <a href=#/icon> /icon</a> object, which can be
directly manipulated and which provides a wider variety of operations.

<p>There are several ways in which icons can be manipulated at runtime.
They can be rotated, added together, and the colors components may be
altered.

<p>One purpose for such operations is to make players look different.  Other
interesting uses (and abuses) will undoubtedly follow.

<h3>Addition and Subtraction</h3>

<p>The result of adding two icons is an arithmetic combination of the color
components of each individual pixel.  At positions where either icon is
transparent, the result is also transparent.  Subtraction, instead of
increasing the intensity, decreases it by the amount in each pixel of the
icon being subtracted.

<p>Suppose you wanted to add together different bodies and heads.  You could
do that by making a few of each type with black backgrounds.  When these add
together, the black contributes nothing but prevents pixels in the other
icon from getting clipped.

<h3>Example:</h3>
<xmp>
mob/verb
   addicon(I as icon)
      icon += I
   subicon(I as icon)
      icon -= I
</xmp>

<p>If you need to add the same color to every pixel, you can do so using a
color value.  Color values have the same format as in HTML: "#RRGGBB" with
two hexadecimal digits for each color component.  That gives you a range in
color from 0 to FF (which is 255 in decimal).

<p>You can also specify a color value as "#RGB".  The single digit is
automatically repeated, so "#F00" is the same as "#FF0000", which is bright
red.  For certain pre-defined color values, you can also specify a name,
such as "red".  See <a href=#/DM/text/tags/colors>HTML colors</a> for a list
of color names.

<p>If you prefer base 10, you can create color values with the rgb(R,G,B)
instruction.  Each parameter is in the range 0 to 255.

<h3>Multiplication</h3>

<p>To increase (or decrease) the intensity of an icon multiplicatively, you
can use the '<code>*</code>' operator.

<h3>Example:</h3>
<xmp>
mob/verb/multicon(factor as num)
   icon *= factor
</xmp>

<hr>

<a name=/DM/mouse>
<h2>mouse control</h2>

<p>Various mouse actions may be handled by defining procedures either on the
client object or on the atomic object being manipulated.  Any of the following
procedures may be defined:

<ul>
<li><a href=#/client/proc/MouseDown>MouseDown()</a>
<li><a href=#/client/proc/MouseUp>MouseUp()</a>
<li><a href=#/client/proc/MouseDrag>MouseDrag()</a>
<li><a href=#/client/proc/MouseDrop>MouseDrop()</a>
<li><a href=#/client/proc/MouseEntered>MouseEntered()</a>
<li><a href=#/client/proc/MouseExited>MouseExited()</a>
<li><a href=#/client/proc/MouseMove>MouseMove</a>
<li><a href=#/client/proc/MouseWheel>MouseWheel</a>
<li><a href=#/client/proc/Click>Click()</a>
<li><a href=#/client/proc/DblClick>DblClick()</a>
</ul>

<p>In general, define only the procedures you need, because extra
communication overhead may be avoided when the compiler detects that you do
not care about certain events.

<p>The arguments used in mouse procs generally follow one of these forms:

<dl>
<dt>For Click(), DblClick(), MouseDown(), MouseUp(), MouseEntered(), MouseExited(), and MouseMove():</dt>
  <dd>client/Click(object, location, control, params)<br/>
  atom/Click(location, control, params)</dd>
<dt>For MouseDrag() and MouseDrop():</dt>
  <dd>client/MouseDrag(src_object, over_object, src_location, over_location, src_control, over_control, params)<br/>
  atom/MouseDrag(over_object, src_location, over_location, src_control, over_control, params)</dd>
<dt>For MouseWeel():</dt>
  <dd>client/MouseWheel(object, delta_x, delta_y, location, control, params)<br/>
  atom/MouseWheel(delta_x, delta_y, location, control, params)</dd>
</dl>

<p>The <tt>location</tt> argument varies with the type of control. For the map, it
will be the turf where the mouse action happened. For info controls (statpanels),
it will be the name of the statpanel where the action happened. For grid controls,
it will be the cell where the action happened. For others controls it may vary,
but most will leave this blank.

<p>The <tt>control</tt> argument is the ID of the skin control where the
action happened, such as <tt>"mappane.map"</tt> or <tt>"mainwindow.banner"</tt>.

<p>The <tt>params</tt> argument is text, and can be converted to a list using
<a href="#/proc/params2list"><tt>params2list()</tt></a>. It may contain any of
the following properties, which will only be set if they are used:

<ul>
<li>icon-x, icon-y: Pixel coordinates within the icon; 1,1 is the lower left
<li>screen-loc: Pixel coordinates in screen_loc format ("[tile_x]:[pixel_x],[tile_y]:[pixel_y]")
<li>left, middle, right: Mouse buttons pressed/held/released
<li>ctrl, shift, alt: Keys held down during the mouse action
<li>drag-cell, drop-cell: Cells involved if using a Grid control
</ul>

<p>The mouse pointer may be customized as well.  The following variables all
deal with the appearance of the pointer.  They do not control what actions may
be taken by the user, but they provide hints to the user about what actions
may work.

<ul>
<li><a href=#/client/var/mouse_pointer_icon>mouse_pointer_icon</a>
<li><a href=#/atom/var/mouse_over_pointer>mouse_over_pointer</a>
<li><a href=#/atom/var/mouse_drag_pointer>mouse_drag_pointer</a>
<li><a href=#/atom/var/mouse_drop_pointer>mouse_drop_pointer</a>
<li><a href=#/atom/var/mouse_drop_zone>mouse_drop_zone</a>
<li><a href=#/atom/var/mouse_opacity>mouse_opacity</a>
</ul>

<p>When selecting a mouse pointer, you may provide your own custom icon or use
one of the <a href=#/DM/mouse/pointers>built-in pointers</a>.

<p><b>Note:</b> Older games compiled prior to BYOND 4.0 had a different format
for the MouseDown() and MouseUp() procs. These used icon_x and icon_y as arguments,
but control and params have replaced them.

<hr>

<a name=/DM/mouse/pointers>
<h2>mouse pointers</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/mouse>mouse control</a>
<dd><a href=#/atom/var/mouse_drag_pointer>mouse_drag_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_drop_pointer>mouse_drop_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_drop_zone>mouse_drop_zone var (atom)</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var (atom)</a>
<dd><a href=#/atom/var/mouse_over_pointer>mouse_over_pointer var (atom)</a>
<dd><a href=#/client/var/mouse_pointer_icon>mouse_pointer_icon var (client)</a>
</dl>

<p>The following mouse pointers are built-in and may be assigned to any of the
mouse pointer variables.  Of course, you can also define your own custom mouse
pointers using an icon file.

<dl>
<dt>MOUSE_INACTIVE_POINTER (0)
<dt>MOUSE_ACTIVE_POINTER (1)
<dt>MOUSE_DRAG_POINTER
<dd>Same as mouse_drag_pointer = MOUSE_ACTIVE_POINTER.
<dt>MOUSE_DROP_POINTER
<dd>Same as mouse_drop_pointer = MOUSE_ACTIVE_POINTER.
<dt>MOUSE_ARROW_POINTER
<dd>Same as mouse_over_pointer = MOUSE_INACTIVE_POINTER.
<dt>MOUSE_CROSSHAIRS_POINTER
<dd>Same as mouse_over_pointer = MOUSE_ACTIVE_POINTER.
<dt>MOUSE_HAND_POINTER
</dl>

<hr>

<a name=/DM/null>
<h2>null</h2>

<p>Variables that are not initialized have the value null.  This value is
distinct from 0 and "".  If you compare it to these, using the <code>==</code>
operator, it is not equal.  However, in a numeric context (like a mathematical
operation), null evaluates to 0 and in a text context (like insertion into a
text expression), null evaluates to "".  In a logical expression, null, 0, and
"" evaluate to false and all other values are true.

<p>In an embedded text expression, null behaves like "".  That means, if you
are expecting a variable to display a 0, you should explicitly initialize it
to 0 rather than leaving it as null.

<hr>

<a name=/DM/preprocessor>
<h2>preprocessor</h2>

<p>The preprocessor performs various transformations on source code as the DM
compiler reads the file.  It may be used to define macros--that is words
which are replaced by other fragments of code.  It is also possible to insert
other source code files and to conditionally compile or not compile sections
of code.

<p>Preprocessor commands are called directives.  They are placed on a line by
themselves and always begin with a hash symbol <code>#</code>.  The
preprocessor directives recognized by DM are the same as standard C compilers:

<code><pre>
<a href=#/DM/preprocessor/define>#define</a>
<a href=#/DM/preprocessor/if>#if</a>
<a href=#/DM/preprocessor/elif>#elif</a>
<a href=#/DM/preprocessor/ifdef>#ifdef</a>
<a href=#/DM/preprocessor/ifndef>#ifndef</a>
<a href=#/DM/preprocessor/else>#else</a>
<a href=#/DM/preprocessor/endif>#endif</a>
<a href=#/DM/preprocessor/include>#include</a>
<a href=#/DM/preprocessor/error>#error</a>
<a href=#/DM/preprocessor/warn>#warn</a>
</pre></code>

<hr>

<a name=/DM/preprocessor/DM_VERSION>
<h2>DM_VERSION macro</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/byond_version>byond_version var (world)</a>
<dd><a href=#/client/var/byond_version>byond_version var (client)</a>
<dd><a href=#/DM/preprocessor>preprocessor</a>
</dl>

<p>This macro indicates the version of the compiler.  This could be useful when
distributing code that uses new language features that would not compile in
older compilers.

<h3>Example:</h3>
<xmp>
#if DM_VERSION < 230
#error This compiler is too far out of date!
#endif
</xmp>

<hr>

<a name=/DM/preprocessor/__FILE__>
<h2>__FILE__ macro</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/ASSERT>ASSERT proc</a>
<dd><a href=#/DM/preprocessor/define/DEBUG>DEBUG definition</a>
<dd><a href=#/DM/preprocessor/__LINE__>__LINE__ macro</a>
<dd><a href=#/DM/preprocessor/__MAIN__>__MAIN__ macro</a>
</dl>

<p>The __FILE__ macro expands to a string containing the name of the current
source file.  This may be useful when generating debugging error messages.

<hr>

<a name=/DM/preprocessor/__LINE__>
<h2>__LINE__ macro</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/ASSERT>ASSERT proc</a>
<dd><a href=#/DM/preprocessor/define/DEBUG>DEBUG definition</a>
<dd><a href=#/DM/preprocessor/__FILE__>__FILE__ macro</a>
</dl>

<p>The __LINE__ macro is replaced by the line number in the current source
file.  This may be useful when generating debugging error messages.

<hr>

<a name=/DM/preprocessor/__MAIN__>
<h2>__MAIN__ macro</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/preprocessor>preprocessor</a>
</dl>

<p>The __MAIN__ macro is defined in the main <code>.dme</code> file being
compiled.  In all other files included by this file, __MAIN__ is not defined.

<p>The purpose of this is for library writers to package a small demo of their
library directly in the library source code.  When users compile the library
directly, the library's own <code>.dme</code> is the main file and can include
extra files that are not normally part of the library.

<h3>Example:</h3>
<xmp>
#ifdef __MAIN__
#include "demo.dm"
#include "demo.dmm"
#endif
</xmp>

<p>If the demo requires a lot of extra resources, it is probably better to
package the demo as a separate project.  Small demos, however, are nice and
convenient using this "auto-demo" technique--especially since Dream Seeker
automatically launches Dream Maker after installing a library containing a
<code>.dme</code> file.

<hr>

<a name=/DM/preprocessor/define>
<h2>#define directive</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/preprocessor>preprocessor</a>
</dl>

<dl><dt><b>Format:</b>
<dd>#define Name Value
<dd>#define Name(Parameters) Value
</dl>

<dl><dt><b>Args:</b>
<dd>Name:  A macro definition.
<dd>Value: The value to substitute for Name.
<dd>Parameters:  Arguments to pass into the macro.
</dl>

<p>The #define statement creates a macro that is substituted for Name.
Substitution only applies to whole words.  Text inside of double or single
quotes is not processed for substitution, so <code>"This is BIG."</code> would
not be modified even if a macro named BIG were defined.  That is different
from <code>"This is [BIG]."</code>, where BIG is an embedded expression, which
does get processed for macro substitution.

<h3>Example:</h3>
<xmp>
#define DAY   0
#define NIGHT 1
var/daytime = NIGHT  //daytime = 1
</xmp>

<h3>Example:</h3>
<xmp>
#define SQR(X) ((X)*(X))
var/x = SQR(2)       //x = ((2)*(2)) = 4
</xmp>

<p>Note that it's usually important to use parentheses around any arguments
you use in a macro. Otherwise strange results may occur if you use an
expression such as 2+3. In the SQR(X) example, if there were no parentheses
around each X then the expansion of the macro would be (2+3*2+3). Since the *
operator has a higher precedence than + the result is 11, not 25 as expected.
It's equally important to put parentheses around the entire macro for the
same reason.

<h3>Advanced macros</h3>

<p>The last parameter of a macro can end in ... which means that it and all
other arguments following it count as a single argument. This is called a
variadic macro because it lets you use a variable number of arguments. The
last parameter will also become optional.

<h3>Example:</h3>
<xmp>
#define DEFAULT_LIST(n, items...) if(!n) n = list(items)
</xmp>

<p>In a macro's body, if you precede a parameter by <code>#</code>, the
replacement value will be turned into a string.  For instance, 2 would become
"2".

<h3>Example:</h3>
<xmp>
#define DEBUG_VAR(v) world.log << #v + " = [v]"
DEBUG_VAR(x)   // world.log << "x" + " = [x]"
</xmp>

<p>A parameter preceded by <code>##</code> in the macro body is substituted
directly, without any spaces. If you use this with the last argument in a
variadic macro, any preceding spaces and a comma (if found) will be removed
if the replacement is empty.

<h3>Example:</h3>
<xmp>
#define MACROVAR(k) var/macro_state_##k
// MACROVAR(right) becomes var/macro_state_right

#define PREFIX_LIST(x, y...) list(x, src, ##y)
// PREFIX_LIST(1, 2, 3) becomes list(1, src, 2, 3)
// PREFIX_LIST(4) becomes list(4, src)
</xmp>

<p>Using <code>###</code> in the macro body, preceded by a number, will
repeat the replacement a certain number of times.

<h3>Example:</h3>
<xmp>
#define SAYTWICE(t) 2###t
#define TOTEXT(t) #t
world << "[TOTEXT(SAYTWICE(hi))]"   // world << "hihi"
</xmp>

<hr>

<a name=/DM/preprocessor/define/DEBUG>
<h2>DEBUG definition</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/preprocessor/define>#define directive</a>
</dl>

<dl><dt><b>Format:</b>
<dd>#define DEBUG
</dl>

<p>If <code>DEBUG</code> is defined, source file and line number information
will be stored in the compiled <code>.dmb</code> file.  If a proc crashes
during execution and <code>DEBUG</code> information is present, the current
source file name and line number will be indicated in the error output.

<p>This option increases the size of the <code>.dmb</code>, typically by about
10%.  Execution of the code may also be a tiny bit slower.

<p>If you are distributing the <code>.dmb</code> to players and you do not
want them to have debug access at runtime, you should <em>not</em> compile in
debug mode.

<p>If you want to use the run-time profiler (see the debugging options in
Dream Seeker), you must compile in debug mode.  Then you can get a report of
CPU usage by your various procs.

<hr>

<a name=/DM/preprocessor/define/FILE_DIR>
<h2>FILE_DIR definition</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/cache>cache</a>
<dd><a href=#/DM/icon>icons</a>
</dl>

<dl><dt><b>Format:</b>
<dd>#define FILE_DIR Path
</dl>

<dl><dt><b>Args:</b>
<dd>Path: A search path on the current filesystem.
</dl>

<p>This macro defines a search path to be used in evaluating resource files
(icons and sounds).  First the current directory is searched, then the first
<code>FILE_DIR</code> path, then the next, etc.

<h3>Example:</h3>
<xmp>
#define FILE_DIR icons
#define FILE_DIR icons/mobs

mob/clown
  icon = 'clown.dmi'
</xmp>

<p>This searches for the file at the paths <code>"./clown.dmi"</code>,
<code>"./icons/clown.dmi"</code>, and <code>"./icons/sounds/clown.dmi"</code>,
where <code>"."</code> is the directory of the current source file.

<hr>

<a name=/DM/preprocessor/elif>
<h2>#elif directive</h2>

<dl><dt><b>See:</b>
<dd><a href=#/DM/preprocessor/if>#if directive</a>
</dl>

<hr>

<a name=/DM/preprocessor/else>
<h2>#else directive</h2>

<dl><dt><b>See:</b>
<dd><a href=#/DM/preprocessor/if>#if directive</a>
</dl>

<hr>

<a name=/DM/preprocessor/endif>
<h2>#endif directive</h2>

<dl><dt><b>See:</b>
<dd><a href=#/DM/preprocessor/if>#if directive</a>
</dl>

<hr>

<a name=/DM/preprocessor/error>
<h2>#error directive</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/preprocessor>preprocessor</a>
<dd><a href=#/DM/preprocessor/warn>#warn directive</a>
</dl>

<dl><dt><b>Format:</b>
<dd>#error Text
</dl>

<dl><dt><b>Args:</b>
<dd>Text: an error message to display
</dl>

<p>The #error directive halts compilation and displays the specified message.

<h3>Example:</h3>
<xmp>
#if DM_VERSION < 4
#error This compiler is too far out of date!
#endif
</xmp>

<hr>

<a name=/DM/preprocessor/if>
<h2>#if directive</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/preprocessor/define>#define directive</a>
<dd><a href=#/DM/preprocessor/ifdef>#ifdef directive</a>
</dl>

<dl><dt><b>Format:</b>
<dd>#if Val
<dd>...
<dd>#elif Val2
<dd>...
<dd>#else
<dd>...
<dd>#endif
</dl>

<dl><dt><b>Args:</b>
<dd>Val: A logical expression.
</dl>

<p>The <code>#if</code> statement is used to conditionally compile code.  If
Val is true (non-zero), the code following the <code>#if</code> statement
will be compiled.  Otherwise, compilation skips to the next
<code>#elif</code>, <code>#else</code>, or <code>#endif</code> statement.

<p>The function <code>defined()</code> can be used in the conditional
expression.  It is true if its argument is a defined macro (with
<code>#define</code>) and false otherwise.

<h3>Example:</h3>
<xmp>
#if defined(DEBUG)
// This code will be compiled if DEBUG is
// defined
#else
// This code will be compiled if DEBUG is
// not defined
#endif
</xmp>

<hr>

<a name=/DM/preprocessor/ifdef>
<h2>#ifdef directive</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/preprocessor/define>#define directive</a>
<dd><a href=#/DM/preprocessor/if>#if directive</a>
<dd><a href=#/DM/preprocessor/ifndef>#ifndef directive</a>
</dl>

<dl><dt><b>Format:</b>
<dd>#ifdef Name
</dl>

<dl><dt><b>Args:</b>
<dd>Name: A macro definition.
</dl>

<p>The <code>#ifdef</code> statement is used to conditionally compile code.  It
is equivalent to <code>#if defined(Name)</code>.

<hr>

<a name=/DM/preprocessor/ifndef>
<h2>#ifndef directive</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/preprocessor/define>#define directive</a>
<dd><a href=#/DM/preprocessor/if>#if directive</a>
<dd><a href=#/DM/preprocessor/ifdef>#ifdef directive</a>
<dd><a href=#/DM/preprocessor>preprocessor</a>
</dl>

<dl><dt><b>Format:</b>
<dd>#ifndef Name
</dl>

<dl><dt><b>Args:</b>
<dd>Name: A macro definition.
</dl>

<p>The <code>#ifndef</code> statement is used to conditionally compile code.
It is equivalent to <code>#if !defined(Name)</code>.

<hr>

<a name=/DM/preprocessor/include>
<h2>#include directive</h2>

<dl><dt><b>Format:</b>
<dd>#include "Filename"
<dd>#include &lt;Filename&gt;
</dl>

<dl><dt><b>Args:</b>
<dd>"Filename": The path to the filename to include, from the current
    directory.
<dd>&lt;Filename&gt;: The path inside the BYOND lib directory.
</dl>

<p>The <code>#include</code> statement causes the compiler to process another
file before continuing in the current source file.

<p>If a file is included multiple times, only the first occurrence will be
processed.  That is a convenient addition to the standard C preprocessor,
which DM otherwise emulates quite closely.

<p>The file <code>&lt;stddef.dm&gt;</code> is automatically included before
all other source code.

<h3>Example:</h3>
<xmp>
#include "test.dm" // checks ./test.dm
#include <test.dm> // checks lib-path/test.dm
</xmp>

<p>The BYOND lib directory is called <code>"lib"</code> and is located in the
BYOND system directory (typically <code>"\Program Files\Byond\lib"</code>).
If the file is not found there, it also looks in the user lib directory, which
would typically be <code>"...\Byond\user\<i>login-name</i>\lib"</code>.

<p>Note that the compiler interface allows you to include files graphically by
simply clicking the checkbox next to the file.  This creates an include
statement for you in the <code>.dme</code> project environment file.  The only
time you would still want to manually include files is when you need to ensure
a certain order of processing.  For example, if file <code>"MyCode.dm"</code>
overrides procedure definitions of an object defined in
<code>"LibCode.dm"</code>, you should include <code>"LibCode.dm"</code> at the
top of <code>"MyCode.dm"</code>.  Most other DM code is independent of order,
but overriding procedure definitions is not.  The compiler will warn you in
such cases if you forget.

<p>Another case in which you should manually include files is if you are
writing a library to be used by other programmers.  Since the
<code>.dme</code> file is not distributed with a library, all necessary
inclusions must be made in the <code>.dm</code> files.

<hr>

<a name=/DM/preprocessor/undef>
<h2>#undef directive</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/preprocessor/define>#define directive</a>
<dd><a href=#/DM/preprocessor>preprocessor</a>
</dl>

<dl><dt><b>Format:</b>
<dd>#undef Name
</dl>

<dl><dt><b>Args:</b>
<dd>Name: A macro definition.
</dl>

<p>The <code>#undef</code> statement removes a macro definition.

<hr>

<a name=/DM/preprocessor/warn>
<h2>#warn directive</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/preprocessor>preprocessor</a>
<dd><a href=#/DM/preprocessor/error>#error directive</a>
</dl>

<dl><dt><b>Format:</b>
<dd>#warn Text
</dl>

<dl><dt><b>Args:</b>
<dd>Text: a warning message to display
</dl>

<p>The #warn directive displays the specified message as a warning, but does
not prevent the project from compiling.

<h3>Example:</h3>
<xmp>
#ifdef USE_LIGHTING
#warn The lighting feature in MyLibrary is experimental.
#endif
</xmp>

<hr>

<a name=/DM/sound>
<h2>sounds</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/preprocessor/define/FILE_DIR>FILE_DIR definition</a>
<dd><a href=#/DM/cache>cache</a>
<dd><a href=#/proc/sound>sound proc</a>
<dd><a href=#/sound>/sound datum</a>
</dl>

<p>A sound stored in a file may be referenced by putting single quotes around
the filename.  The file extension determines the type of sound.  Currently
supported music types include MIDI (.mid or .midi), and module formats .mod, .it,
.s3m, .xm, and .oxm. Supported sound effect formats include .wav, .ogg, .raw,
.wma, and .aiff.*

<h3>Example:</h3>
<xmp>
world << sound('fugue.midi')
</xmp>

<p>This example plays the specified midi file to all players.

<h3>Notes</h3>
<p><small>*The MP3 format is not presently supported by BYOND due to licensing
issues. Ogg-Vorbis, however, is a good alternative. For music the module
formats are also a good choice, and tend to be smaller.</small>

<hr>

<a name=/DM/text>
<h2>text</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&lt;&lt;/output>&lt;&lt; output operator</a>
<dd><a href=#/DM/text/entities>entities (text)</a>
<dd><a href=#/DM/text/macros>macros (text)</a>
<dd><a href=#/DM/text/tags>tags (text)</a>
<dd><a href=#/proc/text>text proc</a>
</dl>

<p>Text consists of a string of characters enclosed in double quotes.  To
place a quote inside a string, escape it with <code>\</code>.


<h3>Example:</h3>
<xmp>
usr << "He said, \"Hi.\""
</xmp>

<p>This example sends some text to the usr:  <code>He said, "Hi."</code>

<p>To insert a variable expression into a string, enclose it in brackets
<code>[]</code>.  These are referred to as embedded text expressions.  An
object expression will display the object's name preceded by the text macro
<code>\the</code> or <code>\The</code> if no other article has been
specified.  Capitalization of the article is inferred from context.


<h3>Example:</h3>
<xmp>
mob/verb/shout(T as text)
  world << "[usr]: [T]"
</xmp>

<p>If this example is called by a mob named "Bill" with the text "hi
everybody!", it will display "Bill: hi everybody!".

<p>On the other hand, if it is called by a mob named "cat", it would display
"The cat: hi everybody!".

<p>For lengthy text strings, DM provides a special text <em>document</em>
syntax.  This begins with <code>{"</code> and ends with <code>"}</code>.  It
may include multiple lines and even un-escaped double quotes.

<h3>Example:</h3>
<xmp>
mob/verb/end()
  usr << {"
This is the way the world ends
This is the way the world ends
This is the way the world ends
Not with a bang but a whimper.

--T.S. Eliot "Hollow Men"
"}
  del world  //the end!
</xmp>

<hr>

<a name=/DM/text/entities>
<h2>entities (text)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/text/macros>macros (text)</a>
<dd><a href=#/DM/text/tags>tags (text)</a>
<dd><a href=#/DM/text>text</a>
</dl>

<p>Special characters may be inserted into text using HTML syntax.  Such
characters are known as entities.  They start with an ampersand and end with a
semicolon.  The main reason for doing this is to insert characters that
otherwise have a special meaning.  The most common entities have names.  The
rest must be referred to by their ASCII number (e.g. &amp;#38; is the same as
&amp;amp;).  The common ones are listed in the following table.  Note that the
same effect may be achieved by simply escaping the special character (like
<code>\&lt;</code>).  The full entity syntax is included for generality.

<table border>
<tr><td><code>&amp;amp;</code></td>    <td>&amp;</td></tr>
<tr><td><code>&amp;lt;</code></td>     <td>&lt;</td></tr>
<tr><td><code>&amp;gt;</code></td>     <td>&gt;</td></tr>
<tr><td><code>&amp;quot;</code></td>   <td>&quot;</td></tr>
<tr><td><code>&amp;copy;</code></td>   <td>&copy;</td></tr>
</table>

<hr>

<a name=/DM/text/macros>
<h2>macros (text)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/text/macros/icon>icon text macro</a>
<dd><a href=#/DM/text>text</a>
<dd><a href=#/proc/text>text proc</a>
</dl>

<p>Text macros start with '\' (a backslash) and end with a space or other
punctuation.

<xmp>
\the, \The // insert 'the' (if needed)
\a, \an,   // insert 'a(n)' or 'some' (if needed)
\A, \An

\he, \He   // insert 'he/she/they/it'
\she, \She // same
\his, \His // insert 'his/her/their/its'
\him       // insert 'him/her/them/it'
\himself   // insert 'himself/herself/themself/itself'
\herself   // same
\hers      // insert 'his/hers/theirs/its'

\proper    // used in an object name to force proper-noun behavior
\improper  // used in an object name to force improper-noun behavior

\th        // insert 1st, 2nd, 5th etc.
\s         // insert 's' if [] was plural
\icon      // insert icon of following []
\ref       // insert a unique id for following []
\roman     // insert following [] as a lower-case roman numeral
\Roman     // insert following [] as an upper-case roman numeral
\...       // suppress final new line
\n         // insert new line
\"         // insert double quote
\\         // insert backslash
\<         // insert &amp;lt; (less than)
\>         // insert &amp;gt; (greater than)
\(space)   // skip a space
\(newline) // skip a newline (and following space)
</xmp>

<h3>Example:</h3>
<xmp>
mob/verb/steal(M as mob,obj/O as obj in M)
  O.loc = usr
  view() << "[usr] finds \himself \an [O]."
</xmp>

<h3>Example:</h3>
<xmp>
var/DayCount
proc/NewDay()
  DayCount++
  world << "The [DayCount]\th day dawns."
</xmp>

<h3>Example:</h3>
<xmp>
obj/CPU
  name = "\improper CPU"  //prevent capitalization from causing proper-noun behavior
</xmp>

<hr>

<a name=/DM/text/macros/icon>
<h2>icon text macro</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/icon_state>icon_state var (atom)</a>
<dd><a href=#/DM/text/macros>macros (text)</a>
<dd><a href=#/DM/text/style>style sheets</a>
<dd><a href=#/DM/text/tags>tags (text)</a>
</dl>

<p>The </code>\icon</code> macro is used to treat the following embedded
expression (in []'s) as an icon rather than as text.  An object, for
example, would be replaced by its icon rather than by its name.

<h3>Example:</h3>
<xmp>
usr << "You look like this: \icon[usr]!"
</xmp>

<p>The <code>\icon</code> macro expands internally to the &lt;IMG&gt; tag.  The
above example, could be rewritten like this:

<xmp>
usr << "You look like this: \
  <IMG CLASS=icon SRC=\ref[usr.icon] ICONSTATE='[usr.icon_state]'>!"
</xmp>

<p>Note that the current icon state of the object is automatically used.
Also note that the image belongs to a class called <code>icon</code>.  That
allows you to configure the way icons are displayed by using a style sheet.
The following default style rule causes icons to be shrunk to 16 by 16
pixels so they fit in better with surrounding text:

<xmp>
IMG.icon {width: 16px; height: 16px}
</xmp>

<p>You could override this setting globally in your own style sheet.  You
could even define rules to allow individual icons to be formatted
differently from the rest.

<h3>Example:</h3>
<xmp>
BIG IMG.icon {width: 32px; height: 32px}
SMALL IMG.icon {width: 16px; height: 16px}
</xmp>

<p>With those rules in place, you could output a full sized icon by using
the &lt;BIG&gt; tag:

<xmp>
usr << "You look like this: <BIG>\icon[usr]</BIG>!"
</xmp>

<p>The one time that one might want to use the &lt;IMG&gt; tag directly is
to specify the ALT text to be displayed on clients which don't support
graphical icons.

<p>Specific states, directions, and frames of an icon can be displayed in lieu
of the default through use of the following tags:
<ul><li>ICONSTATE='[state]'
<li>ICONDIR=[dir], where dir is one of NORTH, SOUTH, EAST, WEST, NORTHEAST, NORTHWEST, SOUTHEAST, SOUTHWEST
<li>ICONFRAME=[frame], where frame is the animation frame, starting with 1</ul>

<h3>Example:</h3>
<xmp>
usr << "You look like this: \
  <IMG CLASS=icon SRC=\ref[usr.icon] ICONSTATE='glowing' ICONDIR=NORTH ICONFRAME=2>!"
</xmp>

<p>Note that the \icon macro does not work in the mini-browser; it is only
for text output. To make icons appear in an HTML document, use
<a href=#/proc/browse_rsc>browse_rsc()</a> to send an icon to the
client before using <a href=#/proc/browse>browse()</a> to display it.

<hr>

<a name=/DM/text/macros/ref>
<h2>ref text macro</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Topic>Topic proc (client)</a>
<dd><a href=#/DM/text/macros/icon>icon text macro</a>
<dd><a href=#/proc/locate>locate proc</a>
<dd><a href=#/DM/text/macros>macros (text)</a>
<dd><a href=#/datum/var/tag>tag var (datum)</a>
</dl>

<p>The <code>\ref</code> text macro inserts a unique identification number
or text string for the following embedded object (inside []'s).  If the
object has a tag, that will be used.  Otherwise, an internal id number is
used.  In either case, the embedded reference is surrounded by [] brackets.

<p>The reason the tag is preferred is that it stands a better chance of still
being valid if the object is deleted and recreated (like in a world
reboot).  The internal id number, on the other hand, is transient and should
only be expected to remain the same for the duration of the object's
existence.  If you want a more permanent reference, you must assign and save
the object's tag variable.

<p>The primary use for object references embedded in text is in topic links.
This allows you to encode a reference to an object in the href value of a
hyperlink.  (Just make sure the object does not get deleted before the user
executes the link.  See <a href=#/DM/garbage>garbage collection</a>.)

<p>Topic links that contain a parameter "src" assigned to an object reference
are treated somewhat specially.  Unless you override client.Topic() to do
otherwise, the default behavior is to call the referenced object's own Topic()
procedure.

<h3>Example:</h3>
<xmp>
mob/verb/test()
   usr << "Click <a href=?src=\ref[src];action=start>here</a>!"
mob/Topic(href,href_list[])
   switch(href_list["action"])
      if("start")
         usr << "Starting the game..."
      else
         return ..()
</xmp>

<p>The above example uses an embedded reference to the player's own mob to
create a link to a topic handled by that mob's Topic() proc.  The
<code>href_list</code> parameter is simply the result of
<code>params2list(href)</code>.

<p>In that example, the embedded reference was automatically converted back
into an object (dereferenced) for you.  If you embed references to additional
objects in the href data, you would have to dereference those yourself using
the locate() instruction.

<hr>

<a name=/DM/text/style>
<h2>style sheets</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/text/entities>entities (text)</a>
<dd><a href=#/DM/text/macros>macros (text)</a>
<dd><a href=#/client/var/script>script var (client)</a>
<dd><a href=#/DM/text/tags>tags (text)</a>
<dd><a href=#/DM/text>text</a>
</dl>

<p>HTML tags, such as <code>&lt;FONT&gt;</code> may be used to directly format
output text.  Another approach, however, is to use HTML tags to specify
purely structural information and use a style sheet to define how various
elements within that structure should be treated.  DM uses a subset of the
Cascading Style Sheet (CSS) language, which was introduced for this purpose
in HTML documents.

<p>This section discusses the syntax of style sheets as an independent
element.  For information on how to include the style sheets in your DM
code, see the section on <a href=#/client/var/script>client.script</a>.

<p>As an example of a style sheet, one might want combat and conversational
messages to appear differently--perhaps using different colors.  Instead of
using the <code>&lt;FONT&gt;</code> tag to color the text, you could use
<code>&lt;SPAN&gt;</code> to mark the beginning and ending of the text and
to specify what kind of message it is.  The result might be text such as the
following:

<xmp>
"[usr] <SPAN CLASS=combat>spanks</SPAN> [targ]!"
"[usr] says, '<SPAN CLASS=chat>[msg]</SPAN>'"
</xmp>

<p>The <code>CLASS</code> attribute may be used with any tag, but
<code>SPAN</code> and <code>DIV</code> are often convenient because they
have no other side-effect but defining the style class.  <code>SPAN</code>
is for text within a single paragraph and <code>DIV</code> is for whole
paragraphs.  The way text belonging to a particular class is formatted may be
controlled in a style sheet such as the following:

<xmp>
.combat {color: red}
.chat {color: green}
</xmp>

<p>This says that text in the 'combat' class should be colored red and text in
the 'chat' class should be colored green.  These classes are not pre-defined;
you can create whatever new style classes you need.

<p>The advantage of using style sheets instead of direct formatting tags is
that you can cleanly separate structural information (such as combat and
conversational messages) from formatting information (such as red and green
text).  By separating the two, you or the player can easily plug in
different formatting schemes without changing any of the actual content.

<p>A style sheet is composed of a list of rules, such as the two rules in the
preceding example.  Each rule contains one or more <EM>selectors</EM>
followed by a body of attribute assignments (in braces).  The selector
specifies the context of the rule and the body specifies the format.

<p>A selector may specify a container tag (such as <code>SPAN</code>,
<code>BODY</code>, or <code>P</code>) and a class.  The above example could
have been written with a selector of <code>SPAN.chat</code>.  However, by
leaving out the tag, it applies to any tag with <code>CLASS=chat</code>.  It
is also possible to only specify the tag and not the class.  In that case,
the selector applies to any matching tag, regardless of class.

<p>To specify a <EM>nested</EM> context, several simple selectors may be listed
one after the other.  For example, emphasized text within a combat message
could be enlarged with the following rule:

<xmp>
.combat EM {font-size: larger}
</xmp>

<p>It is also possible to list several selectors separated by commas in order
to make them all apply to the same body.  For example, this next rule is
equivalent to the two following ones:

<xmp>
.combat EM, .chat EM {font-size: larger}
.combat EM {font-size: larger}
.chat EM {font-size: larger}
</xmp>

<p>The style rule body contains a list of attribute assignments, delimited by
semicolons.  Each assignment takes the form of an attribute name, followed
by a colon, followed by the value of the attribute.  The following table
summarizes the recognized attributes and their possible values.

<table border>
<tr><td>color</td>           <td rowspan=2>#F00, #FF000, red, rgb(255,0,0), rgb(100%,0%,0%)</td>
<tr><td>background</td>
<tr><td>font-size</td>       <td>10pt, 1.5em, 150%</td>
<tr><td>font-style</td>      <td>normal or italic</td>
<tr><td>font-weight</td>     <td>normal, bold, lighter, darker, or 100 to 900</td>
<tr><td>font-family</td>     <td>monospace, sans-serif, serif, cursive, ...</td>
<tr><td>font</td>            <td>style weight size family</td>
<tr><td>text-decoration</td> <td>none or underline</td>
<tr><td>text-align</td>      <td>right, left, or center</td>
<tr><td>text-indent</td>     <td rowspan=3>0.25in, 3em, 20pt</td>
<tr><td>margin-left</td>
<tr><td>margin-right</td>
<tr><td>width</td>           <td rowspan=2>16px, 32px, auto</td>
<tr><td>height</td>
</table>

<h3>fonts</h3>

<p>The <code>font</code> attribute is a special short-hand for assigning
<code>font-size</code>, <code>font-style</code>, <code>font-weight</code>,
and <code>font-family</code> in one statement.  Any properties that are not
specified in the <code>font</code> statement are assigned to their default
values.

<p>The font family may be a specific font name or a more general category such
as monospace or sans-serif.  Since not all users necessarily have the same
fonts installed, it is a good idea to list alternate fonts.  The desired
font is placed first, followed by other possible fall-backs, each separated
by a comma.  Usually a general family such as monospace is listed last of
all.  Any font names containing a space should have quotes around them.

<p>The following example sets the font for the <code>&lt;BODY&gt;</code>
tag.  Even if you don't explicitly use <code>&lt;BODY&gt;</code> in output
text, it is applied implicitly.

<xmp>
BODY {font: 12pt 'Times New Roman', sans-serif}
</xmp>

<p>This sets the font to 12 point and selects <code>Times New Roman</code> if
it is available and otherwise falls back on a system-determined sans-serif
font.  This command also implicitly specifies not to use italics and to use a
normal font weight (not bold).

<p>Font sizes may be specified in points (1pt = 1/72 of an inch), picas (1pc
= 12pt), pixels (px), inches (in), centimeters (cm), and millimeters (mm).
There are also various levels corresponding to the traditional 1 to 7 HTML
scale.  These are xx-small, x-small, small, medium, large, x-large, and
xx-large.  In addition to these absolute font sizes, it is possible to use a
relative size, such as 150% or equivalently 1.5em.  This scales the font
relative to the currently active font setting.

<p>In addition to regular classes, there are special pseudo-classes for
handling embedded hyperlinks.  These are specified in the selector with the
class starting with a colon rather than a dot.  They are <code>:link</code>,
<code>:visited</code>, and <code>:active</code>.  These only apply to the
<code>&lt;A&gt;</code> tag.  The <code>:link</code> class applies to
hyperlinks in their normal state.  Once a link has been clicked, it belongs
instead to the <code>:visited</code> class.  When the user holds the mouse
over a link, it temporarily belongs to the <code>:active</code> class.  The
only attribute that may change in an active or visited link is the text
color.

<h3>margins and indents</h3>

<p>Paragraphs can be given different margins according to your preferences.
The <code>margin-left</code> attribute controls the left margin, and
<code>margin-right</code> is the right margin. You can use specific sizes
like inches or points, or a relative size unit like em or ex. (A percentage
is interpreted so that 100% is 1em, not the width of the window.) Using the
<code>text-indent</code> attribute will indent the first line of a paragraph
from the left margin. It is possible to create a hanging indent by using a
negative value for <code>text-indent</code>, like so:

<xmp>
BODY {text-indent: -0.5in; margin-left: 0.5in}
</xmp>


<h3>background colors</h3>

<p>The background attribute is only relevant to the BODY context.  It causes
the entire terminal background to change color.  When doing this, it is
usually necessary to change the foreground colors of text or it may become
unreadable.  The various standard classes of output generated by DreamSeeker
are in the following table.

<h3>system colors</h3>

<table border>
<tr><td>system notice</td>             <td>general notices from the client</td>
<tr><td>system command echo</td>       <td>command echoing</td>
<tr><td>system command expansion</td> <td>command-line expansion list</td>
<tr><td>system pager</td>              <td>pager messages</td>
<tr><td>system irc</td>                <td>IRC command prefix</td>
<table>

<p>The value of the CLASS attribute may contain a list of classes separated by
spaces.  This permits client output to be in the 'system' class as well as
more specific ones.  That allows you to change all of these colors in one
shot if you are too lazy to change them each individually.  For example, if
you define a style sheet that changes the background color, you might need to
redefine the various foreground colors like this:

<xmp>
BODY {background: aqua; color: black}
.system {color: red; font-weight: bold}
.command {color: green}
</xmp>

<p>In this example, the background color of the terminal will be aqua, normal
text from the server will be black, and all output from the client will be
bold and red, except echoed commands and expansion lists, which will be bold
and green.  The more specific .command rule is placed after the general
.system rule so that its color takes precedence.  This is how style sheets
are composed--you write general rules first followed by any exceptions.

<h3>style rule precedence</h3>

<p>The order in which rules are specified is one of the factors that determines
precedence of style sheet commands.  The language is known as Cascading Style
Sheets because of its ability to handle several layers of stylistic rules,
intermingling the configurations of the user and the designer in an ordered
fashion.

<p>Rules are selected by first finding all matching candidates for a given
attribute in the current HTML tag being processed.  If there is more than
one, rules from a higher level style sheet take precedence over lower level
ones.  That means the basic user configurable settings in DreamSeeker are
the lowest priority, followed by a style sheet in the user's
<code>.dms</code> script file, followed by a style sheet from the designer's
<code>client.script</code> setting, because that is the order in which these
are read by the style sheet manager.

<p>Rules from the same style sheet are ordered by specificity.  The selector
<code>SPAN.chat</code> is more specific than <code>.chat</code> and
<code>.chat EM</code> is more specific than <code>EM</code>.  In general,
the more classes referenced by a selector, the more specific it is.  When
that results in a tie, the selector with the greater number of tags takes
precedence.

<p>If two rules about the same attribute come from the same sheet and have the
same specificity, the final one to be defined takes precedence.

<p>In the rare event that a rule needs to break out of the normal order of
precedence, it can be flagged as important.  In this case it will take
precedence over all other "unimportant" rules.  However, if more than one
rule is important, the normal rules of precedence will be used to resolve
the conflict.

<p>The important flag is applied after the attribute assignment like this:

<xmp>
BODY {background: white ! important; font: serif}
</xmp>

<p>In the above example, only the background color is important, not the font
specification.

<h3>STYLE attribute</h3>

<p>Style commands may also be inserted directly in an html tag to control
its appearance.  This does not have the advantages of style sheets, which
separate content from presentation, but it does allow you to use the style
sheet syntax when formatting text.

<p>The following example uses the style attribute to color some text:

<xmp>
usr << "That <SPAN STYLE='color: red'>HURT</SPAN>!"
</xmp>

<p>As you can see, the <code>STYLE</code> attribute of any tag can be
assigned to a text string containing a list of attribute assignments.  Just
the body of the style rule is given, since no selector is needed to match
the current context.

<hr>

<a name=/DM/text/tags>
<h2>tags (text)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/text/entities>entities (text)</a>
<dd><a href=#/DM/text/macros>macros (text)</a>
<dd><a href=#/DM/text/style>style sheets</a>
<dd><a href=#/DM/text>text</a>
</dl>

<p>Text tags (also known as <em>elements</em> by snooty HTML purists) control
how the text is formatted.  HTML syntax is used, so all tags start with
<code>&lt;</code> and end with <code>&gt;</code>.  The tags which are
currently supported by Dream Seeker, are listed below:

<pre>
&lt;A&gt;&lt;/A&gt;              // anchor (hyperlink)
&lt;ACRONYM&gt;&lt;/ACRONYM&gt;  // acronym or abbreviation
&lt;B&gt;&lt;/B&gt;              // bold text
&lt;BIG&gt;&lt;/BIG&gt;          // one size bigger text
&lt;BODY&gt;&lt;/BODY&gt;        // body of html document
&lt;BR&gt;                 // line break
&lt;CITE&gt;&lt;/CITE&gt;        // citation reference
&lt;CODE&gt;&lt;/CODE&gt;        // program source code
&lt;DFN&gt;&lt;/DFN&gt;          // definition
&lt;DIV&gt;&lt;/DIV&gt;          // used in conjunction with style sheets
&lt;EM&gt;&lt;/EM&gt;            // emphasized text
&lt;FONT&gt;&lt;/FONT&gt;        // font face, color, and size
&lt;H1&gt;&lt;/H1&gt;            // heading level
&lt;H2&gt;&lt;/H2&gt;
&lt;H3&gt;&lt;/H3&gt;
&lt;H4&gt;&lt;/H4&gt;
&lt;H5&gt;&lt;/H5&gt;
&lt;H6&gt;&lt;/H6&gt;
&lt;HEAD&gt;&lt;/HEAD&gt;        // document head section
&lt;HTML&gt;&lt;/HTML&gt;        // html document
&lt;I&gt;&lt;/I&gt;              // italic text
&lt;IMG&gt;&lt;/IMG&gt;          // display icons
&lt;KBD&gt;&lt;/KBD&gt;          // keyboard input
&lt;P&gt;&lt;/P&gt;              // paragraph
&lt;PRE&gt;&lt;/PRE&gt;          // pre-formatted text
&lt;S&gt;&lt;/S&gt;              // overstrike text
&lt;SAMP&gt;&lt;/SAMP&gt;        // sample output
&lt;SMALL&gt;&lt;/SMALL&gt;      // one size smaller text
&lt;SPAN&gt;&lt;/SPAN&gt;        // used in conjunction with style sheets
&lt;STRONG&gt;&lt;/STRONG&gt;    // strongly emphasized text
&lt;STYLE&gt;&lt;/STYLE&gt;      // contains a style sheet
&lt;TITLE&gt;&lt;/TITLE&gt;      // document title
&lt;TT&gt;&lt;/TT&gt;            // typewriter style
&lt;U&gt;&lt;/U&gt;              // underline
&lt;VAR&gt;&lt;/VAR&gt;          // variable name
&lt;XMP&gt;&lt;/XMP&gt;          // preformatted (tags ignored)
</pre>

<p>In addition to these, the <code>&lt;BEEP&gt;</code> tag, which is not
standard HTML, may be used to beep the terminal.

<p>Some tags take additional parameters, known as attributes.  The most common
ones are <code>&lt;FONT&gt;</code> and <code>&lt;A&gt;</code>.
The syntax for these is illustrated by the following two examples:

<xmp>
"How about <FONT FACE=Arial COLOR=red SIZE=+1>this</FONT>!"
"Click <A HREF=byond.com TITLE=BYOND!>here</A>!"
</xmp>

<p>As many attributes may be specified as desired.  The attribute value may
have quotes around it, but this is only necessary if the value contains
spaces.  It is usually more convenient to use single quotes so you don't have
to escape the double quotes, but you can also embed the HTML in a
<a href=#/DM/text>text document</a> to avoid the need for escaping quotes.

<p>Text colors may be specified by name or RGB value.  The named colors and
their corresponding RGB value are listed in the following table:

<a name=/DM/text/tags/colors>
<table border>
<tr><td>black</td>   <td>#000000</td></tr>
<tr><td>silver</td>  <td>#C0C0C0</td></tr>
<tr><td>gray</td>    <td>#808080</td></tr>
<tr><td>grey</td>    <td>#808080</td></tr>
<tr><td>white</td>   <td>#FFFFFF</td></tr>

<tr><td>maroon</td>  <td>#800000</td></tr>
<tr><td>red</td>     <td>#FF0000</td></tr>
<tr><td>purple</td>  <td>#800080</td></tr>
<tr><td>fuchsia</td> <td>#FF00FF</td></tr>
<tr><td>magenta</td> <td>#FF00FF</td></tr>

<tr><td>green</td>   <td>#00C000</td></tr>
<tr><td>lime</td>    <td>#00FF00</td></tr>
<tr><td>olive</td>   <td>#808000</td></tr>
<tr><td>gold</td>   <td>#808000</td></tr>
<tr><td>yellow</td>  <td>#FFFF00</td></tr>

<tr><td>navy</td>    <td>#000080</td></tr>
<tr><td>blue</td>    <td>#0000FF</td></tr>
<tr><td>teal</td>    <td>#008080</td></tr>
<tr><td>aqua</td>    <td>#00FFFF</td></tr>
<tr><td>cyan</td>    <td>#00FFFF</td></tr>
</table>

<p>The hexadecimal colors above are written with 8 bits (two hex digits) for
each color.  It is also possible to use 4 bit values by using only one hex
digit per color.  The full 8 bit color is produced by repeating each digit.
For example, <code>#F00</code> (red) is the same as <code>#FF0000</code>.

<p>Text sizes range from 1 to 7, 1 being the smallest and 7 being the largest.
In addition to absolute sizes, relative sizes may be specified (like +1 for
one size bigger or -1 for one size smaller).

<hr>

<a name=/area>
<h2>area</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom>atom</a>
<dd><a href=#/area/proc>procs (area)</a>
<dd><a href=#/area/room>rooms</a>
<dd><a href=#/area/var>vars (area)</a>
</dl>

<p>Areas are derived from /area.  Regions on the map may be assigned to an
area by painting it onto the map.  Areas off the map serve as rooms that
objects may enter and exit.

<p>For each area type defined, one area object is created at runtime.  So for
areas on the map, all squares with the same area type belong to the same
instance of the area.

<p>Additional instances of rooms may be created from the same type by
explicitly creating them with null as the initial location.  That is, the
first argument to new() should either be <code>null</code> or left
unspecified.

<p>The following example defines the area prototype
<code>/area/outside</code>.  It also defines an action to be taken when
somebody enters an area, namely to display its description.

<h3>Example:</h3>
<xmp>
area
  Entered(O)
    if(desc) O << desc
    return ..()

  outside
    desc = "Ah!  A breath of fresh air!"
</xmp>

<hr>

<a name=/area/proc>
<h2>procs (area)</h2>

<p>Built-in area procs:

<dl><dt>area/proc
<dd><a href=#/atom/proc/Click>Click</a>
<dd><a href=#/atom/proc/DblClick>DblClick</a>
<dd><a href=#/datum/proc/Del>Del</a>
<dd><a href=#/atom/proc/Enter>Enter</a>
<dd><a href=#/atom/proc/Entered>Entered</a>
<dd><a href=#/atom/proc/Exit>Exit</a>
<dd><a href=#/atom/proc/Exited>Exited</a>
<dd><a href=#/atom/proc/MouseDown>MouseDown</a>
<dd><a href=#/atom/proc/MouseDrag>MouseDrag</a>
<dd><a href=#/atom/proc/MouseDrop>MouseDrop</a>
<dd><a href=#/atom/proc/MouseEntered>MouseEntered</a>
<dd><a href=#/atom/proc/MouseExited>MouseExited</a>
<dd><a href=#/atom/proc/MouseMove>MouseMove</a>
<dd><a href=#/atom/proc/MouseUp>MouseUp</a>
<dd><a href=#/atom/proc/MouseWheel>MouseWheel</a>
<dd><a href=#/atom/proc/New>New</a>
<dd><a href=#/datum/proc/Read>Read</a>
<dd><a href=#/atom/proc/Stat>Stat</a>
<dd><a href=#/datum/proc/Topic>Topic</a>
<dd><a href=#/datum/proc/Write>Write</a>
</dl>

<hr>

<a name=/area/room>
<h2>rooms</h2>

<p>Areas that are not located on the map are referred to as <em>rooms</em>.
When a player enters one, the map goes away and you have something like a text
MUD.  By default, there would be no way for players to move from one room to
another, so you have to handle movement yourself.

<p>You can check the variable <a href=#/atom/var/x>area.x</a> to see if a
given area is on the map or not.

<p>The following example puts players in a room when they log in and provides
a single exit.

<h3>Example:</h3>
<xmp>
mob/Login()
   if(!loc) Move(locate(/area/birthing_hut))
   return ..()

area/birthing_hut
   Entered(O)
      O << "Waaaaah!  You land in a pile of straw."
      return ..()
   verb/exit()
      if(Move(locate(1,1,1))) //jump to the map or whatever
         usr << "You crawl into the open air..."
      else
         usr << "The hut door is blocked.  You cannot get out."
</xmp>

<hr>

<a name=/area/var>
<h2>vars (area)</h2>

<p>Built-in area vars:

<dl><dt>area/var
<dd><a href=#/atom/var/alpha>alpha</a>
<dd><a href=#/atom/var/appearance>appearance</a>
<dd><a href=#/atom/var/appearance_flags>appearance_flags</a>
<dd><a href=#/atom/var/blend_mode>blend_mode</a>
<dd><a href=#/atom/var/color>color</a>
<dd><a href=#/atom/var/contents>contents</a>
<dd><a href=#/atom/var/density>density</a>
<dd><a href=#/atom/var/desc>desc</a>
<dd><a href=#/atom/var/dir>dir</a>
<dd><a href=#/atom/var/gender>gender</a>
<dd><a href=#/atom/var/icon>icon</a>
<dd><a href=#/atom/var/icon_state>icon_state</a>
<dd><a href=#/atom/var/invisibility>invisibility</a>
<dd><a href=#/atom/var/underlays>underlays</a>
<dd><a href=#/atom/var/overlays>overlays</a>
<dd><a href=#/atom/var/layer>layer</a>
<dd><a href=#/atom/var/luminosity>luminosity</a>
<dd><a href=#/atom/var/maptext>maptext</a>
<dd><a href=#/atom/var/maptext_width>maptext_width</a>
<dd><a href=#/atom/var/maptext_height>maptext_height</a>
<dd><a href=#/atom/var/maptext_x>maptext_x</a>
<dd><a href=#/atom/var/maptext_y>maptext_y</a>
<dd><a href=#/atom/var/mouse_over_pointer>mouse_over_pointer</a>
<dd><a href=#/atom/var/mouse_drag_pointer>mouse_drag_pointer</a>
<dd><a href=#/atom/var/mouse_drop_pointer>mouse_drop_pointer</a>
<dd><a href=#/atom/var/mouse_drop_zone>mouse_drop_zone var</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var</a>
<dd><a href=#/atom/var/name>name</a>
<dd><a href=#/atom/var/opacity>opacity</a>
<dd><a href=#/area/var/parent_type>parent_type</a>
<dd><a href=#/atom/var/plane>plane</a>
<dd><a href=#/atom/var/suffix>suffix</a>
<dd><a href=#/datum/var/tag>tag</a>
<dd><a href=#/atom/var/text>text</a>
<dd><a href=#/atom/var/transform>transform</a>
<dd><a href=#/datum/var/type>type</a>
<dd><a href=#/datum/var/vars>vars</a>
<dd><a href=#/atom/var/verbs>verbs</a>
</dl>

<hr>

<a name=/area/var/parent_type>
<h2>parent_type var (area)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/datum/var/parent_type>parent_type var</a>
</dl>

<p>The default parent_type of <a href=#/area>/area</a> is <a href=#/atom>/atom</a>.

<hr>

<a name=/atom>
<h2>atom</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/area>area</a>
<dd><a href=#/datum>datum</a>
<dd><a href=#/mob>mob</a>
<dd><a href=#/atom/movable>movable atoms</a>
<dd><a href=#/obj>obj</a>
<dd><a href=#/atom/proc>procs (atom)</a>
<dd><a href=#/turf>turf</a>
<dd><a href=#/atom/var>vars (atom)</a>
</dl>

<p>The /atom object type is the ancestor of all mappable objects in the
game.  The types /area, /turf, /obj, and /mob are all derived from /atom.
You should not create instances of /atom directly but should use /area,
/turf, /obj, and /mob for actual objects.  The /atom object type exists for
the purpose of defining variables or procedures that are shared by all of
the other "physical" objects.  These are also the only objects for which
verbs may be accessible to the user.

<p>/atom is derived from /datum, so it inherits the basic properties that
are shared by all DM objects.

<hr>

<a name=/atom/movable>
<h2>movable atoms</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom>atom</a>
<dd><a href=#/mob>mob</a>
<dd><a href=#/obj>obj</a>
<dd><a href=#/atom/movable/proc>procs (movable atoms)</a>
<dd><a href=#/atom/movable/var>vars (movable atoms)</a>
</dl>

<p>The /atom/movable object type is the ancestor of all mappable objects that
are capable of motion.  The types /obj and /mob are derived from
/atom/movable.  You should not create instances of /atom/movable but should
use /obj and /mob for actual objects.  This object definition exists solely
to define variables and procedures related to motion.

<hr>

<a name=/atom/movable/proc>
<h2>procs (movable atoms)</h2>

<p>Built-in movement procs:

<dl><dt>atom/movable/proc
<dd><a href=#/atom/movable/proc/Bump>Bump</a>
<dd><a href=#/atom/movable/proc/Move>Move</a>
<dd><a href=#/atom/movable/proc/Cross>Cross proc</a>
<dd><a href=#/atom/movable/proc/Crossed>Crossed proc</a>
<dd><a href=#/atom/movable/proc/Uncross>Uncross proc</a>
<dd><a href=#/atom/movable/proc/Uncrossed>Uncrossed proc</a>
</dl>

<hr>

<a name=/atom/movable/proc/Bump>
<h2>Bump proc (movable atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/movable/proc/Move>Move proc (movable atom)</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Bump(atom/Obstacle)
</dl>

<dl><dt><b>When:</b>
<dd>Called when a movement fails due to a dense blockage.
</dl>

<dl><dt><b>Args:</b>
<dd>Obstacle: The blocking object.
</dl>

<dl><dt><b>Default action:</b>
<dd>If the obstacle is a mob and src is in its group, swap their positions.
This is only done if the mobs both move by full tiles and do not use pixel
movement, to preserve the behavior of older games.
</dl>

<hr>

<a name=/atom/movable/proc/Cross>
<h2>Cross proc (movable atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/Enter>Enter proc (atom)</a>
<dd><a href=#/atom/proc/Entered>Entered proc (atom)</a>
<dd><a href=#/atom/proc/Exit>Exit proc (atom)</a>
<dd><a href=#/atom/proc/Exited>Exited proc (atom)</a>
<dd><a href=#/atom/movable/proc/Crossed>Crossed proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Uncross>Uncross proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Uncrossed>Uncrossed proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Move>Move proc (movable atom)</a>
<dd><a href=#/mob/var/group>group var (mob)</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Cross(atom/movable/O)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 to permit; 0 to deny.
</dl>

<dl><dt><b>When:</b>
<dd>Called when another object attempts to overlap this one.
</dl>

<dl><dt><b>Args:</b>
<dd>O: the object attempting to overlap.
</dl>

<dl><dt><b>Default action:</b>
<dd>Allow overlap unless both atoms are dense. If both atoms are mobs, the
behavior depends partly on whether they are in the same group.
</dl>

<p>If src completely covers the turf it is standing on, Cross() is called as
part of turf.Enter(). This is to preserve the behavior of older games, which
expect turf.Enter() to care about its contents.

<p>If src and O are both mobs, and O is in src's group, overlap is allowed
<i>unless</i> neither of them use pixel movement. Older games that do not use
pixel movement expect that Bump() will be called, and by default Bump() will
swap the mobs' positions. Swapping obviously only works in situations where a
mob takes up a whole tile and only moves by tiles; for all other situations,
allowing an overlap makes more sense.

<hr>

<a name=/atom/movable/proc/Crossed>
<h2>Crossed proc (movable atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/Enter>Enter proc (atom)</a>
<dd><a href=#/atom/proc/Entered>Entered proc (atom)</a>
<dd><a href=#/atom/proc/Exit>Exit proc (atom)</a>
<dd><a href=#/atom/proc/Exited>Exited proc (atom)</a>
<dd><a href=#/atom/movable/proc/Cross>Cross proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Uncross>Uncross proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Uncrossed>Uncrossed proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Move>Move proc (movable atom)</a>
<dd><a href=#/mob/var/group>group var (mob)</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Crossed(atom/movable/O)
</dl>

<dl><dt><b>When:</b>
<dd>Called when an object has overlapped this one through Move(). Directly
setting the object's loc or step_x/y vars does not result in a call to
Crossed() or any other movement side-effects.  The same goes for creation
or deletion of an object at a location.
</dl>

<dl><dt><b>Args:</b>
<dd>O: the object that moved and is now overlapping.
</dl>

<dl><dt><b>Default action:</b>
<dd>none
</dl>

<h3>Example:</h3>
<xmp>
obj/landmine
   Crossed(O)
      O << "You stepped on a land mine!"
      Explode()
</xmp>

<hr>

<a name=/atom/movable/proc/Move>
<h2>Move proc (movable atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/movable/proc/Bump>Bump proc (movable atom)</a>
<dd><a href=#/atom/proc/Enter>Enter proc (atom)</a>
<dd><a href=#/atom/proc/Entered>Entered proc (atom)</a>
<dd><a href=#/atom/proc/Exit>Exit proc (atom)</a>
<dd><a href=#/atom/proc/Exited>Exited proc (atom)</a>
<dd><a href=#/atom/movable/proc/Cross>Cross proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Crossed>Crossed proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Uncross>Uncross proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Uncrossed>Uncrossed proc (movable atom)</a>
<dd><a href=#/atom/var/loc>loc var (atom)</a>
<dd><a href=#/atom/movable/var/locs>locs list var (movable atom)</a>
<dd><a href=#/proc/walk>walk proc</a>
<dd><a href=#/{notes}/gliding>Gliding</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Move(NewLoc,Dir=0,step_x=0,step_y=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>Success (jump): 1
<dd>Success (slide): Number of pixels moved
<dd>Failure: 0
</dl>

<dl><dt><b>When:</b>
<dd>Called to move the object.  By default, client.Move() calls this proc when
players use direction keys.  The automated movement functions (like walk())
also call this proc.  Directly setting the loc variable does
<strong>not</strong> call this procedure.
</dl>

<dl><dt><b>Args:</b>
<dd>NewLoc: The new location.
<dd>Dir: The direction of movement (or 0).
<dd>step_x: The new step_x value, relative to NewLoc
<dd>step_y: The new step_y value, relative to NewLoc
</dl>

<p>Any Move() is either a slide or a jump. Normal walking around is a slide;
it can be stopped partway. A jump is pass/fail. See more information below.

<p>This is what happens by default:

<ol><li><p>oldloc.Exit(src) is called for any turfs or areas being vacated, or the
container if moving out of an obj or mob. neighbor.Uncross(src) is called for
any movable atoms that will no longer be overlapping this object. If any of these
return 0 (failure), movement fails.</li>
<li><p>newloc.Enter(src) is called for any turfs or areas that may be entered
for the first time, or the container if moving into an obj or mob.
neighbor.Cross(src) is called for any movable atoms that may be in collision
with this object if the move fully succeeds. If any of these return 0
(failure), then a slide can be cut short but a jump will fail completely.</li>
<li><p>If any obstacles were encountered via Enter() or Cross() failing, then
src.Bump(obstacle) will be called for each of them.</li>
<li><p>If movement did not fail completely, then loc and step_x/y, will be
changed, and the following calls will be made: oldloc.Exited() for any turfs,
areas, or other containers vacated; neighbor.Uncrossed() for any movable
atoms no longer overlapping; newloc.Entered() for any turfs, areas, or other
containers being entered for the first time; and neighbor.Crossed() for any
movable atoms now overlapping the object.</li>
</ol>

<p>A movement is considered a slide if src is moving from one turf to
another on the same z level, and the total pixel distance is less than either
src.step_size or a full tile size (whichever is largest). Any other movement
is a jump. Movement to the same turf with no step_x/y change is also
considered a jump.

<hr>

<a name=/atom/movable/proc/Uncross>
<h2>Uncross proc (movable atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/Enter>Enter proc (atom)</a>
<dd><a href=#/atom/proc/Entered>Entered proc (atom)</a>
<dd><a href=#/atom/proc/Exit>Exit proc (atom)</a>
<dd><a href=#/atom/proc/Exited>Exited proc (atom)</a>
<dd><a href=#/atom/movable/proc/Cross>Cross proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Crossed>Crossed proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Uncrossed>Uncrossed proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Move>Move proc (movable atom)</a>
<dd><a href=#/mob/var/group>group var (mob)</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Uncross(atom/movable/O)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 to permit; 0 to deny.
</dl>

<dl><dt><b>When:</b>
<dd>Called when another object attempts to stop overlapping this one.
</dl>

<dl><dt><b>Args:</b>
<dd>O: the object attempting to get away.
</dl>

<dl><dt><b>Default action:</b>
<dd>Allow the object to get away (returning 1)
</dl>

<hr>

<a name=/atom/movable/proc/Uncrossed>
<h2>Uncrossed proc (movable atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/Enter>Enter proc (atom)</a>
<dd><a href=#/atom/proc/Entered>Entered proc (atom)</a>
<dd><a href=#/atom/proc/Exit>Exit proc (atom)</a>
<dd><a href=#/atom/proc/Exited>Exited proc (atom)</a>
<dd><a href=#/atom/movable/proc/Cross>Cross proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Crossed>Crossed proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Uncross>Uncross proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Move>Move proc (movable atom)</a>
<dd><a href=#/mob/var/group>group var (mob)</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Uncrossed(atom/movable/O)
</dl>

<dl><dt><b>When:</b>
<dd>Called when an object has stopped overlapping this one through a call to
Move().  Directly setting the object's loc or step_x/y vars does not result
in a call to Uncrossed() or any other movement side-effects.  The same goes
for deletion of an object.
</dl>

<dl><dt><b>Args:</b>
<dd>O: the object that moved and is no longer overlapping.
</dl>

<dl><dt><b>Default action:</b>
<dd>none
</dl>

<h3>Example:</h3>
<xmp>
obj/pressure_plate
   Uncrossed(O)
      // if no other mobs are standing on it...
      if(!(locate(/mob) in bounds()))
         // do something
         Release()
</xmp>

<hr>

<a name=/atom/movable/var>
<h2>vars (movable atoms)</h2>

<p>Built-in movement vars:

<dl><dt>atom/movable/var
<dd><a href=#/atom/movable/var/animate_movement>animate_movement</a>
<dd><a href=#/atom/movable/var/bound_x>bound_x</a>
<dd><a href=#/atom/movable/var/bound_y>bound_y</a>
<dd><a href=#/atom/movable/var/bound_width>bound_width</a>
<dd><a href=#/atom/movable/var/bound_height>bound_height</a>
<dd><a href=#/atom/movable/var/locs>locs</a>
<dd><a href=#/atom/movable/var/screen_loc>screen_loc</a>
<dd><a href=#/atom/movable/var/glide_size>glide_size</a>
<dd><a href=#/atom/movable/var/step_size>step_size</a>
<dd><a href=#/atom/movable/var/step_x>step_x</a>
<dd><a href=#/atom/movable/var/step_y>step_y</a>
</dl>

<hr>

<a name=/atom/movable/var/animate_movement>
<h2>animate_movement var (movable atoms)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/movable/proc/Move>Move proc (movable atom)</a>
<dd><a href=#/atom/movable/var/glide_size>glide_size var (movable atoms)</a>
<dd><a href=#/{notes}/gliding>Gliding</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>FORWARD_STEPS (1)
</dl>

<dl><dt><b>Possible values:</b>
<dd>NO_STEPS (0)
<dd>FORWARD_STEPS (1)
<dd>SLIDE_STEPS (2)
<dd>SYNC_STEPS (3)
</dl>

<p><b>Deprecated.</b> This setting has no impact when used with pixel
movement. See <a href=#/{notes}/gliding>Gliding</a> for more details.

<p>Setting this to 0 causes movement between two adjacent positions to be
displayed as a single discrete jump.  Otherwise, objects will be made to glide
from one position to another, using the movement animation defined in the icon
file if one is defined.

<p>By default, movement animation avoids cutting corners, since this can look
very bad in some games.  If you want objects to take the shortest (and
smoothest) visual path when moving around, use SLIDE_STEPS instead of the
default FORWARD_STEPS.  This also allows the object to be facing in a
different direction than it is moving, so make sure this is what you want.

<p>SYNC_STEPS is intended for objects that move in unison as part of a larger
"conglomerate" object.  You should set the movement animation to SYNC_STEPS on
all but a single "head" object, which will serve as the leader when choosing
pixel step sizes.  If you do not use SYNC_STEPS, there are cases where the
pixel offsets of objects may get out of sync during motion, causing the object
to visually break up.

<hr>

<a name=/atom/movable/var/bound_x>
<h2>bound_x var (movable atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/movable/var/bound_y>bound_y var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_width>bound_width var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_height>bound_height var (movable atom)</a>
<dd><a href=#/atom/movable/var/step_x>step_x var (movable atom)</a>
<dd><a href=#/atom/movable/var/step_y>step_y var (movable atom)</a>
<dd><a href=#/atom/movable/var/locs>locs list var (movable atom)</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>This var defines the left side of the physical atom's bounding box, in
pixels. By default all atoms are assumed to be one tile in physical size.

<p>The left edge of the bounding box starts bound_x pixels inward from the
left edge of the atom's icon (as affected by step_x). A bound_x value of 4
means the atom has 4 pixels of empty space to its left.

<p>Example: A 16&times;16 smiley face centered in a 32&times;32 icon should
have a bound_x value of 8, since there are 8 pixels of empty space to the
left.

<hr>

<a name=/atom/movable/var/bound_y>
<h2>bound_y var (movable atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/movable/var/bound_x>bound_x var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_width>bound_width var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_height>bound_height var (movable atom)</a>
<dd><a href=#/atom/movable/var/step_x>step_x var (movable atom)</a>
<dd><a href=#/atom/movable/var/step_y>step_y var (movable atom)</a>
<dd><a href=#/atom/movable/var/locs>locs list var (movable atom)</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>This var defines the bottom side of the physical atom's bounding box, in
pixels. By default all atoms are assumed to be one tile in physical size.

<p>The bottom edge of the bounding box starts bound_y pixels inward from the
bottom edge of the atom's icon (as affected by step_y). A bound_y value of 4
means the atom has 4 pixels of empty space below it.

<p>Example: A 16&times;16 smiley face centered in a 32&times;32 icon should
have a bound_y value of 8, since there are 8 pixels of empty space below.

<hr>

<a name=/atom/movable/var/bound_width>
<h2>bound_width var (movable atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/movable/var/bound_x>bound_x var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_y>bound_y var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_height>bound_height var (movable atom)</a>
<dd><a href=#/atom/movable/var/step_x>step_x var (movable atom)</a>
<dd><a href=#/atom/movable/var/step_y>step_y var (movable atom)</a>
<dd><a href=#/atom/movable/var/locs>locs list var (movable atom)</a>
<dd><a href=#/world/var/icon_size>icon_size var (world)</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>32 (width of default icon; depends on world.icon_size)
</dl>

<p>This var defines the width of the physical atom's bounding box, in
pixels. By default all atoms are assumed to be one tile in physical size.

<p>Example: A 16&times;16 smiley face centered in a 32&times;32 icon should
have a bound_width value of 16.

<hr>

<a name=/atom/movable/var/bound_height>
<h2>bound_height var (movable atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/movable/var/bound_x>bound_x var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_y>bound_y var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_width>bound_width var (movable atom)</a>
<dd><a href=#/atom/movable/var/step_x>step_x var (movable atom)</a>
<dd><a href=#/atom/movable/var/step_y>step_y var (movable atom)</a>
<dd><a href=#/atom/movable/var/locs>locs list var (movable atom)</a>
<dd><a href=#/world/var/icon_size>icon_size var (world)</a>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>32 (depends on world.icon_size)
</dl>

<p>This var defines the height of the physical atom's bounding box, in
pixels. By default all atoms are assumed to be one tile in physical size.

<p>Example: A 16&times;16 smiley face centered in a 32&times;32 icon should
have a bound_height value of 16.

<p>The default value depends on world.icon_size and world.map_format. In a
topdown or tiled map_format, the icon height specified in world.icon_size is
used. In other modes, height is irrelevant and tile "footprints" are square,
so the icon width is used.

<hr>

<a name=/atom/movable/var/glide_size>
<h2>glide_size var (movable atoms)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/movable/var/animate_movement>animate_movement var (movable atoms)</a>
<dd><a href=#/client/var/glide_size>glide_size var (client)</a>
<dd><a href=#/atom/var/pixel_x>pixel_x var (atom)</a>
<dd><a href=#/atom/var/pixel_y>pixel_y var (atom)</a>
<dd><a href=#/world/var/icon_size>icon_size var (world)</a>
<dd><a href=#/client/var/fps>fps var (client)</a>
<dd><a href=#/{notes}/gliding>Gliding</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>This setting has no impact when used with pixel movement. See
<a href=#/{notes}/gliding>Gliding</a> for more details.

<p>This controls the number of pixels an object is moved in each footstep
during animated movement.  The default value of 0 chooses automated control
over this value, which generally results in a minimum footstep of 4 pixels
that is increased when necessary to keep up with motion on the turf grid.

<p>Decimal values are allowed.

<p>Be careful about using small glide sizes.  Icons with high contrast
pixel-level detail can look pretty ugly when displaced by short distances.

<p>The glide size is measured in server ticks. If you use a different client
tick rate by altering <code>client.fps</code> or <code>client.tick_lag</code>,
the actual glide used will be scaled appropriately.  E.g., if your
<code>client.fps</code> is 4 times greater than <code>world.fps</code>, the
actual glide amount each client tick will be <code>glide_size/4</code>.

<p>This was renamed from pixel_step_size.

<hr>

<a name=/atom/movable/var/locs>
<h2>locs list var (movable atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/movable/var/bound_x>bound_x var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_y>bound_y var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_width>bound_width var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_height>bound_height var (movable atom)</a>
<dd><a href=#/atom/movable/var/step_x>step_x var (movable atom)</a>
<dd><a href=#/atom/movable/var/step_y>step_y var (movable atom)</a>
<dd><a href=#/atom/var/loc>loc var (atom)</a>
<dd><a href=#/atom/var/contents>contents list var (atom)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>list(src.loc)
</dl>

<p>This read-only var tells which turfs are being physically covered by the
atom's bounding box. The purpose of this is for cases where you set the
atom's bounds to change its physical size so that it ends up covering more
than one turf.

<p>This is different from the loc var in that every atom still has only one
"true" location. A movable atom may cover multiple turfs, but only one turf
is its loc. The loc var can be thought of as an anchor point, while the
actual physical footprint is in locs.

<p>For every turf in locs, this atom will also be in that turf's contents
list.

<p>If loc is not a turf, it will be the only item in the locs list. If loc
is null, locs will be empty.

<hr>

<a name=/atom/movable/var/pixel_step_size>
<h2>pixel_step_size var (movable atoms)</h2>

<p>Renamed to <a href=#/atom/movable/var/glide_size>glide_size</a>.

<hr>

<a name=/atom/movable/var/screen_loc>
<h2>screen_loc var (movable atoms)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/{notes}/HUD>HUD / screen objects</a>
<dd><a href=#/atom/var/layer>layer var (atom)</a>
<dd><a href=#/client/var/screen>screen var (client)</a>
<dd><a href=#/client/var/view>view var (client)</a>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
</dl>

<p>This is a text string that controls where an object that is listed in
<var>client.screen</var> will appear on the user's screen.  The format is:

<xmp>
"x,y"
"x1,y1 to x2,y2"
</xmp>

<p>The bottom left corner of the map viewport (southwest) is <tt>"1,1"</tt>.
If the view is 11x11, then the top-right corner (northeast) is
<tt>"11,11"</tt>. (Changing <a href=#/world/var/map_format>world.map_format</a>
may change the range for screen_loc.)

<p>A range of coordinates (the second format above) causes a square region to
be filled with the object at each position.  The southwest and northeast
corners of the box are indicated in the screen_loc value.

<p>The edges of the map may also be referenced by using directions, such as
<tt>"3,NORTH"</tt>.  For convenience, the order of coordinates is arbitrary
when using directions, so one may specify <var>y</var> before <var>x</var> as
in <tt>"NORTH,WEST"</tt>.  In expressions such as the latter, you may also
leave out the comma.

<p>The CENTER keyword can also be used. This can be used alone to completely
center the object, or as either the x or y component. If the map covers an
even number of tiles in either direction, pixel offsets will be applied
automatically.

<p>In addition to objects inside of the map view, one may create border
objects.  Borders are automatically created when screen objects are placed at
coordinates outside of the inner map view.  For example, objects placed at y=0
fall on a border directly below the map and y=-1 is one tile below that.  (The
CENTER keyword is based on normal viewport bounds and not any extra borders.)

<p>Offsets may be applied to screen_loc coordinates.  For example,
<tt>"NORTH+1,WEST"</tt> is in a border above the map.
<tt>"CENTER+2,CENTER-1"</tt> will appear 2 units right, 1 unit down from the
center of the map.

<p>It is also possible to specify a pixel offset.  Screen objects do not use
pixel_x and pixel_y for this purpose, because it is intended that an object
could exist on the map and in the screen object list simultaneously, so
positioning must be independent. Pixel offsets are specified after a colon
like this: <tt>"1:16,1:16"</tt>. In this case the object is shifted to the
northeast by 16 pixels.

<p>Normal layering rules apply to screen objects when using a default top-down
world.map_format (TOPDOWN_MAP or TILED_ICON_MAP), so to color the background of
the map (visible at least when regions of the map are blocked from view), one
could create an object with a drawing layer below all other map objects and set
its screen_loc to cover the whole map (e.g. <tt>"1,1 to 11,11"</tt>). To achieve
this affect in other map modes like isometric, you will have to add
BACKGROUND_LAYER to the layer.

<p>You can use HUD objects in any additional map controls that might appear in
game's skin file. If you have a second map named "map2" for instance, then you
can use <tt>"map2:1,1"</tt> or something similar as a screen_loc. If the map
control is set to automatically scale to fit its contents, it will try to show
every object you put there. (NOTE: You should not use the full window.control
name, just the name of the control itself. Map controls should always have
unique names.)

<hr>

<a name=/atom/movable/var/step_size>
<h2>step_size var (movable atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/movable/var/step_x>step_x var (movable atom)</a>
<dd><a href=#/atom/movable/var/step_y>step_y var (movable atom)</a>
<dd><a href=#/atom/movable/proc/Move>Move proc (movable atom)</a>
<dd><a href=#/atom/movable/var/locs>locs list var (movable atom)</a>
<dd><a href=#/world/var/fps>fps var (world)</a>
<dd><a href=#/world/var/icon_size>icon_size var (world)</a>
<dd><a href=#/{notes}/gliding>Gliding</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>32 (width of default icon; depends on world.icon_size)
</dl>

<p>This var defines how fast, in pixels, an atom will move by default.
If you use lower values of step_size for most items in your world, you
may want to consider raising world.fps (at higher performance cost).

<p>When Move() is called by a step or walk, or by the built-in client
movement verbs, a change of step_size is applied to step_x and/or
step_y. Any movement within the speed of step_size, or up to one tile
in distance (whichever is greater), is considered a slide and may
partially succeed if an obstacle is bumped before reaching the final
position.

<hr>

<a name=/atom/movable/var/step_x>
<h2>step_x var (movable atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/movable/var/step_y>step_y var (movable atom)</a>
<dd><a href=#/atom/movable/var/step_size>step_size var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_x>bound_x var (movable atom)</a>
<dd><a href=#/atom/movable/proc/Move>Move proc (movable atom)</a>
<dd><a href=#/atom/movable/var/locs>locs list var (movable atom)</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>This var defines the position of the atom (in pixels) relative to its
tile, on the x axis. A step_x of 5 means the atom actually is shown 5 pixels
east of the tile's western edge.

<p>The atom's actual bounding box may not begin at step_x, but can be set
even further in via bound_x.

<p>Example: A 16&times;16 smiley face centered in a 32&times;32 icon should
have the following bounds:

<ul><li>bound_x = 8</li>
<li>bound_y = 8</li>
<li>bound_width = 16</li>
<li>bound_height = 16</li>
</ul>

<p>For the smiley to appear at the left edge of the tile it is standing on,
it would need a step_x value of -8. A step_x value of 8 takes it all the way
to the rightmost edge of the tile. Anything outside of the range -8 to 8 will
have the atom straddling multiple turfs.

<hr>

<a name=/atom/movable/var/step_y>
<h2>step_y var (movable atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/movable/var/step_x>step_x var (movable atom)</a>
<dd><a href=#/atom/movable/var/step_size>step_size var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_x>bound_y var (movable atom)</a>
<dd><a href=#/atom/movable/proc/Move>Move proc (movable atom)</a>
<dd><a href=#/atom/movable/var/locs>locs list var (movable atom)</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>This var defines the position of the atom (in pixels) relative to its
tile, on the y axis. A step_y of 5 means the atom actually is shown 5 pixels
north of the tile's southern edge.

<p>The atom's actual bounding box may not begin at step_y, but can be set
even further in via bound_y.

<p>Example: A 16&times;16 smiley face centered in a 32&times;32 icon should
have the following bounds:

<ul><li>bound_x = 8</li>
<li>bound_y = 8</li>
<li>bound_width = 16</li>
<li>bound_height = 16</li>
</ul>

<p>For the smiley to appear at the bottom edge of the tile it is standing on,
it would need a step_y value of -8. A step_y value of 8 takes it all the way
to the top edge of the tile. Anything outside of the range -8 to 8 will have
the atom straddling multiple turfs.

<hr>

<a name=/atom/proc>
<h2>procs (atom)</h2>

<p>Built-in atom procs:

<dl><dt>atom/proc
<dd><a href=#/atom/proc/Click>Click</a>
<dd><a href=#/atom/proc/DblClick>DblClick</a>
<dd><a href=#/datum/proc/Del>Del</a>
<dd><a href=#/atom/proc/Enter>Enter</a>
<dd><a href=#/atom/proc/Entered>Entered</a>
<dd><a href=#/atom/proc/Exit>Exit</a>
<dd><a href=#/atom/proc/Exited>Exited</a>
<dd><a href=#/atom/proc/MouseDown>MouseDown</a>
<dd><a href=#/atom/proc/MouseDrag>MouseDrag</a>
<dd><a href=#/atom/proc/MouseDrop>MouseDrop</a>
<dd><a href=#/atom/proc/MouseEntered>MouseEntered</a>
<dd><a href=#/atom/proc/MouseExited>MouseExited</a>
<dd><a href=#/atom/proc/MouseMove>MouseMove</a>
<dd><a href=#/atom/proc/MouseUp>MouseUp</a>
<dd><a href=#/atom/proc/MouseWheel>MouseWheel</a>
<dd><a href=#/atom/proc/New>New</a>
<dd><a href=#/datum/proc/Read>Read</a>
<dd><a href=#/atom/proc/Stat>Stat</a>
<dd><a href=#/datum/proc/Topic>Topic</a>
<dd><a href=#/datum/proc/Write>Write</a>
</dl>

<hr>

<a name=/atom/proc/Click>
<h2>Click proc (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Click>Click proc (client)</a>
<dd><a href=#/atom/proc/DblClick>DblClick proc (atom)</a>
<dd><a href=#/atom/proc/MouseDown>MouseDown proc (atom)</a>
<dd><a href=#/atom/proc/MouseDrag>MouseDrag proc (atom)</a>
<dd><a href=#/atom/proc/MouseDrop>MouseDrop proc (atom)</a>
<dd><a href=#/atom/proc/MouseEntered>MouseEntered proc (atom)</a>
<dd><a href=#/atom/proc/MouseExited>MouseExited proc (atom)</a>
<dd><a href=#/atom/proc/MouseMove>MouseMove proc (atom)</a>
<dd><a href=#/atom/proc/MouseUp>MouseUp proc (atom)</a>
<dd><a href=#/atom/proc/MouseWheel>MouseWheel proc (atom)</a>
<dd><a href=#/client/var/show_popup_menus>show_popup_menus var (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Click(location,control,params)
</dl>

<dl><dt><b>When:</b>
<dd>Called when the object is clicked.
</dl>

<dl><dt><b>Args:</b>
<dd>location: the turf, stat panel, grid cell, etc. in which the object was clicked
<dd>control: the name of the skin control involved
<dd>params: other parameters including mouse/keyboard flags, icon offsets, etc.; see <a href="#/DM/mouse">mouse control</a>
</dl>

<p>This proc is called by the default client.Click() procedure.

<p>The following example allows the player to walk to a position by clicking
it.

<h3>Example:</h3>
<xmp>
turf/Click()
  walk_to(usr,src)
</xmp>

<hr>

<a name=/atom/proc/DblClick>
<h2>DblClick proc (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/Click>Click proc (atom)</a>
<dd><a href=#/client/proc/DblClick>DblClick proc (client)</a>
<dd><a href=#/atom/proc/MouseDown>MouseDown proc (atom)</a>
<dd><a href=#/atom/proc/MouseDrag>MouseDrag proc (atom)</a>
<dd><a href=#/atom/proc/MouseDrop>MouseDrop proc (atom)</a>
<dd><a href=#/atom/proc/MouseEntered>MouseEntered proc (atom)</a>
<dd><a href=#/atom/proc/MouseExited>MouseExited proc (atom)</a>
<dd><a href=#/atom/proc/MouseMove>MouseMove proc (atom)</a>
<dd><a href=#/atom/proc/MouseUp>MouseUp proc (atom)</a>
<dd><a href=#/atom/proc/MouseWheel>MouseWheel proc (atom)</a>
<dd><a href=#/client/var/show_popup_menus>show_popup_menus var (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>DblClick(location,control,params)
</dl>

<dl><dt><b>When:</b>
<dd>Called when the object is double-clicked.
</dl>

<dl><dt><b>Args:</b>
<dd>location: the turf, stat panel, grid cell, etc. in which the object was double-clicked
<dd>control: the name of the skin control involved
<dd>params: other parameters including mouse/keyboard flags, icon offsets, etc.; see <a href="#/DM/mouse">mouse control</a>
</dl>

<p>This proc is called by the default client.DblClick() procedure.

<p>This example allows the player to teleport to a position by double
clicking it.

<h3>Example:</h3>
<xmp>
turf/DblClick()
  usr.Move(src)
</xmp>

<hr>

<a name=/atom/proc/Enter>
<h2>Enter proc (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/Entered>Entered proc (atom)</a>
<dd><a href=#/atom/proc/Exit>Exit proc (atom)</a>
<dd><a href=#/atom/proc/Exited>Exited proc (atom)</a>
<dd><a href=#/atom/movable/proc/Cross>Cross proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Crossed>Crossed proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Uncross>Uncross proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Uncrossed>Uncrossed proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Move>Move proc (movable atom)</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Enter(atom/movable/O, atom/oldloc)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 to permit; 0 to deny.
</dl>

<dl><dt><b>When:</b>
<dd>Called when an object attempts to enter the contents list.
</dl>

<dl><dt><b>Args:</b>
<dd>O: the object attempting to enter.
<dd>oldloc: the old (current) loc of the object attempting to enter.
</dl>

<dl><dt><b>Default action:</b>
<dd>Explained below.
</dl>

<p>Areas, objs, and mobs will always permit anything to enter by default.

<p>Turfs will return 1 (permit) or 0 (deny) based on density. In simple
terms, if the atom that is entering is dense, then the turf will deny entry
if the turf itself or its contents (any that take up the full tile) are
dense.

<p>What actually happens in turf.Enter() is more detailed: The turf's
density is checked against the object's density first. If this check succeeds
(movement is permitted), then Cross() is called for any atoms in
turf.contents that cover the entire tile. If any Cross() call fails, Enter()
fails too and will return 0.

<p>If a mob is standing on a turf but its bounding box does not cover the
whole tile, it is ignored by Enter(). Instead, its Cross() proc is called if
there is a danger of the object overlapping it.

<hr>

<a name=/atom/proc/Entered>
<h2>Entered proc (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/Enter>Enter proc (atom)</a>
<dd><a href=#/atom/proc/Exit>Exit proc (atom)</a>
<dd><a href=#/atom/proc/Exited>Exited proc (atom)</a>
<dd><a href=#/atom/movable/proc/Cross>Cross proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Crossed>Crossed proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Uncross>Uncross proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Uncrossed>Uncrossed proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Move>Move proc (movable atom)</a>
<dd><a href=#/atom/movable/var/step_x>step_x var (movable atom)</a>
<dd><a href=#/atom/movable/var/step_y>step_y var (movable atom)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Entered(atom/movable/Obj,atom/OldLoc)
</dl>

<dl><dt><b>When:</b>
<dd>Called when an object has entered the contents list through Move().
Directly setting the object's loc or step_x/y vars does not result in a
call to Entered() or any other movement side-effects.  The same goes for
creation or deletion of an object at a location.
</dl>

<dl><dt><b>Args:</b>
<dd>Obj: the object that entered (a mob or obj).
<dd>OldLoc: the previous location of the object.
</dl>

<dl><dt><b>Default action:</b>
<dd>none
</dl>

<h3>Example:</h3>
<xmp>
turf/pit
   Entered(O)
      O << "OUCH.  You fell in a pit!"
</xmp>

<p>The mob's Entered() and Exited() procs can be used to control what
happens when objects are added or removed from the mob's inventory.  Of
course that could all be done within get() and drop() verbs, but the
following code separates user interface from lower-level functions.

<h3>Example:</h3>
<xmp>
obj
   var
      weight = 10
   verb
      get()
         set src in oview(1)
         if(Move(usr))
            usr << "You pick up \a [src]."
         else
            usr << "You cannot pick up [src]."
      drop()
         set src in usr
         if(Move(usr.loc))
            usr << "You drop \a [src]."
mob
   var
      weight
      max_weight = 50

   Entered(obj/O)
      weight += O.weight
   Exited(obj/O)
      weight -= O.weight
   Enter(obj/O)
      //only allow entrance if weight is within the limit
      if(O.weight + weight <= max_weight)
         return ..()
</xmp>

<p>To see the advantages of this arrangement, imagine that there are certain
situations in which an object may be created directly within the mob's
inventory without the mob picking it up.  You can still run it through your
normal movement rules without calling get().

<h3>Example:</h3>
<xmp>
mob/verb/wish()
   var/obj/O = new() //create it with loc=null
   if(O.Move(usr))   //and then move it into inventory
      usr << "Your wish has been granted!"
   else
      usr << "You are too greedy!"
      del O
</xmp>

<hr>

<a name=/atom/proc/Exit>
<h2>Exit proc (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/Enter>Enter proc (atom)</a>
<dd><a href=#/atom/proc/Entered>Entered proc (atom)</a>
<dd><a href=#/atom/proc/Exited>Exited proc (atom)</a>
<dd><a href=#/atom/movable/proc/Cross>Cross proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Crossed>Crossed proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Uncross>Uncross proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Uncrossed>Uncrossed proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Move>Move proc (movable atom)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Exit(atom/movable/O, atom/newloc)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 to permit; 0 to deny.
</dl>

<dl><dt><b>When:</b>
<dd>Called when an object attempts to exit the contents list.
</dl>

<dl><dt><b>Args:</b>
<dd>O: the object attempting to exit.
<dd>newloc: the object's new location.
</dl>

<dl><dt><b>Default action:</b>
<dd>Allow the object to exit (returning 1).
</dl>

<p>By default, every atom returns 1 to allow exit.

<p>If a turf allows exit, Uncross() will be called for any atoms in
turf.contents that cover the entire tile. If any Uncross() call fails, Exit()
fails too and will return 0. In games using pixel movement, Uncross() is
usually called separately, but this allows projects using tile-based movement
instead to benefit from Cross() and Uncross().

<hr>

<a name=/atom/proc/Exited>
<h2>Exited proc (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/Enter>Enter proc (atom)</a>
<dd><a href=#/atom/proc/Entered>Entered proc (atom)</a>
<dd><a href=#/atom/proc/Exit>Exit proc (atom)</a>
<dd><a href=#/atom/movable/proc/Cross>Cross proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Crossed>Crossed proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Uncross>Uncross proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Uncrossed>Uncrossed proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Move>Move proc (movable atom)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Exited(atom/movable/Obj, atom/newloc)
</dl>

<dl><dt><b>When:</b>
<dd>Called when an object has exited from the contents list through a call to
Move().  Directly setting the object's loc or step_x/y vars does not result
in a call to Exited() or any other movement side-effects.  The same goes for
deletion of an object.
</dl>

<dl><dt><b>Args:</b>
<dd>Obj: the object that exited (a mob or obj).
<dd>newloc: the object's new location.
</dl>

<dl><dt><b>Default action:</b>
<dd>none
</dl>

<hr>

<a name=/atom/proc/MouseDown>
<h2>MouseDown proc (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/Click>Click proc (atom)</a>
<dd><a href=#/atom/proc/DblClick>DblClick proc (atom)</a>
<dd><a href=#/client/proc/MouseDown>MouseDown proc (client)</a>
<dd><a href=#/atom/proc/MouseDrag>MouseDrag proc (atom)</a>
<dd><a href=#/atom/proc/MouseDrop>MouseDrop proc (atom)</a>
<dd><a href=#/atom/proc/MouseEntered>MouseEntered proc (atom)</a>
<dd><a href=#/atom/proc/MouseExited>MouseExited proc (atom)</a>
<dd><a href=#/atom/proc/MouseMove>MouseMove proc (atom)</a>
<dd><a href=#/atom/proc/MouseUp>MouseUp proc (atom)</a>
<dd><a href=#/atom/proc/MouseWheel>MouseWheel proc (atom)</a>
<dd><a href=#/atom/var/mouse_drag_pointer>mouse_drag_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_drop_pointer>mouse_drop_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var (atom)</a>
<dd><a href=#/atom/var/mouse_over_pointer>mouse_over_pointer var (atom)</a>
<dd><a href=#/client/var/show_popup_menus>show_popup_menus var (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>MouseDown(location,control,params)
</dl>

<dl><dt><b>Args:</b>
<dd>location: the turf, stat panel, grid cell, etc. in which the object was clicked
<dd>control: the name of the skin control involved
<dd>params: other parameters including mouse/keyboard flags, icon offsets, etc.; see <a href="#/DM/mouse">mouse control</a>
</dl>

<p>This is called when a mouse button is pressed while pointing to this
object.

<p>Don't define this unless you need it, because it generates extra
communication that is otherwise avoided.  Most operations can be done through
Click(), DblClick(), and MouseDrop().  The other procedures are simply
available for completeness.

<p><b>Note:</b> In BYOND 3.5 this procedure took three different arguments:
location, icon_x, and icon_y. Since icon_x and icon_y have been replaced,
old code will need to be modified. Games compiled before this change will still
work normally.

<hr>

<a name=/atom/proc/MouseDrag>
<h2>MouseDrag proc (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/Click>Click proc (atom)</a>
<dd><a href=#/atom/proc/DblClick>DblClick proc (atom)</a>
<dd><a href=#/atom/proc/MouseDown>MouseDown proc (atom)</a>
<dd><a href=#/client/proc/MouseDrag>MouseDrag proc (client)</a>
<dd><a href=#/atom/proc/MouseDrop>MouseDrop proc (atom)</a>
<dd><a href=#/atom/proc/MouseEntered>MouseEntered proc (atom)</a>
<dd><a href=#/atom/proc/MouseExited>MouseExited proc (atom)</a>
<dd><a href=#/atom/proc/MouseMove>MouseMove proc (atom)</a>
<dd><a href=#/atom/proc/MouseUp>MouseUp proc (atom)</a>
<dd><a href=#/atom/proc/MouseWheel>MouseWheel proc (atom)</a>
<dd><a href=#/atom/var/mouse_drag_pointer>mouse_drag_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_drop_pointer>mouse_drop_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_drop_zone>mouse_drop_zone var (atom)</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var (atom)</a>
<dd><a href=#/atom/var/mouse_over_pointer>mouse_over_pointer var (atom)</a>
<dd><a href=#/client/var/show_popup_menus>show_popup_menus var (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>MouseDrag(over_object,src_location,over_location,src_control,over_control,params)
</dl>

<dl><dt><b>Args:</b>
<dd>over_object: the object under the mouse pointer
<dd>src_location: the turf, stat panel, grid cell, etc. from where the src object was dragged
<dd>over_location: the turf, stat panel, grid cell, etc. containing the object under the mouse pointer
<dd>src_control: The id of the skin control the object was dragged from
<dd>over_control: The id of the skin control the object was dragged over
<dd>params: other parameters including mouse/keyboard flags, icon offsets, etc.; see <a href="#/DM/mouse">mouse control</a>
</dl>

<p>This is called while dragging this object by pressing and holding the left
mouse button over the object and moving the mouse.  The over_object may be
null if dragging over a stat panel or over other empty space.

<p>Don't define this unless you need it, because it generates extra
communication that is otherwise avoided.  Most operations can be done through
Click(), DblClick(), and MouseDrop().  The other procedures are simply
available for completeness.

<hr>

<a name=/atom/proc/MouseDrop>
<h2>MouseDrop proc (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/Click>Click proc (atom)</a>
<dd><a href=#/atom/proc/DblClick>DblClick proc (atom)</a>
<dd><a href=#/atom/proc/MouseDown>MouseDown proc (atom)</a>
<dd><a href=#/atom/proc/MouseDrag>MouseDrag proc (atom)</a>
<dd><a href=#/client/proc/MouseDrop>MouseDrop proc (client)</a>
<dd><a href=#/atom/proc/MouseEntered>MouseEntered proc (atom)</a>
<dd><a href=#/atom/proc/MouseExited>MouseExited proc (atom)</a>
<dd><a href=#/atom/proc/MouseMove>MouseMove proc (atom)</a>
<dd><a href=#/atom/proc/MouseUp>MouseUp proc (atom)</a>
<dd><a href=#/atom/proc/MouseWheel>MouseWheel proc (atom)</a>
<dd><a href=#/atom/var/mouse_drag_pointer>mouse_drag_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_drop_pointer>mouse_drop_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_drop_zone>mouse_drop_zone var (atom)</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var (atom)</a>
<dd><a href=#/atom/var/mouse_over_pointer>mouse_over_pointer var (atom)</a>
<dd><a href=#/client/var/show_popup_menus>show_popup_menus var (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>MouseDrop(over_object,src_location,over_location,src_control,over_control,params)
</dl>

<dl><dt><b>Args:</b>
<dd>over_object: the object under the mouse pointer
<dd>src_location: the turf, stat panel, grid cell, etc. from where the src object was dragged
<dd>over_location: the turf, stat panel, grid cell, etc. containing the object under the mouse pointer
<dd>src_control: The id of the skin control the object was dragged from
<dd>over_control: The id of the skin control the object was dropped onto
<dd>params: other parameters including mouse/keyboard flags, icon offsets, etc.; see <a href="#/DM/mouse">mouse control</a>
</dl>

<p>This is called when the a mouse button is released after dragging this
object.  The over_object may be null if dropping over a stat panel or over
other empty space.

<hr>

<a name=/atom/proc/MouseEntered>
<h2>MouseEntered proc (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/Click>Click proc (atom)</a>
<dd><a href=#/atom/proc/DblClick>DblClick proc (atom)</a>
<dd><a href=#/atom/proc/MouseDown>MouseDown proc (atom)</a>
<dd><a href=#/atom/proc/MouseDrag>MouseDrag proc (atom)</a>
<dd><a href=#/atom/proc/MouseDrop>MouseDrop proc (atom)</a>
<dd><a href=#/client/proc/MouseEntered>MouseEntered proc (client)</a>
<dd><a href=#/atom/proc/MouseExited>MouseExited proc (atom)</a>
<dd><a href=#/atom/proc/MouseMove>MouseMove proc (atom)</a>
<dd><a href=#/atom/proc/MouseUp>MouseUp proc (atom)</a>
<dd><a href=#/atom/proc/MouseWheel>MouseWheel proc (atom)</a>
<dd><a href=#/atom/var/mouse_drag_pointer>mouse_drag_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_drop_pointer>mouse_drop_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var (atom)</a>
<dd><a href=#/atom/var/mouse_over_pointer>mouse_over_pointer var (atom)</a>
<dd><a href=#/client/var/show_popup_menus>show_popup_menus var (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>MouseEntered(location,control,params)
</dl>

<dl><dt><b>Args:</b>
<dd>location: the turf, stat panel, grid cell, etc. containing the object
<dd>control: the name of the skin control involved
<dd>params: other parameters including mouse/keyboard flags, icon offsets, etc.; see <a href="#/DM/mouse">mouse control</a>
</dl>

<p>This is called when the mouse moves onto the object with no buttons
pressed.

<p>Don't define this unless you need it, because it generates extra
communication that is otherwise avoided.  Defining it on only the objects that
require it reduces overhead.

<hr>

<a name=/atom/proc/MouseExited>
<h2>MouseExited proc (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/Click>Click proc (atom)</a>
<dd><a href=#/atom/proc/DblClick>DblClick proc (atom)</a>
<dd><a href=#/atom/proc/MouseDown>MouseDown proc (atom)</a>
<dd><a href=#/atom/proc/MouseDrag>MouseDrag proc (atom)</a>
<dd><a href=#/atom/proc/MouseDrop>MouseDrop proc (atom)</a>
<dd><a href=#/atom/proc/MouseEntered>MouseEntered proc (atom)</a>
<dd><a href=#/client/proc/MouseExited>MouseExited proc (client)</a>
<dd><a href=#/atom/proc/MouseMove>MouseMove proc (atom)</a>
<dd><a href=#/atom/proc/MouseUp>MouseUp proc (atom)</a>
<dd><a href=#/atom/proc/MouseWheel>MouseWheel proc (atom)</a>
<dd><a href=#/atom/var/mouse_drag_pointer>mouse_drag_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_drop_pointer>mouse_drop_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var (atom)</a>
<dd><a href=#/atom/var/mouse_over_pointer>mouse_over_pointer var (atom)</a>
<dd><a href=#/client/var/show_popup_menus>show_popup_menus var (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>MouseExited(location,control,params)
</dl>

<dl><dt><b>Args:</b>
<dd>location: the turf, stat panel, grid cell, etc. containing the object
<dd>control: the name of the skin control involved
<dd>params: other parameters including mouse/keyboard flags, icon offsets, etc.; see <a href="#/DM/mouse">mouse control</a>
</dl>

<p>This is called when the mouse moves off of an object with no buttons
pressed.

<p>Don't define this unless you need it, because it generates extra
communication that is otherwise avoided.  Defining it on only the objects that
require it reduces overhead.

<hr>

<a name=/atom/proc/MouseMove>
<h2>MouseMove proc (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/Click>Click proc (atom)</a>
<dd><a href=#/atom/proc/DblClick>DblClick proc (atom)</a>
<dd><a href=#/atom/proc/MouseDown>MouseDown proc (atom)</a>
<dd><a href=#/atom/proc/MouseDrag>MouseDrag proc (atom)</a>
<dd><a href=#/atom/proc/MouseDrop>MouseDrop proc (atom)</a>
<dd><a href=#/atom/proc/MouseEntered>MouseEntered proc (atom)</a>
<dd><a href=#/atom/proc/MouseExited>MouseExited proc (atom)</a>
<dd><a href=#/client/proc/MouseMove>MouseMove proc (client)</a>
<dd><a href=#/atom/proc/MouseUp>MouseUp proc (atom)</a>
<dd><a href=#/atom/proc/MouseWheel>MouseWheel proc (atom)</a>
<dd><a href=#/atom/var/mouse_drag_pointer>mouse_drag_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_drop_pointer>mouse_drop_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var (atom)</a>
<dd><a href=#/atom/var/mouse_over_pointer>mouse_over_pointer var (atom)</a>
<dd><a href=#/client/var/show_popup_menus>show_popup_menus var (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>MouseMove(location,control,params)
</dl>

<dl><dt><b>Args:</b>
<dd>location: the turf, stat panel, grid cell, etc. containing the object
<dd>control: the name of the skin control involved
<dd>params: other parameters including mouse/keyboard flags, icon offsets, etc.; see <a href="#/DM/mouse">mouse control</a>
</dl>

<p>This is called when the mouse moves over the object with no buttons
pressed. When the mouse moves over for the first time, MouseEntered() is
called instead.

<p>Don't define this unless you need it, because it generates extra
communication that is otherwise avoided.  Defining it on only the objects that
require it reduces overhead.

<hr>

<a name=/atom/proc/MouseUp>
<h2>MouseUp proc (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/Click>Click proc (atom)</a>
<dd><a href=#/atom/proc/DblClick>DblClick proc (atom)</a>
<dd><a href=#/atom/proc/MouseDown>MouseDown proc (atom)</a>
<dd><a href=#/atom/proc/MouseDrag>MouseDrag proc (atom)</a>
<dd><a href=#/atom/proc/MouseDrop>MouseDrop proc (atom)</a>
<dd><a href=#/atom/proc/MouseEntered>MouseEntered proc (atom)</a>
<dd><a href=#/atom/proc/MouseExited>MouseExited proc (atom)</a>
<dd><a href=#/atom/proc/MouseMove>MouseMove proc (atom)</a>
<dd><a href=#/client/proc/MouseUp>MouseUp proc (client)</a>
<dd><a href=#/atom/proc/MouseWheel>MouseWheel proc (atom)</a>
<dd><a href=#/atom/var/mouse_drag_pointer>mouse_drag_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_drop_pointer>mouse_drop_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_drop_zone>mouse_drop_zone var (atom)</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var (atom)</a>
<dd><a href=#/atom/var/mouse_over_pointer>mouse_over_pointer var (atom)</a>
<dd><a href=#/client/var/show_popup_menus>show_popup_menus var (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>MouseUp(location,control,params)
</dl>

<dl><dt><b>Args:</b>
<dd>location: the turf, stat panel, grid cell, etc. in which the object was clicked
<dd>control: the name of the skin control involved
<dd>params: other parameters including mouse/keyboard flags, icon offsets, etc.; see <a href="#/DM/mouse">mouse control</a>
</dl>

<p>This is called when a mouse button is released while pointing to
this object.

<p>Don't define this unless you need it, because it generates extra
communication that is otherwise avoided.  Most operations can be done through
Click(), DblClick(), and MouseDrop().  The other procedures are simply
available for completeness.

<p><b>Note:</b> In BYOND 3.5 this procedure took three different arguments:
location, icon_x, and icon_y. Since icon_x and icon_y have been replaced,
old code will need to be modified. Games compiled before this change will still
work normally.

<hr>

<a name=/atom/proc/MouseWheel>
<h2>MouseWheel proc (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/Click>Click proc (atom)</a>
<dd><a href=#/atom/proc/DblClick>DblClick proc (atom)</a>
<dd><a href=#/atom/proc/MouseDown>MouseDown proc (atom)</a>
<dd><a href=#/atom/proc/MouseDrag>MouseDrag proc (atom)</a>
<dd><a href=#/atom/proc/MouseDrop>MouseDrop proc (atom)</a>
<dd><a href=#/atom/proc/MouseEntered>MouseEntered proc (atom)</a>
<dd><a href=#/atom/proc/MouseExited>MouseExited proc (atom)</a>
<dd><a href=#/atom/proc/MouseMove>MouseMove proc (atom)</a>
<dd><a href=#/atom/proc/MouseUp>MouseUp proc (atom)</a>
<dd><a href=#/client/proc/MouseWheel>MouseWheel proc (client)</a>
<dd><a href=#/atom/var/mouse_drag_pointer>mouse_drag_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_drop_pointer>mouse_drop_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var (atom)</a>
<dd><a href=#/atom/var/mouse_over_pointer>mouse_over_pointer var (atom)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>MouseWheel(delta_x,delta_y,location,control,params)
</dl>

<dl><dt><b>Args:</b>
<dd>delta_x,delta_y: amount of wheel movement
<dd>location: the turf, stat panel, grid cell, etc. containing the object
<dd>control: the name of the skin control involved
<dd>params: other parameters including mouse/keyboard flags, icon offsets, etc.; see <a href="#/DM/mouse">mouse control</a>
</dl>

<p>This is called when the mouse wheel is moved while over an object.

<p>Positive values of delta_x and delta_y refer to scrolling right or up,
respectively. Negative values are left and down, respectively.

<p>Don't define this unless you need it, because it generates extra
communication that is otherwise avoided.  Defining it on only the objects that
require it reduces overhead.

<hr>

<a name=/atom/proc/New>
<h2>New proc (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/datum/proc/New>New proc (datum)</a>
<dd><a href=#/proc/new>new proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>New(loc)
<dd><small>(supports <a href=#/proc/arguments/named>named arguments</a>)</small>
</dl>

<dl><dt><b>When:</b>
<dd>Called when the object is created.
</dl>

<dl><dt><b>Args:</b>
<dd>loc: The initial location.
</dl>

<dl><dt><b>Default action:</b>
<dd>None.
</dl>

<p>By the time New() is called, the object has already been created at the
specified location and all of its variables have been initialized.  You can
perform additional initialization by overriding this procedure.

<p>Since the initial location parameter passed to <code>new()</code> is
applied before New() is even called, there is some special handling of the
<var>loc</var> variable when using named arguments in a call.  Normally, if a
procedure is overridden, named arguments in a call are matched against those
in the the overridden definition.  In this case, however, the <var>loc</var>
parameter name is hard-coded.  Regardless of what you call the first argument
in your definition of New(), the initial location will be taken from the first
positional argument, or from the argument named <var>loc</var> if there are no
positional arguments.

<p>The following example does some extra initialization that is not possible
in the variable definition section, because it requires a runtime evaluation.
This is a common reason to use New().

<h3>Example:</h3>
<xmp>
mob
   var
      birthdate //time stamp
   New()
      birthdate = world.realtime
      return ..()
   verb/look()
      set src in view()
      usr << "[src] was born on [time2text(birthdate,"DD-MMM-YYYY")]."
</xmp>

<hr>

<a name=/atom/proc/Stat>
<h2>Stat proc (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Stat>Stat proc (client)</a>
<dd><a href=#/proc/stat>stat proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Stat()
</dl>

<dl><dt><b>When:</b>
<dd>Called periodically by the client to update the stat window.
</dl>

<dl><dt><b>Default action:</b>
<dd>none.
</dl>

<p>The following code could be used to display a player's current status.

<h3>Example:</h3>
<xmp>
mob/var
   health = 100
mob/Stat()
   stat("health",health)
   statpanel("Inventory",contents)
</xmp>

<hr>

<a name=/atom/var>
<h2>vars (atom)</h2>

<p>Built-in atom vars:

<dl><dt>atom/var
<dd><a href=#/atom/var/alpha>alpha</a>
<dd><a href=#/atom/var/appearance>appearance</a>
<dd><a href=#/atom/var/appearance_flags>appearance_flags</a>
<dd><a href=#/atom/var/blend_mode>blend_mode</a>
<dd><a href=#/atom/var/color>color</a>
<dd><a href=#/atom/var/contents>contents</a>
<dd><a href=#/atom/var/density>density</a>
<dd><a href=#/atom/var/desc>desc</a>
<dd><a href=#/atom/var/dir>dir</a>
<dd><a href=#/atom/var/gender>gender</a>
<dd><a href=#/atom/var/icon>icon</a>
<dd><a href=#/atom/var/icon_state>icon_state</a>
<dd><a href=#/atom/var/invisibility>invisibility</a>
<dd><a href=#/atom/var/infra_luminosity>infra_luminosity</a>
<dd><a href=#/atom/var/loc>loc</a>
<dd><a href=#/atom/var/layer>layer</a>
<dd><a href=#/atom/var/luminosity>luminosity</a>
<dd><a href=#/atom/var/maptext>maptext</a>
<dd><a href=#/atom/var/maptext_width>maptext_width</a>
<dd><a href=#/atom/var/maptext_height>maptext_height</a>
<dd><a href=#/atom/var/maptext_x>maptext_x</a>
<dd><a href=#/atom/var/maptext_y>maptext_y</a>
<dd><a href=#/atom/var/mouse_over_pointer>mouse_over_pointer</a>
<dd><a href=#/atom/var/mouse_drag_pointer>mouse_drag_pointer</a>
<dd><a href=#/atom/var/mouse_drop_pointer>mouse_drop_pointer</a>
<dd><a href=#/atom/var/mouse_drop_zone>mouse_drop_zone var</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var</a>
<dd><a href=#/atom/var/name>name</a>
<dd><a href=#/atom/var/opacity>opacity</a>
<dd><a href=#/atom/var/overlays>overlays</a>
<dd><a href=#/atom/var/override>override</a> (images only)
<dd><a href=#/datum/var/parent_type>parent_type</a>
<dd><a href=#/atom/var/pixel_x>pixel_x</a>
<dd><a href=#/atom/var/pixel_y>pixel_y</a>
<dd><a href=#/atom/var/pixel_w>pixel_w</a>
<dd><a href=#/atom/var/pixel_z>pixel_z</a>
<dd><a href=#/atom/var/plane>plane</a>
<dd><a href=#/atom/var/suffix>suffix</a>
<dd><a href=#/datum/var/tag>tag</a>
<dd><a href=#/atom/var/text>text</a>
<dd><a href=#/atom/var/transform>transform</a>
<dd><a href=#/datum/var/type>type</a>
<dd><a href=#/atom/var/underlays>underlays</a>
<dd><a href=#/datum/var/vars>vars</a>
<dd><a href=#/atom/var/verbs>verbs</a>
<dd><a href=#/atom/var/x>x</a>
<dd><a href=#/atom/var/y>y</a>
<dd><a href=#/atom/var/z>z</a>
</dl>

<hr>

<a name=/atom/var/alpha>
<h2>alpha var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var>vars (atom)</a>
<dd><a href=#/atom/var/appearance_flags>appearance_flags var (atom)</a>
<dd><a href=#/atom/var/blend_mode>blend_mode var (atom)</a>
<dd><a href=#/atom/var/color>color var (atom)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>255 (opaque)
</dl>

<dl><dt><b>Possible values:</b>
<dd>0 (transparent) through 255 (opaque)
</dl>

<p>Controls the opacity of the icon displayed on players' screens. A value of
128 means the atom is half-transparent, so it will have a ghostly appearance.
This can be used to fade an atom in and out, especially when combined with
animation. Alpha is also applied to maptext.

<p>Overlays and images will also be affected by alpha, unless they use the
RESET_ALPHA value in appearance_flags.

<hr>

<a name=/atom/var/appearance>
<h2>appearance var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var>vars (atom)</a>
<dd><a href=#/mutable_appearance>mutable appearance</a>
</dl>

<p>Every atom or image has an appearance, which controls all of the values
relating to how it appears on the map. (The overlays and underlays lists are
lists of appearances.) When read, this var provides a copy of the current
appearance.

<p>This value can also be used to change an atom's appearance, altering
multiple values at once. Setting atom.appearance to another appearance will
change all of the following values to match:

<dl>
<dd><a href=#/atom/var/alpha>alpha</a>
<dd><a href=#/atom/var/appearance_flags>appearance_flags</a>
<dd><a href=#/atom/var/blend_mode>blend_mode</a>
<dd><a href=#/atom/var/color>color</a>
<dd><a href=#/atom/var/desc>desc</a>
<dd><a href=#/atom/var/gender>gender</a>
<dd><a href=#/atom/var/icon>icon</a>
<dd><a href=#/atom/var/icon_state>icon_state</a>
<dd><a href=#/atom/var/invisibility>invisibility</a>
<dd><a href=#/atom/var/infra_luminosity>infra_luminosity</a>
<dd><a href=#/atom/var/layer>layer</a>
<dd><a href=#/atom/var/luminosity>luminosity</a>
<dd><a href=#/atom/var/maptext>maptext</a>
<dd><a href=#/atom/var/maptext_width>maptext_width</a>
<dd><a href=#/atom/var/maptext_height>maptext_height</a>
<dd><a href=#/atom/var/maptext_x>maptext_x</a>
<dd><a href=#/atom/var/maptext_y>maptext_y</a>
<dd><a href=#/atom/var/mouse_over_pointer>mouse_over_pointer</a>
<dd><a href=#/atom/var/mouse_drag_pointer>mouse_drag_pointer</a>
<dd><a href=#/atom/var/mouse_drop_pointer>mouse_drop_pointer</a>
<dd><a href=#/atom/var/mouse_drop_zone>mouse_drop_zone var</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var</a>
<dd><a href=#/atom/var/name>name</a>
<dd><a href=#/atom/var/opacity>opacity</a>
<dd><a href=#/atom/var/overlays>overlays</a>
<dd><a href=#/atom/var/override>override</a> (images only)
<dd><a href=#/atom/var/pixel_x>pixel_x</a>
<dd><a href=#/atom/var/pixel_y>pixel_y</a>
<dd><a href=#/atom/var/pixel_w>pixel_w</a>
<dd><a href=#/atom/var/pixel_z>pixel_z</a>
<dd><a href=#/atom/var/plane>plane</a>
<dd><a href=#/atom/var/suffix>suffix</a>
<dd><a href=#/atom/var/text>text</a>
<dd><a href=#/atom/var/transform>transform</a>
<dd><a href=#/atom/var/underlays>underlays</a>
</dl>

<p>Other vars that are technically part of the appearance, but don't make any
sense to change when cloning, are not changed. These include density, dir,
screen_loc, and verbs. However, those vars ARE copied when you assign a
/mutable_appearance.

<p>If you set atom.appearance to another atom, the other atom's appearance
will be copied.

<hr>

<a name=/atom/var/appearance_flags>
<h2>appearance_flags var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var>vars (atom)</a>
<dd><a href=#/atom/var/alpha>alpha var (atom)</a>
<dd><a href=#/atom/var/color>color var (atom)</a>
<dd><a href=#/atom/var/transform>transform var (atom)</a>
<dd><a href=#/client/var/color>color var (client)</a>
<dd><a href=#/{notes}/gliding>Gliding</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<dl><dt><b>Possible values:</b>
<dd>Any combination of:
<dd><b>LONG_GLIDE</b> - Diagonal glides take as long as cardinal ones
<dd><b>RESET_COLOR</b> - If this is an overlay/image/etc., ignore the parent's color
<dd><b>RESET_ALPHA</b> - If this is an overlay/image/etc., ignore the parent's alpha value
<dd><b>RESET_TRANSFORM</b> - If this is an overlay/image/etc., ignore the parent's transform
<dd><b>NO_CLIENT_COLOR</b> - Ignore client.color
<dd><b>KEEP_TOGETHER</b> - Draw this icon along with its overlays and underlays, as one unit
<dd><b>KEEP_APART</b> - Detach from a parent icon that uses KEEP_TOGETHER
<dd><b>PLANE_MASTER</b> - Groups all other icons in the same plane
<dd><b>TILE_BOUND</b> - Avoids more accurate visibility calculations
<dd><b>PIXEL_SCALE</b> - Use point sampling when transforming this icon
</dl>

<p>The appearance_flags value controls miscellaneous behavior of an atom or
appearance that doesn't make sense to handle in any other var.

<p>These values are bitflags, and can be combined with the + or | operator.

<p>The NO_CLIENT_COLOR flag is inherited by overlays and images automatically
unless they have the RESET_COLOR flag.

<h3>KEEP_TOGETHER</h3>

<p>This flag is used to force the overlays and underlays of this icon (its
"children") to be drawn with it all at once, not each icon individually.  One
reason you might want to do this is if your player's icon uses overlays for
hair and equipment, and you want to change the alpha value to make them fade
out.  With regular drawing, changing the parent icon's alpha means that each
individual icon becomes translucent; with KEEP_TOGETHER, the whole combination
fades as one unit.  Because this incurs some small overhead, it should be
avoided for atoms that do not need it.

<p>Any child appearances underneath KEEP_TOGETHER use NO_CLIENT_COLOR
automatically, and RESET_COLOR, RESET_ALPHA, and RESET_TRANSFORM become
meaningless.  Use KEEP_APART with them if you want to use those flags.

<p>Icons that are in a different plane from the parent icon will
automatically have KEEP_APART set and therefore won't be included.

<h3>KEEP_APART</h3>

<p>If this appearance is a child of something that uses KEEP_TOGETHER, it will
be separated out from the main icon and drawn separately.  This may be useful
for things such as health meters, for instance.

<h3>PLANE_MASTER</h3>

<p>Use this flag to group all icons in the same plane and draw them on a
temporary surface the size of the whole screen, and then that image is drawn
over the existing scene.  This is useful for post-processing effects, like
lighting.  The plane master's icon is not drawn, but its color, transform, and
blend_mode are all taken into account when drawing.

<h3>Example</h3>
<xmp>
obj/lighting_plane
    screen_loc = "1,1"
    plane = 2
    blend_mode = BLEND_MULTIPLY
    appearance_flags = PLANE_MASTER | NO_CLIENT_COLOR
    // use 20% ambient lighting; be sure to add full alpha
    color = list(null,null,null,null,"#333f")
    mouse_opacity = 0    // nothing on this plane is mouse-visible

image/spotlight
    plane = 2
    blend_mode = BLEND_ADD
    icon = 'spotlight.dmi'  // a 96x96 white circle
    pixel_x = -32
    pixel_y = -32

mob/Login()
    ..()
    client.screen += new/obj/lighting_plane
    overlays += /image/spotlight
</xmp>

<p>In the example, all objects in plane 2 are lights.  They're added together,
and then the whole image is put through the color matrix, then multiplied over
the rest of the scene below.  This will darken everything that doesn't have a
spotlight overlay, but anywhere a spotlight exists will have a circle of
light.

<p>The example also makes a point of adding full alpha to the plane, because a
PLANE_MASTER is fully transparent by default.

<p>The mouse_opacity set by the plane master will determine how the mouse
interacts with objects on the plane.  See
<a href=#/atom/var/mouse_opacity>mouse_opacity</a> for more info.

<h3>TILE_BOUND</h3>

<p>There are many ways an object may be shifted out of the normal bounds of
the tile it's on: a large icon, pixel offsets, step offsets, and transform.
Ordinarily it's desirable to be able to see the object if it touches any
visible turf. However, in some cases it's more desirable to only show the
object if its actual loc is in view. The TILE_BOUND flag will accomplish
that. This flag is inherited by images and overlays. 

<h3>PIXEL_SCALE</h3>

<p>Normally if an icon is transformed via atom.transform, it uses bilinear
texture sampling which produces a nice smooth effect. If you want a granular
pixel-art effect instead, PIXEL_SCALE will do that for you. This flag is
inherited by images and overlays.

<hr>

<a name=/atom/var/blend_mode>
<h2>blend_mode var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var>vars (atom)</a>
<dd><a href=#/atom/var/alpha>alpha var (atom)</a>
<dd><a href=#/atom/var/color>color var (atom)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0 (none/overlay)
</dl>

<dl><dt><b>Possible values:</b>
<dd>BLEND_DEFAULT (0)
<dd>BLEND_OVERLAY
<dd>BLEND_ADD
<dd>BLEND_SUBTRACT<small>*</small>
<dd>BLEND_MULTIPLY<small>*</small>
</dl>

<p>[<small>*</small> This blend type appears only when using graphics
hardware mode. It is also not visible in the map editor.]

<p>Controls the way the atom's icon is blended onto the icons behind it. The
blend mode used by an atom is inherited by any attached overlays, unless they
override it. BLEND_DEFAULT will use the main atom's blend mode; for the atom
itself, it's the same as BLEND_OVERLAY.

<p>BLEND_OVERLAY will draw an icon the normal way.

<p>BLEND_ADD will do additive blending, so that the colors in the icon are
added to whatever is behind it. Light effects like explosions will tend to
look better in this mode.

<p>BLEND_SUBTRACT is for subtractive blending. This may be useful for special
effects.

<p>BLEND_MULTIPLY will multiply the icon's colors by whatever is behind it.
This is typically only useful for applying a colored light effect; for simply
darkening, using a translucent black icon with normal overlay blending is a
better option.

<hr>

<a name=/atom/var/color>
<h2>color var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var>vars (atom)</a>
<dd><a href=#/atom/var/alpha>alpha var (atom)</a>
<dd><a href=#/atom/var/appearance_flags>appearance_flags var (atom)</a>
<dd><a href=#/atom/var/blend_mode>blend_mode var (atom)</a>
<dd><a href=#/client/var/color>color var (client)</a>
<dd><a href=#/proc/rgb>rgb proc</a>
<dd><a href=#/icon/proc/MapColors>MapColors proc (icon)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>null (white)
</dl>

<dl><dt><b>Possible values:</b>
<dd>null (white)
<dd>any color generated by rgb() (e.g., "#00ff00" for green)
<dd>a matrix (in list form)
</dl>

<p>Controls the color of the icon displayed on players' screens. This color
is multiplied by the icon, so that a white icon will become this color. The
color multiplier is also applied to maptext.

<p>If you include an alpha component in the color, the atom's alpha var will
be set at the same time.

<p>Overlays and images will also be multiplied by this color, unless they use
the RESET_COLOR value in appearance_flags.

<p>The color value can be set to a
<a href=#/{notes}/color-matrix>color matrix</a>, which is a list of values.
This allows for more complex transformations such as adding or subtracting
color, inverting the color, turning to grayscale, shiting hue, etc.  Using
an RGB-only color matrix will include the existing alpha value in the matrix.

<p>When reading the color var, if it is a matrix it will be read out as a
list with 20 items (full RGBA format). 

<hr>

<a name=/atom/var/contents>
<h2>contents list var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/Enter>Enter proc (atom)</a>
<dd><a href=#/atom/proc/Entered>Entered proc (atom)</a>
<dd><a href=#/atom/proc/Exit>Exit proc (atom)</a>
<dd><a href=#/atom/proc/Exited>Exited proc (atom)</a>
<dd><a href=#/atom/movable/var/locs>locs list var (movable atom)</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
<dd><a href=#/list>list</a>
<dd><a href=#/atom/var/loc>loc var (atom)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>List of contained objects.
</dl>

<p>Except in the case of areas, this list is always restricted to objs and
mobs (ie movable objects).  Only direct contents are listed.  Items inside of
a bag object, for example, would not show up in the mob's contents list.

<p>The contents of areas are a little different.  The turfs contained in the
area are in the list along with any objs or mobs directly contained by those
turfs.

<p>If a movable atom uses the bound vars to change its physical size, or
step_x/y to change its position, it may cover more than one turf. In that
case, those turfs' contents won't just contain anything directly in them, but
also any atoms overhanging them. I.e., if a turf is in a mob's locs list,
then the mob is in that turf's contents list. (See
<a href=#/atom/movable/var/locs>locs</a> for more information.)

<hr>

<a name=/atom/var/density>
<h2>density var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/Enter>Enter proc (atom)</a>
<dd><a href=#/atom/proc/Entered>Entered proc (atom)</a>
<dd><a href=#/atom/proc/Exit>Exit proc (atom)</a>
<dd><a href=#/atom/proc/Exited>Exited proc (atom)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0 (1 for mobs)
</dl>

<p>This turns the object's density on or off (1 or 0).  Two dense objects may
not occupy the same space in the standard movement system.

<hr>

<a name=/atom/var/desc>
<h2>desc var (atom)</h2>

<dl><dt><b>Default value:</b>
<dd>null
</dl>

<p>This is the description of the object.

<h3>Example:</h3>
<xmp>
mob/verb/look(atom/O in view())
   if(O.desc) usr << O.desc
   else usr << "It's just \an [O]."
</xmp>

<hr>

<a name=/atom/var/dir>
<h2>dir var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/movable/proc/Move>Move proc (movable atom)</a>
<dd><a href=#/atom/var/icon>icon var (atom)</a>
<dd><a href=#/proc/turn>turn proc</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>SOUTH
</dl>

<dl><dt><b>Possible values:</b>
<dd>NORTH, SOUTH, EAST, WEST, NORTHEAST, NORTHWEST, SOUTHEAST, SOUTHWEST
</dl>

<p>This is the direction that the object is facing.  This has little effect
unless the object's icon is directional.  In the case of a directional icon,
this selects the corresponding orientation from the icon file.

<p>An icon file with only four (cardinal) directions makes the choice of
orientation ambiguous when the true direction is a diagonal.  In that case, of
the two possibilities, the one closest to the previous orientation is
displayed.  Sounds complicated, but it's what one would naturally expect.

<hr>

<a name=/atom/var/gender>
<h2>gender var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/text/macros>macros (text)</a>
<dd><a href=#/atom/var/name>name var (atom)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>"neuter"
</dl>

<p>This sets the object's gender.  This influences text macros like
<code>\he</code>, which may expand to "it", "he", "she", or "they".  Valid
values are:

<xmp>
"neuter"
"male"
"female"
"plural"
</xmp>

These are also defined as constants, which may help prevent typos, since the
compiler will complain if it doesn't recognize what you type:

<xmp>
NEUTER
MALE
FEMALE
PLURAL
</xmp>

<hr>

<a name=/atom/var/icon>
<h2>icon var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/icon>icon proc</a>
<dd><a href=#/atom/var/icon_state>icon_state var (atom)</a>
<dd><a href=#/DM/icon>icons</a>
<dd><a href=#/atom/var/overlays>overlays var (atom)</a>
<dd><a href=#/atom/var/underlays>underlays var (atom)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>null
</dl>

<p>This is the icon file that will be used to represent the object on
graphical clients.

<h3>Example:</h3>
<xmp>
turf/wall
   icon = 'wall.dmi'
</xmp>

<p>You can also assign this to an external file at run-time with an expression
such as file("wall.dmi"), but you would only want to do that when the other
method is not possible, because it requires addition of the file to the
resource cache, which can take a little time.

<p>When this variable is assigned to any dynamically created icon object, that
object gets dumped into the world's resource cache (the <tt>.rsc</tt> file),
and a reference to that cached file is assigned to atom.icon.  In other words,
don't expect comparisons such as <code>usr.icon ==
MyDynamicallyCreatedIcon</code> to work unless you have used fcopy_rsc() to
get a cache reference to your dynamically created icon first.  This is almost
never an issue, so don't worry about it if none of that made any sense to you!

<hr>

<a name=/atom/var/icon_state>
<h2>icon_state var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/flick>flick proc</a>
<dd><a href=#/atom/var/icon>icon var (atom)</a>
<dd><a href=#/proc/icon_states>icon_states proc</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>null
</dl>

<p>Icons may appear differently depending on the icon state.  For example,
turf door icons could have "open" and "closed" states.  If a state is
specified that does not exist in the icon file, the default null state will
be displayed if it exists.

<h3>Example:</h3>
<xmp>
turf/door
   icon_state = "closed"
   density = 1
   verb
      open()
         set src in view(1)
         icon_state = "open"
         density = 0
      close()
         set src in view(1)
         icon_state = "closed"
         density = 1
</xmp>

<hr>

<a name=/atom/var/infra_luminosity>
<h2>infra_luminosity var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/luminosity>luminosity var (atom)</a>
<dd><a href=#/mob/var/see_infrared>see_infrared var (mob)</a>
<dd><a href=#/mob/var/sight>sight var (mob)</a>
<dd><a href=#/proc/view>view proc</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>This causes the object to be visible in the dark to mobs that can see
infrared light.  Nothing but the object itself is lit up by the infrared
emission.  The scale is identical to luminosity: 1 makes it visible only from
the same location; 2 makes it visible from a neighboring position; and so on.

<hr>

<a name=/atom/var/invisibility>
<h2>invisibility var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/verb/set/invisibility>invisibility setting (verb)</a>
<dd><a href=#/atom/var/opacity>opacity var (atom)</a>
<dd><a href=#/mob/var/see_invisible>see_invisible var (mob)</a>
<dd><a href=#/mob/var/sight>sight var (mob)</a>
<dd><a href=#/proc/view>view proc</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<dl><dt><b>Possible values:</b>
<dd>0 to 101
</dl>

<p>This determines the object's level of invisibility.  The corresponding mob
variable <code>see_invisible</code> controls the maximum level of invisibility
that the mob may see.

<p>A value of 101 is absolutely invisible, no matter what, and it is filtered
from all lists of possible values for verb arguments.  This is intended for
objects that exist purely for some internal purpose, such as "verb
containers".

<hr>

<a name=/atom/var/layer>
<h2>layer var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/overlays>overlays var (atom)</a>
<dd><a href=#/atom/var/plane>plane var (atom)</a>
<dd><a href=#/atom/var/z>z var (atom)</a>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
<dd><a href=#/{notes}/BACKGROUND_LAYER>BACKGROUND_LAYER</a>
<dd><a href=#/{notes}/EFFECTS_LAYER>EFFECTS_LAYER</a>
<dd><a href=#/{notes}/TOPDOWN_LAYER>TOPDOWN_LAYER</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>1 (AREA_LAYER)
<dd>2 (TURF_LAYER)
<dd>3 (OBJ_LAYER)
<dd>4 (MOB_LAYER)
</dl>

<p>This numerical value determines the layer in which the object is drawn on
the map.  By default, the order is area, turf, obj, mob, followed by missiles
and images (in FLY_LAYER, which is 5).

<h3>Example:</h3>
<xmp>
turf
   archway
      layer = MOB_LAYER+1  //overhead
</xmp>

<p>When making objects to be used as graphical overlays, you should also be
aware of the special FLOAT_LAYER value.  This causes the overlay (or underlay)
to be in the same drawing layer as the base object, no matter how that layer
changes after the addition of the overlay.  Otherwise, the overlay object's
own drawing layer is used.

<p>The actual drawing order of icons may change depending on world.map_format.
An isometric map for instance has to display tiles that are "closer" to the
viewer in front of tiles that are in the back, so the layer var takes a
backseat to the needs of the map. If you use the TOPDOWN_MAP or TILED_ICON_MAP
map formats, the layer is more important.

<p>If you are using a world.map_format that does not display topdown, such as
ISOMETRIC_MAP or SIDE_MAP, then you can use a special layer for showing certain
portions of the map in topdown mode. For those parts of the map, you can add
TOPDOWN_LAYER to every atom's layer to make the atom appear in topdown mode.
This is for special cases, like for instance a battle map in an RPG, where a
regular topdown view is preferable to the special mapping used by the rest of
the game. It is recommended that you use TOPDOWN_LAYER with every atom in that
portion of the map, since topdown and isometric maps for instance don't mix. If
you use TOPDOWN_LAYER, it is best to use a square size in world.icon_size if
any of these atoms will be moving around.

<p>Another special layer, EFFECTS_LAYER, is also available. Icons that use this
layer will display above icons that don't. TOPDOWN_LAYER will then display
above that. This layer is useful for situations such as using a floating name
or health meter overlay on a mob in isometric mode. When using EFFECTS_LAYER,
other icons on the regular map won't cover the overlay. (It is preferable to
use atom.plane for this, when possible.)

<p>Finally there is BACKGROUND_LAYER. Adding this to an atom's layer will make
it appear below any atoms that do not use BACKGROUND_LAYER.  (It is preferable
to use atom.plane when possible.)

<p>The atom.plane var takes priority over layer.  This is the preferred method
of handling background and effects going forward.


<hr>

<a name=/atom/var/loc>
<h2>loc var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/contents>contents list var (atom)</a>
<dd><a href=#/atom/var/x>x var (atom)</a>
<dd><a href=#/atom/var/y>y var (atom)</a>
<dd><a href=#/atom/var/z>z var (atom)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>The location of the object or null if there is none.
</dl>

<p>The container is always an atom (or null).  For areas, this value is always
null, since an area may not be contained by any other object.

<hr>

<a name=/atom/var/luminosity>
<h2>luminosity var (atom)</h2>

<dl><dt><b>Default value:</b>
<dd>0
<dd>1 (areas)
</dl>

<p>This sets the object's luminosity (how far it casts light).  It must be an
integer in the range 0 to 6.

<p>Areas are a little different.  Any non-zero value in an area results in all
objects within the area being bathed in light.

<hr>

<a name=/atom/var/maptext>
<h2>maptext var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/maptext_width>maptext_width var (atom)</a>
<dd><a href=#/atom/var/maptext_height>maptext_height var (atom)</a>
<dd><a href=#/atom/var/maptext_x>maptext_x var (atom)</a>
<dd><a href=#/atom/var/maptext_y>maptext_y var (atom)</a>
<dd><a href=#/atom/var/overlays>overlays var (atom)</a>
<dd><a href=#/image>image objects</a>
<dd><a href=#/atom/var/pixel_x>pixel_x var (atom)</a>
<dd><a href=#/atom/var/pixel_y>pixel_y var (atom)</a>
<dd><a href=#/atom/var/pixel_w>pixel_w var (atom)</a>
<dd><a href=#/atom/var/pixel_z>pixel_z var (atom)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>null
</dl>

<p>This is optional text that will be displayed in the same position as the
atom. If an atom has both an icon and maptext, the text will be displayed in
front of the icon. Usually however, this is something that would be added to
an overlay or image object, which can then be positioned with pixel offsets.

<p>Map text is constrained to the bounds set by maptext_width and
maptext_height, which default to a single icon in size. It can be offset by
maptext_x and maptext_y.</p>

<p>Text can use HTML and CSS, mostly the same limited subset supported by
regular text output, and different styles can be used in the same block of
text. In addition, alpha colors can also be used, by specifying a color as
#rrggbbaa instead of just #rrggbb. (Alpha transparency will be ignored when
the map is drawn without hardware rendering, so anything below 50% opacity
is not displayed in those cases.)

<hr>

<a name=/atom/var/maptext_width>
<h2>maptext_width var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/maptext>maptext var (atom)</a>
<dd><a href=#/atom/var/maptext_x>maptext_x var (atom)</a>
<dd><a href=#/atom/var/maptext_y>maptext_y var (atom)</a>
<dd><a href=#/atom/var/maptext_height>maptext_height var (atom)</a>
<dd><a href=#/world/var/icon_size>icon_size var (world)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>32 (depends on world.icon_size)
</dl>

<p>This is the width of the text shown in the maptext var. By default, it
uses the icon width provided in world.icon_size.

<hr>

<a name=/atom/var/maptext_height>
<h2>maptext_height var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/maptext>maptext var (atom)</a>
<dd><a href=#/atom/var/maptext_width>maptext_width var (atom)</a>
<dd><a href=#/atom/var/maptext_x>maptext_x var (atom)</a>
<dd><a href=#/atom/var/maptext_y>maptext_y var (atom)</a>
<dd><a href=#/world/var/icon_size>icon_size var (world)</a>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>32 (depends on world.icon_size)
</dl>

<p>This is the height of the text shown in the maptext var. The default value
depends on world.icon_size and world.map_format. In a topdown (default) or
tiled map_format, the icon height is used. In other map views, tile
"footprints" are square and height is irrelevant, so the default will be the
icon width instead.)

<hr>

<a name=/atom/var/maptext_x>
<h2>maptext_x var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/maptext>maptext var (atom)</a>
<dd><a href=#/atom/var/maptext_width>maptext_width var (atom)</a>
<dd><a href=#/atom/var/maptext_height>maptext_height var (atom)</a>
<dd><a href=#/atom/var/maptext_y>maptext_y var (atom)</a>
<dd><a href=#/world/var/icon_size>icon_size var (world)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>Maptext, if used, is offset by this many pixels to the right.

<hr>

<a name=/atom/var/maptext_y>
<h2>maptext_y var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/maptext>maptext var (atom)</a>
<dd><a href=#/atom/var/maptext_width>maptext_width var (atom)</a>
<dd><a href=#/atom/var/maptext_height>maptext_height var (atom)</a>
<dd><a href=#/atom/var/maptext_x>maptext_x var (atom)</a>
<dd><a href=#/world/var/icon_size>icon_size var (world)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>Maptext, if used, is offset by this many pixels upward.

<hr>

<a name=/atom/var/mouse_drag_pointer>
<h2>mouse_drag_pointer var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/MouseDrag>MouseDrag proc (atom)</a>
<dd><a href=#/atom/proc/MouseDrop>MouseDrop proc (atom)</a>
<dd><a href=#/atom/var/mouse_drop_pointer>mouse_drop_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_drop_zone>mouse_drop_zone var (atom)</a>
<dd><a href=#/atom/var/mouse_over_pointer>mouse_over_pointer var (atom)</a>
<dd><a href=#/client/var/mouse_pointer_icon>mouse_pointer_icon var (client)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>MOUSE_INACTIVE_POINTER (0)
</dl>

<p>This defines how the mouse looks when dragging this object.  Assigning this
to MOUSE_ACTIVE_POINTER (1) enables the default dragging indicator.

<p>This variable may also be assigned to any of the other
<a href=#/DM/mouse/pointers>built-in mouse pointers</a>, or a custom icon or
icon state.  If an icon state is specified, this is applied against the object's
main icon to find a custom pointer.

<p>Note that all mouse pointers are purely visual indicators.  They do not
effect what objects may actually be manipulated with the mouse.  You control
all of the real behavior in the associated procedures.

<hr>

<a name=/atom/var/mouse_drop_pointer>
<h2>mouse_drop_pointer var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/MouseDrag>MouseDrag proc (atom)</a>
<dd><a href=#/atom/proc/MouseDrop>MouseDrop proc (atom)</a>
<dd><a href=#/atom/var/mouse_drop_pointer>mouse_drop_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_drop_zone>mouse_drop_zone var (atom)</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var (atom)</a>
<dd><a href=#/atom/var/mouse_over_pointer>mouse_over_pointer var (atom)</a>
<dd><a href=#/client/var/mouse_pointer_icon>mouse_pointer_icon var (client)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>MOUSE_ACTIVE_POINTER (1)
</dl>

<p>This defines how the mouse looks when dragging this object over another
object that has <var>mouse_drop_zone</var> set.  The default value enables the
addition of a standard "droppable" indicator to whatever
<var>mouse_drag_pointer</var> is (unless <var>mouse_drag_pointer</var> is
turned off).

<p>This variable may also be assigned to any of the other
<a href=#/DM/mouse/pointers>built-in mouse pointers</a>, or a custom icon or
icon state.  If an icon state is specified, this is applied against the object's
main icon to find a custom pointer.

<p>Note that all mouse pointers are purely visual indicators.  They do not
effect what objects may actually be manipulated with the mouse.  You control
all of the real behavior in the associated procedures.

<hr>

<a name=/atom/var/mouse_drop_zone>
<h2>mouse_drop_zone var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/MouseDrag>MouseDrag proc (atom)</a>
<dd><a href=#/atom/proc/MouseDrop>MouseDrop proc (atom)</a>
<dd><a href=#/atom/var/mouse_drag_pointer>mouse_drag_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_drop_pointer>mouse_drop_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var (atom)</a>
<dd><a href=#/atom/var/mouse_over_pointer>mouse_over_pointer var (atom)</a>
<dd><a href=#/client/var/mouse_pointer_icon>mouse_pointer_icon var (client)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>Setting this to 1 indicates that this object is a valid site on which to
drop other objects.  While dragging, <var>mouse_drop_cursor</var> of the
object being dragged will become active in this case.  Note that this is a
purely visual effect.  It does not control what the user may do with the
mouse.  You control the real behavior with the associated procedures.

<hr>

<a name=/atom/var/mouse_opacity>
<h2>mouse_opacity var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/mouse>mouse control</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>1
</dl>

<dl><dt><b>Possible values:</b>
<dd>0  // transparent to mouse
<dd>1  // opaque where icon is also opaque
<dd>2  // completely opaque
</dl>

<p>This may be used to control how mouse operations on an object are
interpreted.  A click or mouse movement over an object's icon normally applies
to that object only if it is the top-most object that is not transparent at
the position of the mouse.  Setting mouse_opacity to 0 would cause the object
to be ignored completely, and setting it to 2 causes it to always be chosen
over any lower-level objects, regardless of the transparency of its icon.

<p>When this is applied to a PLANE_MASTER object (see
<a href=#/atom/var/appearance_flags>appearance_flags</a>), a value of 0 means
everything on the plane is mouse-transparent.  1 means everything on the
plane is mouse-visible (using the objects' normal mouse_opacity), but the
plane master itself is not.  2 means everything on the plane is mouse-visible,
and so is the plane master.

<hr>

<a name=/atom/var/mouse_over_pointer>
<h2>mouse_over_pointer var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/Click>Click proc (atom)</a>
<dd><a href=#/atom/proc/MouseEntered>MouseEntered proc (atom)</a>
<dd><a href=#/atom/proc/MouseExited>MouseExited proc (atom)</a>
<dd><a href=#/atom/proc/MouseMove>MouseMove proc (atom)</a>
<dd><a href=#/atom/var/mouse_drag_pointer>mouse_drag_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_drop_pointer>mouse_drop_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_drop_zone>mouse_drop_zone var (atom)</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var (atom)</a>
<dd><a href=#/client/var/mouse_pointer_icon>mouse_pointer_icon var (client)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>MOUSE_INACTIVE_POINTER (0)
</dl>

<p>This defines how the mouse looks when no buttons are pressed and it is held
over this object.  Assigning this to MOUSE_ACTIVE_POINTER (1) enables the
default indicator that there is something special under the mouse
(crosshairs).

<p>This variable may also be assigned to any of the other
<a href=#/DM/mouse/pointers>built-in mouse pointers</a>, or a custom icon or
icon state.  If an icon state is specified, this is applied against the object's
main icon to find a custom pointer.

<p>Note that all mouse pointers are purely visual indicators.  They do not
effect what objects may actually be manipulated with the mouse.  You control
all of the real behavior in the associated procedures.

<hr>

<a name=/atom/var/name>
<h2>name var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/gender>gender var (atom)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>The name of the object type with underscores converted to spaces.
</dl>

<hr>

<a name=/atom/var/opacity>
<h2>opacity var (atom)</h2>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>This turns the object's opacity on or off (1 or 0).  Opaque objects block
light.

<hr>

<a name=/atom/var/overlays>
<h2>overlays var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/icon>icon var (atom)</a>
<dd><a href=#/atom/var/layer>layer var (atom)</a>
<dd><a href=#/list>list</a>
<dd><a href=#/atom/var/underlays>underlays var (atom)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>empty list
</dl>

<p>This is a list of icons which are displayed on top of the object's main
icon.

<p>The individual items in the list may not be directly accessed, since they
are stored in a special internal format.  However, the list operators
<code>+=</code>, <code>-=</code>, and the procedures <code>Add</code>,
<code>Remove</code>, and <code>Cut</code> work normally.

<h3>Example:</h3>
<xmp>
turf/verb/AddOverlay(I as icon)
   overlays += I
turf/verb/RemoveOverlay(I as icon)
   overlays -= I
</xmp>

<p>The data types that may be used as overlays are icons, icon states (text
strings), objects, and object types.  When an icon state is used, the
corresponding image in the object's icon is displayed.  When another object is
used as an overlay, a static "snapshot" of the object is taken at the time
when the overlay is created.  Future changes to the object will not change the
appearance of the overlay.

<p>Overlays have their own independent drawing layer.  It is normally the
special value FLOAT_LAYER, which makes them float above the base object.  If
the overlay is a snapshot of another object, the drawing layer of that object
is used.  The important advantage of using FLOAT_LAYER is that if the layer of
the base object changes, the overlays will move with it into the new layer.

<p>Any negative number may be used in place of FLOAT_LAYER (which happens to
be -1).  They all cause the same "floating" behavior.  However, the overlays
are ordered amongst themselves according to their own relative layer values
(-2 below -1 and so on).  This may be useful if you have several classes of
overlays that should always appear in a certain order, because you would not
have to worry about the order in which you add them to the list.

<h3>Example:</h3>
<xmp>
var/const
   ARMOR_LAYER = FLOAT_LAYER-1
   CLOTHES_LAYER = FLOAT_LAYER-2
obj/overlay
   armor
      icon = 'armor.dmi'
      layer = ARMOR_LAYER
   clothes
      icon = 'clothes.dmi'
      layer = CLOTHES_LAYER
mob/verb
   wear_clothes()
      overlays += /obj/overlay/clothes
   wear_armor()
      overlays += /obj/overlay/armor
   remove_clothes()
      overlays -= /obj/overlay/clothes
   remove_armor()
      overlays -= /obj/overlay/armor
</xmp>

<p>That example used object types, but you can use instances of objects as
well.  Rather than using different "float" layers, you can also just make your
own list of overlays with the order you want and assign that to the actual
overlays list.

<h3>Example:</h3>
<xmp>
mob/var
   boots
   clothes
	armor
mob/proc
   ShowOverlays()
      var/L[0]
      if(boots)   L += boots
      if(clothes) L += clothes
      if(armor)   L += armor
      overlays = L
</xmp>

<hr>

<a name=/atom/var/override>
<h2>override var (atom)</h2>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p><b>Currently this only applies to <a href=#/image>images</a>.</b>

<p>If you attach an image to an atom, normally it is seen only in addition to
the atom's regular icon. If the image's override var is 1, it will be seen
<i>in place of</i> the original atom (and its overlays).  It will inherit the
atom's color, alpha, transform, and appearance_flags, unless its own
appearance_flags say otherwise.

<p>If the image has a specific name and/or suffix value, those will override
the parent atom too. Leaving them blank will let the original atom take
precedence.

<hr>

<a name=/atom/var/pixel_x>
<h2>pixel_x var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/movable/var/animate_movement>animate_movement var (movable atoms)</a>
<dd><a href=#/atom/movable/var/glide_size>glide_size var (movable atoms)</a>
<dd><a href=#/atom/var/pixel_y>pixel_y var (atom)</a>
<dd><a href=#/atom/var/pixel_w>pixel_w var (atom)</a>
<dd><a href=#/atom/var/pixel_z>pixel_z var (atom)</a>
<dd><a href=#/world/var/icon_size>icon_size var (world)</a>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>This displaces the object's icon on the x-axis by the specified number of
pixels. In a project with a standard 32x32 tile size, this can range from -32
to +32. (You can get away with larger displacements, but they are not
guaranteed to work for objects off the edge of the map.)

<p>Since overlays and images can each have their own additional displacements,
this makes it possible to create visual effects that extend beyond the
object's own cell in the turf grid, but which automatically move around with
the object.

<p>This effect is purely visual and does not influence such things as movement
bumping or view() range calculations.

<hr>

<a name=/atom/var/pixel_y>
<h2>pixel_y var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/movable/var/animate_movement>animate_movement var (movable atoms)</a>
<dd><a href=#/atom/movable/var/glide_size>glide_size var (movable atoms)</a>
<dd><a href=#/atom/var/pixel_x>pixel_x var (atom)</a>
<dd><a href=#/atom/var/pixel_w>pixel_w var (atom)</a>
<dd><a href=#/atom/var/pixel_z>pixel_z var (atom)</a>
<dd><a href=#/world/var/icon_size>icon_size var (world)</a>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>This displaces the object's icon on the y-axis by the specified number of
pixels. In a project with a standard 32x32 tile size, this can range from -32
to +32. (You can get away with larger displacements, but they are not
guaranteed to work for objects off the edge of the map.)

<p>Since overlays and images can each have their own additional displacements,
this makes it possible to create visual effects that extend beyond the
object's own cell in the turf grid, but which automatically move around with
the object.

<p>This effect is purely visual and does not influence such things as movement
bumping or view() range calculations.

<hr>

<a name=/atom/var/pixel_w>
<h2>pixel_w var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/movable/var/animate_movement>animate_movement var (movable atoms)</a>
<dd><a href=#/atom/movable/var/glide_size>glide_size var (movable atoms)</a>
<dd><a href=#/atom/var/pixel_x>pixel_x var (atom)</a>
<dd><a href=#/atom/var/pixel_y>pixel_y var (atom)</a>
<dd><a href=#/atom/var/pixel_z>pixel_z var (atom)</a>
<dd><a href=#/world/var/icon_size>icon_size var (world)</a>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>This displaces the object's icon horizontally by the specified number of pixels. This
is meant to be used in situations where world.map_format is used to display something
other than a top-down form, for instance in an isometric or side-view display. In a
top-down mode pixel_w behaves the same as pixel_x, except that it does not rotate with
changes to client.dir.

<p>This effect is purely visual and does not influence such things as movement
bumping or view() range calculations.

<hr>

<a name=/atom/var/pixel_z>
<h2>pixel_z var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/movable/var/animate_movement>animate_movement var (movable atoms)</a>
<dd><a href=#/atom/movable/var/glide_size>glide_size var (movable atoms)</a>
<dd><a href=#/atom/var/pixel_x>pixel_x var (atom)</a>
<dd><a href=#/atom/var/pixel_y>pixel_y var (atom)</a>
<dd><a href=#/atom/var/pixel_w>pixel_w var (atom)</a>
<dd><a href=#/world/var/icon_size>icon_size var (world)</a>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>This displaces the object's icon vertically by the specified number of pixels. This
is meant to be used in situations where world.map_format is used to display something
other than a top-down form, for instance in an isometric or side-view display. In a
top-down mode pixel_z behaves the same as pixel_y, except that it does not rotate with
changes to client.dir.

<p>This effect is purely visual and does not influence such things as movement
bumping or view() range calculations.

<hr>

<a name=/atom/var/plane>
<h2>plane var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/layer>layer var (atom)</a>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<dl><dt><b>Possible values:</b>
<dd>-100 to 100 (integers only)
</dl>

<p>The value of plane overrides layer, and is mainly used for non-topdown map
formats like isometric.  Positive values are drawn on top, and negative values
are drawn below.  This mostly deprecates EFFECTS_LAYER and BACKGROUND_LAYER,
but they can still be useful when using PLANE_MASTER for effects
(see <a href=#/atom/var/appearance_flags>appearance_flags</a>).

<p>The special value FLOAT_PLANE can be used for images and overlays, to take
on the plane of the parent atom. Whenever an icon or icon_state is used
directly as an overlay, this is its plane.

<hr>

<a name=/atom/var/suffix>
<h2>suffix var (atom)</h2>

<dl><dt><b>Default value:</b>
<dd>null
</dl>

<p>This is an optional text string that follows the object's name in the stat
panels.  For example, items in an inventory list are displayed as an icon, a
name, and a suffix.

<hr>

<a name=/atom/var/text>
<h2>text var (atom)</h2>

<dl><dt><b>Default value:</b>
<dd>The first letter of the object's name.
</dl>

<p>This is the character used to represent the object on text clients.

<p>Entering several characters produces a text movie (the state of the art!).
In that case, each character is displayed for a 10th of a second.

<p>HTML tags in the text can be used to modify the colors of the text
characters.  As a convenience, the &lt;font&gt; tag may include a
<code>bgcolor</code> attribute, so you don't have to do a CSS style setting to
accomplish the same thing.

<h3>Example:</h3>
<xmp>
world
   maxx = 10
   maxy = 10
area
   text = "<font bgcolor=blue> "
turf
   text = "<font color=#F00>....<font color=#C00>.."
</xmp>

<p>The example above produces a map with a blue background (from the area) and
turfs (depicted by ".") that flash from bright red to a shorter span of light
red.

<p>Note that in order to see text icons, the user must switch to the text map
in Dream Seeker.  If your DM code never does anything with the icon variable,
then this is the default configuration.  Such applications are known as
<em>advanced</em> iconic text games:)

<hr>

<a name=/atom/var/transform>
<h2>transform var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var>vars (atom)</a>
<dd><a href=#/matrix>matrix</a>
</dl>

<p>An atom can be made to appear rotated, scaled, and/or translated (moved)
by using affine transforms. This takes a matrix and multiplies the x and y
positions of the icon's corners like so:

<xmp>          a d 0
x y 1  *  b e 0  =  x' y' 1
          c f 1</xmp>

<p>This is equivalent to:

<xmp>x' = a*x + b*y + c
y' = d*x + e*y + f</xmp>

<p>You do not need to understand matrix math to use transforms, because you
can use the <a href="#/matrix">matrix datum</a> to do this for you.

<p>Transformations are relative to the center of the icon. They do not apply
to maptext.</p>

<h3>Examples:</h3>
<xmp>
// Rotate the atom by 45 clockwise
src.transform = turn(src.transform, 45)

// OR
var/matrix/M = matrix()
M.Turn(45)
src.transform = M

// Scale the atom by 2x2
src.transform *= 2

// OR
var/matrix/M = matrix()
M.Scale(2,2)
src.transform = M
</xmp>

<p>Whenever you read the atom.transform var, you will get a <i>copy</i> of
the atom's current transformation. Whenever you assign a value to the var,
you will update the transformation.

<p>Assigning null to atom.transform will revert the atom to using no
transformation at all. It is also legal to assign a list with six values,
which is equivalent to using a matrix.

<hr>

<a name=/atom/var/underlays>
<h2>underlays var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/icon>icon var (atom)</a>
<dd><a href=#/list>list</a>
<dd><a href=#/atom/var/overlays>overlays var (atom)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>empty list
</dl>

<p>This is a list of icons which are displayed underneath the object's main
icon.

<p>The individual items in the list may not be directly accessed, since they
are stored in a special internal format.  However, the list operators
<code>+=</code>, <code>-=</code>, and the procedures <code>Add</code>,
<code>Remove</code>, and <code>Cut</code> work normally.

<h3>Example:</h3>
<xmp>
turf/verb/AddUnderlay(I as icon)
   underlays += I
turf/verb/RemoveUnderlay(I as icon)
   underlays -= I
</xmp>

<p>The data types that may be used as underlays are icons, icon states (text
strings), objects, and object types.  When an icon state is used, the
corresponding image in the object's icon is displayed.  When another object is
used as an underlay, a static "snapshot" of that object is taken at the time
when the underlay is created.  Future changes to the object will not change
the appearance of the underlay.

<p>Underlays have their own independent drawing layer.  It is normally the
special value FLOAT_LAYER, which makes them float directly below the base
object.  If the underlay is a snapshot of another object, the drawing layer of
that object is used.

<p>See the discussion of FLOAT_LAYER for <a href=#/atom/var/overlays>overlays</a>,
because the same applies here.

<hr>

<a name=/atom/var/verbs>
<h2>verbs list var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/list>list</a>
<dd><a href=#/proc/typesof>typesof proc</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>The list of verbs defined for the object's prototype.
</dl>

<p>This is a list of the object's verbs.  Initially, it contains all of the
verbs defined in the prototype.  It may be used to add and remove verbs at
runtime.

<p>Note that this variable is not automatically saved when the object is
written to a savefile.  That behavior may change in the future.  In the mean
time, you must save any necessary changes yourself or they will not be
preserved when the object is loaded.

<h3>Example:</h3>
<xmp>
mob/proc/kazaam()
   usr << "Kazaam!"

mob/verb/add_kazaam()
   verbs += /mob/proc/kazaam
mob/verb/remove_kazaam()
   verbs -= /mob/proc/kazaam
</xmp>

<hr>

<a name=/atom/var/x>
<h2>x var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/loc>loc var (atom)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>The x coordinate of the object on the map.
</dl>

<p>You may assign the coordinates of movable objects (mobs and objs), but this
is not advisable.  It is better to compute the new location (with
<code>locate()</code>) and move them to that.  Then you can use the normal
<code>Move()</code> procedure, which enables all the normal movement behavior.

<p>For areas that are on the map, this is the coordinate of the turf with the
lowest z, y, and x coordinate (in that order) that is contained by the area.

<hr>

<a name=/atom/var/y>
<h2>y var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/loc>loc var (atom)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>The y coordinate of the object on the map.
</dl>

<p>You may assign the coordinates of movable objects (mobs and objs), but this
is not advisable.  It is better to compute the new location (with
<code>locate()</code>) and move them to that.  Then you can use the normal
<code>Move()</code> procedure, which enables all the normal movement behavior.

<p>For areas that are on the map, this is the coordinate of the turf with the
lowest z, y, and x coordinate (in that order) that is contained by the area.

<hr>

<a name=/atom/var/z>
<h2>z var (atom)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/layer>layer var (atom)</a>
<dd><a href=#/atom/var/loc>loc var (atom)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>The z coordinate of the object on the map.
</dl>

<p>The z coordinate is how objects move between maps.  When you include
several maps in a project, they are placed on different z levels so that the
full map is a single 3-dimensional space.  It is also possible for a single
map file to contain multiple z levels.

<p>Do not confuse this with drawing layer.  The z coordinate moves an object
between different maps.  The layer variable determines the order in which an
object is drawn graphically relative to other objects at the same position on
the map.

<p>You may assign the coordinates of movable objects (mobs and objs), but this
is not advisable.  It is better to compute the new location (with
<code>locate()</code>) and move them to that.  Then you can use the normal
<code>Move()</code> procedure, which enables all the normal movement behavior.

<p>For areas that are on the map, this is the coordinate of the turf with the
lowest z, y, and x coordinate (in that order) that is contained by the area.

<hr>

<a name=/client>
<h2>client</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/mob/var/client>client var (mob)</a>
<dd><a href=#/mob/var/key>key var (mob)</a>
<dd><a href=#/client/proc>procs (client)</a>
<dd><a href=#/client/var>vars (client)</a>
</dl>

<p>Each connected player has a corresponding client object.  It has
variables and procedures which control aspects of player input/output.  This
object is also responsible for linking the player up to a mob.

<p>The client can be reassigned from its original mob M to a new mob N by
setting N.client = M.client.  This process disconnects the player from M
(calling M.Logout()) and connects the player to N (calling N.Login()).
Setting the mob's key has the same effect.

<p>Additional vars, procs, and verbs may be added to the client in order to
give the player properties that are independent of the mob.

<hr>

<a name=/client/proc>
<h2>procs (client)</h2>

<p>Built-in client procs:

<dl><dt>client/proc
<dd><a href=#/client/proc/AllowUpload>AllowUpload</a>
<dd><a href=#/client/proc/Center>Center</a>
<dd><a href=#/client/proc/CheckPassport>CheckPassport</a>
<dd><a href=#/client/proc/Click>Click</a>
<dd><a href=#/client/proc/Command>Command</a>
<dd><a href=#/client/proc/DblClick>DblClick</a>
<dd><a href=#/client/proc/Del>Del</a>
<dd><a href=#/client/proc/East>East</a>
<dd><a href=#/client/proc/Export>Export</a>
<dd><a href=#/client/proc/Import>Import</a>
<dd><a href=#/client/proc/IsByondMember>IsByondMember</a>
<dd><a href=#/client/proc/MouseDown>MouseDown</a>
<dd><a href=#/client/proc/MouseDrag>MouseDrag</a>
<dd><a href=#/client/proc/MouseDrop>MouseDrop</a>
<dd><a href=#/client/proc/MouseEntered>MouseEntered</a>
<dd><a href=#/client/proc/MouseExited>MouseExited</a>
<dd><a href=#/client/proc/MouseMove>MouseMove</a>
<dd><a href=#/client/proc/MouseUp>MouseUp</a>
<dd><a href=#/client/proc/MouseWheel>MouseWheel</a>
<dd><a href=#/client/proc/Move>Move</a>
<dd><a href=#/client/proc/New>New</a>
<dd><a href=#/client/proc/North>North</a>
<dd><a href=#/client/proc/Northeast>Northeast</a>
<dd><a href=#/client/proc/Northwest>Northwest</a>
<dd><a href=#/client/proc/SendPage>SendPage</a>
<dd><a href=#/client/proc/South>South</a>
<dd><a href=#/client/proc/Southeast>Southeast</a>
<dd><a href=#/client/proc/Southwest>Southwest</a>
<dd><a href=#/client/proc/Stat>Stat</a>
<dd><a href=#/client/proc/Topic>Topic</a>
<dd><a href=#/client/proc/West>West</a>
</dl>

<hr>

<a name=/client/proc/AllowUpload>
<h2>AllowUpload proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/input>input proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>AllowUpload(filename, filelength)
</dl>

<dl><dt><b>When:</b>
<dd>Called when the player attempts to upload a file to the server, through input() or a command.
</dl>

<dl><dt><b>Default action:</b>
<dd>Allows the upload by returning 1.
</dl>

<p>The client who owns this proc (src) is the one trying to upload the file.
If this proc returns a true value, the upload will be allowed. Otherwise, it
will be rejected.

<h3>Example:</h3>
<xmp>
client
   AllowUpload(filename, filelength)
      if(filelength >= 524288)  // 512K (0.5M)
         src << "[filename] is too big to upload!"
         return 0
      return 1
</xmp>

<hr>

<a name=/client/proc/Center>
<h2>Center proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/walk>walk proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Center()
</dl>

<dl><dt><b>When:</b>
<dd>Called when the player presses the "center" key or cursor.
</dl>

<dl><dt><b>Default action:</b>
<dd>Cancels any automated movement by calling walk(usr,0).
</dl>

<hr>

<a name=/client/proc/CheckPassport>
<h2>CheckPassport proc (client)</h2>

<dl><dt><b>Format:</b>
<dd>CheckPassport(passport_identifier)
</dl>

<dl><dt><b>Args:</b>
<dd>passport_identifier: a text string assigned to you by BYOND Hub.
</dl>

<p>This built-in procedure checks to see if the user is subscribed to a
particular BYOND Hub entry. If the user is subscribed, the result is the
number of days left (rounded up) on their subscription, or -1 for lifetime
subscribers.

<h3>Example:</h3>
<xmp>
world
   hub = "My.Hub"  //change this to your own hub entry

mob/var
   full_access

mob/Login()
   if(client.CheckPassport("0123456789abcdef"))
      full_access = 1
   else
      src << "For full access, <a href=\
              'http://www.byond.com/hub/[world.hub]' >subscribe</a>!"
   return ..()
</xmp>

<p>Note that in general the value of world.hub has nothing to do with the
passport you happen to check.  This example assumes the passport number
belongs to world.hub just for the purpose of forwarding the user to the
appropriate subscription page.

<hr>

<a name=/client/proc/Click>
<h2>Click proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/Click>Click proc (atom)</a>
<dd><a href=#/client/proc/DblClick>DblClick proc (client)</a>
<dd><a href=#/client/proc/MouseDown>MouseDown proc (client)</a>
<dd><a href=#/client/proc/MouseDrag>MouseDrag proc (client)</a>
<dd><a href=#/client/proc/MouseDrop>MouseDrop proc (client)</a>
<dd><a href=#/client/proc/MouseEntered>MouseEntered proc (client)</a>
<dd><a href=#/client/proc/MouseExited>MouseExited proc (client)</a>
<dd><a href=#/client/proc/MouseMove>MouseMove proc (client)</a>
<dd><a href=#/client/proc/MouseUp>MouseUp proc (client)</a>
<dd><a href=#/client/proc/MouseWheel>MouseWheel proc (client)</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var (atom)</a>
<dd><a href=#/atom/var/mouse_over_pointer>mouse_over_pointer var (atom)</a>
<dd><a href=#/client/var/show_popup_menus>show_popup_menus var (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Click(object,location,control,params)
</dl>

<dl><dt><b>When:</b>
<dd>Called when the player clicks on the map or in the stat panels.
</dl>

<dl><dt><b>Args:</b>
<dd>object: the object clicked
<dd>location: the client stat panel, location (turf) of object on map, grid cell, or other control-specific info
<dd>control: the name of the skin control involved
<dd>params: other parameters including mouse/keyboard flags, icon offsets, etc.; see <a href="#/DM/mouse">mouse control</a>
</dl>

<dl><dt><b>Default action:</b>
<dd>Call object.Click(location,control,params).
</dl>

<h3>Example:</h3>
<xmp>
client
  Click(O)
    usr << "You clicked [O]"
    ..() // do default action
</xmp>

<p>Note that due to network lag, it is possible when clicking on moving
objects for the location of those objects to have changed by the time the
Click() proc is executed.  That is the reason for the location argument.  It
tells you where the click originally took place.

<hr>

<a name=/client/proc/Command>
<h2>Command proc (client)</h2>

<dl><dt><b>Format:</b>
<dd>Command(command as command_text)
</dl>

<dl><dt><b>When:</b>
<dd>Called when the player types in something that is not understood as a
valid command, or if the player is connected via telnet.
</dl>

<dl><dt><b>Default action:</b>
<dd>None.
</dl>

<p>If this proc is used, players will be able to connect to your world via
telnet. All telnet users' commands are routed through this proc instead of
being parsed into verbs. Players who join the world through Dream Seeker
will have their commands parsed as verbs first, and those commands will end
up here only if there is no applicable verb.

<p>Note that text received by this proc is not interpreted beforehand, so
quotes " and backslashses \ should come through unaltered.

<p>This proc is primarily useful if you want to handle parsing yourself (like
for a MUD), or if your world is a chat server and verbs are not used much.

<hr>

<a name=/client/proc/DblClick>
<h2>DblClick proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Click>Click proc (client)</a>
<dd><a href=#/atom/proc/DblClick>DblClick proc (atom)</a>
<dd><a href=#/client/proc/MouseDown>MouseDown proc (client)</a>
<dd><a href=#/client/proc/MouseDrag>MouseDrag proc (client)</a>
<dd><a href=#/client/proc/MouseDrop>MouseDrop proc (client)</a>
<dd><a href=#/client/proc/MouseEntered>MouseEntered proc (client)</a>
<dd><a href=#/client/proc/MouseExited>MouseExited proc (client)</a>
<dd><a href=#/client/proc/MouseMove>MouseMove proc (client)</a>
<dd><a href=#/client/proc/MouseUp>MouseUp proc (client)</a>
<dd><a href=#/client/proc/MouseWheel>MouseWheel proc (client)</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var (atom)</a>
<dd><a href=#/atom/var/mouse_over_pointer>mouse_over_pointer var (atom)</a>
<dd><a href=#/client/var/show_popup_menus>show_popup_menus var (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>DblClick(object,location,control,params)
</dl>

<dl><dt><b>When:</b>
<dd>Called when the player double-clicks on the map or in the stat panels.
</dl>

<dl><dt><b>Args:</b>
<dd>object: the object double-clicked
<dd>location: the client stat panel, location (turf) of object on map, grid cell, or other control-specific info
<dd>control: the name of the skin control involved
<dd>params: other parameters including mouse/keyboard flags, icon offsets, etc.; see <a href="#/DM/mouse">mouse control</a>
</dl>

<dl><dt><b>Default action:</b>
<dd>Call object.DblClick(location,control,params).
</dl>

<h3>Example:</h3>
<xmp>
client
  DblClick(O)
    usr << "You double-clicked [O]"
    ..() // do default action
</xmp>

<p>Note that due to network lag, it is possible when clicking on moving
objects for the location of those objects to have changed by the time the
DblClick() proc is executed.  That is the reason for the location argument.
It tells you where the click originally took place.

<hr>

<a name=/client/proc/Del>
<h2>Del proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/mob/proc/Logout>Logout proc (mob)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Del()
</dl>

<dl><dt><b>When:</b>
<dd>Called when the player disconnects from the world.
</dl>

<dl><dt><b>Default action:</b>
<dd>If the player is connected to a mob, call mob.Logout() to disconnect.
If the player's connection to the world is still not dead, kill it.
</dl>

<p>Note that this does not automatically delete the player's mob.  If you want
to do that, you could do so in mob.Logout().

<hr>

<a name=/client/proc/East>
<h2>East proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Move>Move proc (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>East()
</dl>

<dl><dt><b>Returns:</b>
<dd>1 on success; 0 on failure.
</dl>

<dl><dt><b>When:</b>
<dd>Called when the player presses the "right" key or cursor.
</dl>

<dl><dt><b>Default action:</b>
<dd>Calls src.Move() towards the east.
</dl>

<hr>

<a name=/client/proc/Export>
<h2>Export proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Import>Import proc (client)</a>
<dd><a href=#/client/proc/New>New proc (client)</a>
<dd><a href=#/world/var/hub>hub var (world)</a>
<dd><a href=#/savefile>savefile</a>
</dl>

<dl><dt><b>Format:</b>
<dd>client.Export(file)
</dl>

<dl><dt><b>Args:</b>
<dd>file: file to send to client
</dl>

<p>This stores the file on the user's computer in a special location unique to 
each registered <a href=#/world/var/hub>world.hub</a> setting.  This is most 
useful for writing a client-side savefile, but any type of file may be stored.  
The purpose of this is to exchange information between different worlds running 
under the same hub path.

<p>When a file is exported to the player's computer, it replaces any
previous file stored by a game with the same <code>world.hub</code> value.
This should not be used for anything requiring high security, because any
other world could make use of the same hub path and access the file.  It
is also possible for the user to tinker with the file, since it resides on
their computer.

<p>To delete the client-side file completely, call
<code>client.Export()</code> with no argument at all.

<h3>Example:</h3>

<xmp>
mob/verb/save()
   var/savefile/F = new()
   F << usr     //write the player's mob
   usr.client.Export(F)

client/New()
   var/client_file = Import()
   if(client_file)
      var/savefile/F = new(client_file) //open it as a savefile
      F >> usr  //read the player's mob
   return ..()
</xmp>

<hr>

<a name=/client/proc/Import>
<h2>Import proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Export>Export proc (client)</a>
<dd><a href=#/client/proc/New>New proc (client)</a>
<dd><a href=#/savefile>savefile</a>
</dl>

<dl><dt><b>Format:</b>
<dd>client.Import(Query)
</dl>

<dl><dt><b>Args:</b>
<dd>Query: optional query parameters
</dl>

<p>When no query parameters are given, this returns the client-side file last
exported with <code>client.Export()</code>.  This comes as an entry in the
resource cache, which can be opened as a savefile among other things.  If
there is no file, null is returned.  For an example, see
<a href=#/client/proc/Export>client.Export</a>.

<p>When there are query parameters, these may be used to import a file from
some alternate source.  Currently this is not supported.

<hr>

<a name=/client/proc/IsByondMember>
<h2>IsByondMember proc (client)</h2>

<dl><dt><b>Format:</b>
<dd>IsByondMember()
</dl>

<dl><dt><b>Args:</b>
<dd>None.
</dl>

<p>This built-in procedure checks to see if the user is a BYOND Member.
Use it to give special in-game rewards to those who support BYOND.

<p>If the user is a Member, the result is the number of days left (rounded
up) on their Membership, or -1 for lifetime Members.

<h3>Example:</h3>
<xmp>
mob/var
   special_features

mob/Login()
   if(client.IsByondMember())
      special_features = 1
   else
      src << "For special features, <a href=\
              'http://members.byond.com/' >become a BYOND Member</a>!"
   return ..()
</xmp>

<hr>

<a name=/client/proc/MouseDown>
<h2>MouseDown proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Click>Click proc (client)</a>
<dd><a href=#/client/proc/DblClick>DblClick proc (client)</a>
<dd><a href=#/atom/proc/MouseDown>MouseDown proc (atom)</a>
<dd><a href=#/client/proc/MouseDrag>MouseDrag proc (client)</a>
<dd><a href=#/client/proc/MouseDrop>MouseDrop proc (client)</a>
<dd><a href=#/client/proc/MouseEntered>MouseEntered proc (client)</a>
<dd><a href=#/client/proc/MouseExited>MouseExited proc (client)</a>
<dd><a href=#/client/proc/MouseMove>MouseMove proc (client)</a>
<dd><a href=#/client/proc/MouseUp>MouseUp proc (client)</a>
<dd><a href=#/client/proc/MouseWheel>MouseWheel proc (client)</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var (atom)</a>
<dd><a href=#/client/var/mouse_pointer_icon>mouse_pointer_icon var (client)</a>
<dd><a href=#/client/var/show_popup_menus>show_popup_menus var (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>MouseDown(object,location,control,params)
</dl>

<dl><dt><b>Args:</b>
<dd>object: the object under the mouse pointer
<dd>location: the turf, stat panel, grid cell, etc. containing the object where it was clicked
<dd>control: the name of the skin control involved
<dd>params: other parameters including mouse/keyboard flags, icon offsets, etc.; see <a href="#/DM/mouse">mouse control</a>
</dl>

<dl><dt><b>Default action:</b>
<dd>Call object.MouseDown(location,control,params).
</dl>

<p>This is called when the a mouse button is pressed while pointing to the
object.  Note that MouseUp() will always be called after MouseDown() is
called, even if over empty space.  That means <var>object</var> and
<var>location</var> may be null.

<p>Don't define this unless you need it, because it generates extra
communication that is otherwise avoided.  Most operations can be done through
Click(), DblClick(), and MouseDrop().  The other procedures are simply
available for completeness.

<p><b>Note:</b> In BYOND 3.5 this procedure took four different arguments:
object, location, icon_x, and icon_y. Since icon_x and icon_y have been replaced,
old code will need to be modified. Games compiled before this change will still
work normally.

<hr>

<a name=/client/proc/MouseDrag>
<h2>MouseDrag proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Click>Click proc (client)</a>
<dd><a href=#/client/proc/DblClick>DblClick proc (client)</a>
<dd><a href=#/client/proc/MouseDown>MouseDown proc (client)</a>
<dd><a href=#/atom/proc/MouseDrag>MouseDrag proc (atom)</a>
<dd><a href=#/client/proc/MouseDrop>MouseDrop proc (client)</a>
<dd><a href=#/client/proc/MouseEntered>MouseEntered proc (client)</a>
<dd><a href=#/client/proc/MouseExited>MouseExited proc (client)</a>
<dd><a href=#/client/proc/MouseMove>MouseMove proc (client)</a>
<dd><a href=#/client/proc/MouseUp>MouseUp proc (client)</a>
<dd><a href=#/client/proc/MouseWheel>MouseWheel proc (client)</a>
<dd><a href=#/client/var/mouse_pointer_icon>mouse_pointer_icon var (client)</a>
<dd><a href=#/client/var/show_popup_menus>show_popup_menus var (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>MouseDrag(src_object,over_object,src_location,over_location,src_control,over_control,params)
</dl>

<dl><dt><b>Args:</b>
<dd>src_object: the object being dragged
<dd>over_object: the object under the mouse pointer
<dd>src_location: the turf, stat panel, grid cell, etc. from where the src object was dragged
<dd>over_location: the turf, stat panel, grid cell, etc. containing the object under the mouse pointer
<dd>src_control: The id of the skin control the object was dragged from
<dd>over_control: The id of the skin control the object was dragged over
<dd>params: other parameters including mouse/keyboard flags, icon offsets, etc.; see <a href="#/DM/mouse">mouse control</a>
</dl>

<dl><dt><b>Default action:</b>
<dd>Call object.MouseDrag(over_object,src_location,over_location,src_control,over_control,params).
</dl>

<p>This is called while dragging an object by pressing and holding the left
mouse button over the object and moving the mouse.  The over_object may be
null if dragging over a stat panel or over other empty space.

<p>Don't define this unless you need it, because it generates extra
communication that is otherwise avoided.  Most operations can be done through
Click(), DblClick(), and MouseDrop().  The other procedures are simply
available for completeness.

<hr>

<a name=/client/proc/MouseDrop>
<h2>MouseDrop proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Click>Click proc (client)</a>
<dd><a href=#/client/proc/DblClick>DblClick proc (client)</a>
<dd><a href=#/client/proc/MouseDown>MouseDown proc (client)</a>
<dd><a href=#/client/proc/MouseDrag>MouseDrag proc (client)</a>
<dd><a href=#/atom/proc/MouseDrop>MouseDrop proc (atom)</a>
<dd><a href=#/client/proc/MouseEntered>MouseEntered proc (client)</a>
<dd><a href=#/client/proc/MouseExited>MouseExited proc (client)</a>
<dd><a href=#/client/proc/MouseMove>MouseMove proc (client)</a>
<dd><a href=#/client/proc/MouseUp>MouseUp proc (client)</a>
<dd><a href=#/client/proc/MouseWheel>MouseWheel proc (client)</a>
<dd><a href=#/client/var/mouse_pointer_icon>mouse_pointer_icon var (client)</a>
<dd><a href=#/client/var/show_popup_menus>show_popup_menus var (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>MouseDrop(src_object,over_object,src_location,over_location,src_control,over_control,params)
</dl>

<dl><dt><b>Args:</b>
<dd>src_object: the object being dropped
<dd>over_object: the object under the mouse pointer
<dd>src_location: the turf, stat panel, grid cell, etc. from where the src object was dragged
<dd>over_location: the turf, stat panel, grid cell, etc. containing the object under the mouse pointer
<dd>src_control: The id of the skin control the object was dragged from
<dd>over_control: The id of the skin control the object was dropped onto
<dd>params: other parameters including mouse/keyboard flags, icon offsets, etc.; see <a href="#/DM/mouse">mouse control</a>
</dl>

<dl><dt><b>Default action:</b>
<dd>Call object.MouseDrop(over_object,src_location,over_location,src_control,over_control,params).
</dl>

<p>This is called when a mouse button is released after dragging an
object.  The over_object may be null if dropping over a stat panel or over
other empty space.

<hr>

<a name=/client/proc/MouseEntered>
<h2>MouseEntered proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Click>Click proc (client)</a>
<dd><a href=#/client/proc/DblClick>DblClick proc (client)</a>
<dd><a href=#/client/proc/MouseDrag>MouseDrag proc (client)</a>
<dd><a href=#/client/proc/MouseDrop>MouseDrop proc (client)</a>
<dd><a href=#/atom/proc/MouseEntered>MouseEntered proc (atom)</a>
<dd><a href=#/client/proc/MouseExited>MouseExited proc (client)</a>
<dd><a href=#/client/proc/MouseMove>MouseMove proc (client)</a>
<dd><a href=#/client/proc/MouseUp>MouseUp proc (client)</a>
<dd><a href=#/client/proc/MouseWheel>MouseWheel proc (client)</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var (atom)</a>
<dd><a href=#/client/var/mouse_pointer_icon>mouse_pointer_icon var (client)</a>
<dd><a href=#/client/var/show_popup_menus>show_popup_menus var (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>MouseEntered(object,location,control,params)
</dl>

<dl><dt><b>Args:</b>
<dd>object: the object under the mouse pointer
<dd>location: the turf, stat panel, grid cell, etc. containing the object where it was clicked
<dd>control: the name of the skin control involved
<dd>params: other parameters including mouse/keyboard flags, icon offsets, etc.; see <a href="#/DM/mouse">mouse control</a>
</dl>

<dl><dt><b>Default action:</b>
<dd>Call object.MouseEntered(location,control,params).
</dl>

<p>This is called when no mouse buttons are pressed while pointing to the
object.

<p>Don't define this unless you need it, because it generates extra
communication that is otherwise avoided.  Defining it on only the objects that
require it reduces overhead.

<hr>

<a name=/client/proc/MouseExited>
<h2>MouseExited proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Click>Click proc (client)</a>
<dd><a href=#/client/proc/DblClick>DblClick proc (client)</a>
<dd><a href=#/client/proc/MouseDrag>MouseDrag proc (client)</a>
<dd><a href=#/client/proc/MouseDrop>MouseDrop proc (client)</a>
<dd><a href=#/client/proc/MouseEntered>MouseEntered proc (client)</a>
<dd><a href=#/atom/proc/MouseExited>MouseExited proc (atom)</a>
<dd><a href=#/client/proc/MouseMove>MouseMove proc (client)</a>
<dd><a href=#/client/proc/MouseUp>MouseUp proc (client)</a>
<dd><a href=#/client/proc/MouseWheel>MouseWheel proc (client)</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var (atom)</a>
<dd><a href=#/client/var/mouse_pointer_icon>mouse_pointer_icon var (client)</a>
<dd><a href=#/client/var/show_popup_menus>show_popup_menus var (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>MouseExited(object,location,control,params)
</dl>

<dl><dt><b>Args:</b>
<dd>object: the object under the mouse pointer
<dd>location: the turf, stat panel, grid cell, etc. containing the object where it was clicked
<dd>control: the name of the skin control involved
<dd>params: other parameters including mouse/keyboard flags, icon offsets, etc.; see <a href="#/DM/mouse">mouse control</a>
</dl>

<dl><dt><b>Default action:</b>
<dd>Call object.MouseExited(location,control,params).
</dl>

<p>This is called when the mouse moves off of an object.

<p>Don't define this unless you need it, because it generates extra
communication that is otherwise avoided.  Defining it on only the objects that
require it reduces overhead.

<hr>

<a name=/client/proc/MouseMove>
<h2>MouseMove proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Click>Click proc (client)</a>
<dd><a href=#/client/proc/DblClick>DblClick proc (client)</a>
<dd><a href=#/client/proc/MouseDrag>MouseDrag proc (client)</a>
<dd><a href=#/client/proc/MouseDrop>MouseDrop proc (client)</a>
<dd><a href=#/client/proc/MouseEntered>MouseEntered proc (client)</a>
<dd><a href=#/client/proc/MouseExited>MouseExited proc (client)</a>
<dd><a href=#/atom/proc/MouseMove>MouseMove proc (atom)</a>
<dd><a href=#/client/proc/MouseUp>MouseUp proc (client)</a>
<dd><a href=#/client/proc/MouseWheel>MouseWheel proc (client)</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var (atom)</a>
<dd><a href=#/client/var/mouse_pointer_icon>mouse_pointer_icon var (client)</a>
<dd><a href=#/client/var/show_popup_menus>show_popup_menus var (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>MouseMove(object,location,control,params)
</dl>

<dl><dt><b>Args:</b>
<dd>object: the object under the mouse pointer
<dd>location: the turf, stat panel, grid cell, etc. containing the object where it was clicked
<dd>control: the name of the skin control involved
<dd>params: other parameters including mouse/keyboard flags, icon offsets, etc.; see <a href="#/DM/mouse">mouse control</a>
</dl>

<dl><dt><b>Default action:</b>
<dd>Call object.MouseMove(location,control,params).
</dl>

<p>This is called when no mouse buttons are pressed while pointing to the
object, and the mouse has moved. The first time the mouse moves over the
object, MouseEntered() is called instead.

<p>Don't define this unless you need it, because it generates extra
communication that is otherwise avoided.  Defining it on only the objects that
require it reduces overhead.

<hr>

<a name=/client/proc/MouseUp>
<h2>MouseUp proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Click>Click proc (client)</a>
<dd><a href=#/client/proc/DblClick>DblClick proc (client)</a>
<dd><a href=#/client/proc/MouseDown>MouseDown proc (client)</a>
<dd><a href=#/client/proc/MouseDrag>MouseDrag proc (client)</a>
<dd><a href=#/client/proc/MouseDrop>MouseDrop proc (client)</a>
<dd><a href=#/client/proc/MouseEntered>MouseEntered proc (client)</a>
<dd><a href=#/client/proc/MouseExited>MouseExited proc (client)</a>
<dd><a href=#/client/proc/MouseMove>MouseMove proc (client)</a>
<dd><a href=#/atom/proc/MouseUp>MouseUp proc (atom)</a>
<dd><a href=#/client/proc/MouseWheel>MouseWheel proc (client)</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var (atom)</a>
<dd><a href=#/client/var/mouse_pointer_icon>mouse_pointer_icon var (client)</a>
<dd><a href=#/client/var/show_popup_menus>show_popup_menus var (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>MouseUp(object,location,control,params)
</dl>

<dl><dt><b>Args:</b>
<dd>object: the object under the mouse pointer
<dd>location: the turf, stat panel, grid cell, etc. containing the object where it was clicked
<dd>control: the name of the skin control involved
<dd>params: other parameters including mouse/keyboard flags, icon offsets, etc.; see <a href="#/DM/mouse">mouse control</a>
</dl>

<dl><dt><b>Default action:</b>
<dd>Call object.MouseUp(location,control,params).
</dl>

<p>This is called when a mouse button is released while pointing to
an object.

<p>Don't define this unless you need it, because it generates extra
communication that is otherwise avoided.  Most operations can be done through
Click(), DblClick(), and MouseDrop().  The other procedures are simply
available for completeness.

<p><b>Note:</b> In BYOND 3.5 this procedure took four different arguments:
object, location, icon_x, and icon_y. Since icon_x and icon_y have been replaced,
old code will need to be modified. Games compiled before this change will still
work normally.

<hr>

<a name=/client/proc/MouseWheel>
<h2>MouseWheel proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Click>Click proc (client)</a>
<dd><a href=#/client/proc/DblClick>DblClick proc (client)</a>
<dd><a href=#/client/proc/MouseDown>MouseDown proc (client)</a>
<dd><a href=#/client/proc/MouseDrag>MouseDrag proc (client)</a>
<dd><a href=#/client/proc/MouseDrop>MouseDrop proc (client)</a>
<dd><a href=#/client/proc/MouseEntered>MouseEntered proc (client)</a>
<dd><a href=#/client/proc/MouseExited>MouseExited proc (client)</a>
<dd><a href=#/client/proc/MouseMove>MouseMove proc (client)</a>
<dd><a href=#/client/proc/MouseUp>MouseUp proc (client)</a>
<dd><a href=#/atom/proc/MouseWheel>MouseWheel proc (atom)</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var (atom)</a>
<dd><a href=#/client/var/mouse_pointer_icon>mouse_pointer_icon var (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>MouseWheel(object,delta_x,delta_y,location,control,params)
</dl>

<dl><dt><b>Args:</b>
<dd>object: the object under the mouse pointer
<dd>delta_x,delta_y: amount of wheel movement
<dd>location: the turf, stat panel, grid cell, etc. containing the object
<dd>control: the name of the skin control involved
<dd>params: other parameters including mouse/keyboard flags, icon offsets, etc.; see <a href="#/DM/mouse">mouse control</a>
</dl>

<dl><dt><b>Default action:</b>
<dd>Call object.MouseWheel(delta_x,delta_y,location,control,params).
</dl>

<p>This is called when the mouse wheel is moved while over an object or
control. It is NOT called if over a browser control, or any control that is
currently scrollable.

<p>Positive values of delta_x and delta_y refer to scrolling right or up,
respectively. Negative values are left and down, respectively.

<p>Don't define this unless you need it, because it generates extra
communication that is otherwise avoided.  If you only need wheel support on
specific objects, use atom.MouseWheel() instead which is more selective.

<hr>

<a name=/client/proc/Move>
<h2>Move proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/East>East proc (client)</a>
<dd><a href=#/atom/movable/proc/Move>Move proc (movable atom)</a>
<dd><a href=#/client/proc/North>North proc (client)</a>
<dd><a href=#/client/proc/Northeast>Northeast proc (client)</a>
<dd><a href=#/client/proc/Northwest>Northwest proc (client)</a>
<dd><a href=#/client/proc/South>South proc (client)</a>
<dd><a href=#/client/proc/Southeast>Southeast proc (client)</a>
<dd><a href=#/client/proc/Southwest>Southwest proc (client)</a>
<dd><a href=#/client/proc/West>West proc (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Move(loc,dir)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 on success; 0 on failure
</dl>

<dl><dt><b>When:</b>
<dd>Called by the direction procs.
</dl>

<dl><dt><b>Default action:</b>
<dd>Calls src.mob.Move().  Also cancels any automated movement by
    calling walk(usr,0).
</dl>

<hr>

<a name=/client/proc/New>
<h2>New proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Export>Export proc (client)</a>
<dd><a href=#/client/proc/Import>Import proc (client)</a>
<dd><a href=#/mob/proc/Login>Login proc (mob)</a>
<dd><a href=#/datum/proc/New>New proc (datum)</a>
<dd><a href=#/client/proc/Topic>Topic proc (client)</a>
<dd><a href=#/world/var/mob>mob var (world)</a>
<dd><a href=#/savefile>savefile</a>
</dl>

<dl><dt><b>Format:</b>
<dd>New(TopicData)
</dl>

<dl><dt><b>Returns:</b>
<dd>The newly connected mob, client.mob, or null to disallow the connection.
</dl>

<dl><dt><b>When:</b>
<dd>Called when the player first tries to connect to the world.
</dl>

<dl><dt><b>Args:</b>
<dd>usr: The mob in the world with the same key as the player, if it exists.
<dd>TopicData: If the player accessed the world with a "connection topic",
    this is the topic text.  Otherwise it is null.
</dl>

<dl><dt><b>Default action:</b>
<dd>Look for an existing mob with the same key as the player.  If found,
  connect the player to that mob (mob.Login()).  Otherwise, look for a
  prototype mob with the same key as the player.  If found, create a mob of
  that type and connect the player to it.  Otherwise, create a mob of type
  world.mob, give it the same name and gender as the player's key, and
  connect the player to it.  If TopicData is not null, call
  client.Topic(TopicData).  Finally, the player's mob is returned.
</dl>

<p>This is a fairly low-level procedure that you would only want to override
if you cannot accomplish the same thing in <code>mob/Login()</code> or
<code>mob/New()</code>.  One reason to override <code>client/New()</code> is
if player mobs are created from a savefile.  In that case, you don't need a
temporary mob to be created first.

<h3>Example:</h3>
<xmp>
client/New()
   if(usr) return ..() //reconnecting to existing mob
   else
      var/player_sav = "players/[ckey].sav"
      if(length(file(player_sav)))        //if player savefile exists
         var/savefile/F = new(player_sav) //open it
         F >> usr    //create saved mob
      return ..()    //creates a new mob if necessary
mob/Logout()
   var/player_sav = "players/[ckey].sav"
   var/savefile/F = new(player_sav)
   F << src
   del src
</xmp>

<p>If you want to do any user-interaction before loading the saved mob, you
will have to create a temporary mob first in order to interact with the
player.  In that case, you are better off doing things in
<code>mob/Login()</code>, rather than <code>client/New()</code>.

<p>Note that for the above example to work, you <strong>must</strong> make
proper use of the <a href=#/var/tmp>tmp</a> flag when defining new object
variables.  Otherwise, this can end up sucking large portions of your world
into each player savefile, which can have all sorts of unexpected
consequences!

<hr>

<a name=/client/proc/North>
<h2>North proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Move>Move proc (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>North()
</dl>

<dl><dt><b>Returns:</b>
<dd>1 on success; 0 on failure.
</dl>

<dl><dt><b>When:</b>
<dd>Called when the player presses the "up" key or cursor.
</dl>

<dl><dt><b>Default action:</b>
<dd>Calls src.Move() towards the north.
</dl>

<hr>

<a name=/client/proc/Northeast>
<h2>Northeast proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Move>Move proc (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Northeast()
</dl>

<dl><dt><b>Returns:</b>
<dd>1 on success; 0 on failure.
</dl>

<dl><dt><b>When:</b>
<dd>Called when the player presses the "up-right" key or cursor.
</dl>

<dl><dt><b>Default action:</b>
<dd>Calls src.Move() towards the northeast.
</dl>

<hr>

<a name=/client/proc/Northwest>
<h2>Northwest proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Move>Move proc (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Northwest()
</dl>

<dl><dt><b>Returns:</b>
<dd>Returns 1 on success; 0 on failure.
</dl>

<dl><dt><b>When:</b>
<dd>Called when the player presses the "up-left" key or cursor.
</dl>

<dl><dt><b>Default action:</b>
<dd>Calls src.Move() towards the northwest.
</dl>

<hr>

<a name=/client/proc/SendPage>
<h2>SendPage proc (client)</h2>

<dl><dt><b>Format:</b>
<dd>SendPage(msg,recipient,options)
</dl>

<dl><dt><b>Returns:</b>
<dd>Returns number of recipients successfully contacted.
</dl>

<dl><dt><b>Args:</b>
<dd>msg: text to send
<dd>recipient: key or list of keys to page
<dd>options: text string containing key=value options
</dl>

<p>The user is prompted to authorize sending of the pager message.  The
recipient may easily respond or jump to the sender's location by clicking on
the link in the pager message.  The effect is identical to that of the
sending a page through the Dream Seeker pager.

<p>The options are encoded in the same format read by text2params().  The
valid options are:

<dl>
<dt>summon (0/1)</dt>

<dd>If not included in the options, this is 0.  If included in the options
without assigning it to anything, it is 1.  A value of 1 sends the recipient
the sender's location so they can join by clicking on the message.

<dt>email (0/1)</dt>

<dd>If not included in the options, this is 0.  If included in the options
without assigning it to anything, it is 1.  A value of 1 sends causes the
message to be delivered as email.  If this is not possible, it is delivered as
a long-lived pager message.  Normally, pager messages expire within a short
time after being sent (half an hour).

<dt>subject</dt>

<dd>For email messages, this specifies the subject to use.

</dl>

<hr>

<a name=/client/proc/South>
<h2>South proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Move>Move proc (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>South()
</dl>

<dl><dt><b>Returns:</b>
<dd>Returns 1 on success; 0 on failure.
</dl>

<dl><dt><b>When:</b>
<dd>Called when the player presses the "down" key or cursor.
</dl>

<dl><dt><b>Default action:</b>
<dd>Calls src.Move() towards the south.
</dl>

<hr>

<a name=/client/proc/Southeast>
<h2>Southeast proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Move>Move proc (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Southeast()
</dl>

<dl><dt><b>Returns:</b>
<dd>1 on success; 0 on failure.
</dl>

<dl><dt><b>When:</b>
<dd>Called when the player presses the "down-right" key or cursor.
</dl>

<dl><dt><b>Default action:</b>
<dd>Calls src.Move() towards the southeast.
</dl>

<hr>

<a name=/client/proc/Southwest>
<h2>Southwest proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Move>Move proc (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Southwest()
</dl>

<dl><dt><b>Returns:</b>
<dd>Returns 1 on success; 0 on failure.
</dl>

<dl><dt><b>When:</b>
<dd>Called when the player presses the "down-left" key or cursor.
</dl>

<dl><dt><b>Default action:</b>
<dd>Calls src.Move() towards the southwest.
</dl>

<hr>

<a name=/client/proc/Stat>
<h2>Stat proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/Stat>Stat proc (atom)</a>
<dd><a href=#/proc/stat>stat proc</a>
<dd><a href=#/client/var/statobj>statobj var (client)</a>
<dd><a href=#/proc/statpanel>statpanel proc</a>
<dd><a href=#/client/var/statpanel>statpanel var (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Stat()
</dl>

<dl><dt><b>When:</b>
<dd>Called periodically by the client to update the stat window.
</dl>

<dl><dt><b>Default action:</b>
<dd>Call statobj.Stat().
</dl>

<p>If this procedure sleeps (or engages in some other waiting operation), it
will not be called again until it finally returns.  This allows you to
effectively decrease the frequency of calls to the proc.  You might want to
do that if it is a fairly lengthy procedure, and frequent calls are slowing
things down.

<p>To increase the frequency of stat updates, you can lower
<code>world.tick_lag</code>.

<hr>

<a name=/client/proc/Topic>
<h2>Topic proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/New>New proc (client)</a>
<dd><a href=#/datum/proc/Topic>Topic proc (datum)</a>
<dd><a href=#/proc/link>link proc</a>
<dd><a href=#/DM/text/macros/ref>ref text macro</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Topic(href,href_list[],hsrc)
</dl>

<dl><dt><b>When:</b>
<dd>Called when a player connects to a world with a "connection topic" or
    when the player runs a hyperlink in the current world by clicking one
    embedded in text or generated by the link() instruction.
</dl>

<dl><dt><b>Args:</b>
<dd>href: The topic text (everything after the '?' in the full href).
<dd>href_list: List of key/value pairs in href (produced from params2list(href)).
<dd>hsrc: The object referenced by the "src" parameter in href or null if none.
</dl>

<dl><dt><b>Default action:</b>
<dd>Call the hsrc object's own Topic() proc.
</dl>

<p>The following example uses a very simple href value.

<h3>Example:</h3>
<xmp>
mob/Login()
  src << "Click <a href=?source>here</a> to download the source code."
  return ..()

client/Topic(href)
  if(href == "source")
    usr << file("world.dm")
    usr << file("world.rsc")
  else ..()
</xmp>

<p>Be sure to call the default handler unless you want to prevent rerouting
of topics to other objects.  For security reasons, you might want to control
which objects a player has access to, since a player could spoof a topic
link containing any arbitrary object reference.  (Never trust those sneaky
players!)

<p>The next example demonstrates an href that gets handled by another object.
This is how you would normally want to do things.  It is best not to override
client/Topic() (as in the example above) unless you need to intervene in the
low-level details of routing the request to the right object.

<p>You specify the object that will handle the request by using a parameter
called "src".

<h3>Example:</h3>
<xmp>
mob/Login()
   src << "Click <a href='?src=\ref[src];action=startgame'>here</a> to start."
   return ..()

mob/Topic(href,href_list[])
   switch(href_list["action"])
      if("startgame")
         usr << "Starting game..."
      else
         return ..()
</xmp>

<p>Although it is slightly more complex, the use of the parameter list allows
you to easily include extra data and new functionality.  Just remember that
the data in the list is always stored as text, so if you are expecting a
number or an object, you must convert it yourself (with text2num(), locate(),
or whatever).

<hr>

<a name=/client/proc/West>
<h2>West proc (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Move>Move proc (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>West()
</dl>

<dl><dt><b>Returns:</b>
<dd>Returns 1 on success; 0 on failure.
</dl>

<dl><dt><b>When:</b>
<dd>Called when the player presses the "left" key or cursor.
</dl>

<dl><dt><b>Default action:</b>
<dd>Calls src.Move() towards the west.
</dl>

<hr>

<a name=/client/var>
<h2>vars (client)</h2>

<p>Built-in client vars:

<dl><dt>client/var
<dd><a href=#/client/var/address>address</a>
<dd><a href=#/client/var/authenticate>authenticate</a>
<dd><a href=#/client/var/bounds>bounds</a>
<dd><a href=#/client/var/byond_version>byond_version</a>
<dd><a href=#/client/var/CGI>CGI</a>
<dd><a href=#/client/var/ckey>ckey</a>
<dd><a href=#/client/var/color>color</a>
<dd><a href=#/client/var/command_text>command_text</a>
<dd><a href=#/client/var/connection>connection</a>
<dd><a href=#/client/var/control_freak>control_freak</a>
<dd><a href=#/client/var/computer_id>computer_id</a>
<dd><a href=#/client/var/default_verb_category>default_verb_category</a>
<dd><a href=#/client/var/dir>dir</a>
<dd><a href=#/client/var/edge_limit>edge_limit</a>
<dd><a href=#/client/var/eye>eye</a>
<dd><a href=#/client/var/fps>fps</a>
<dd><a href=#/client/var/gender>gender</a>
<dd><a href=#/client/var/glide_size>glide_size</a>
<dd><a href=#/client/var/images>images</a>
<dd><a href=#/client/var/inactivity>inactivity</a>
<dd><a href=#/client/var/key>key</a>
<dd><a href=#/client/var/lazy_eye>lazy_eye</a>
<dd><a href=#/client/var/mob>mob</a>
<dd><a href=#/client/var/mouse_pointer_icon>mouse_pointer_icon</a>
<dd><a href=#/client/var/perspective>perspective</a>
<dd><a href=#/client/var/pixel_x>pixel_x</a>
<dd><a href=#/client/var/pixel_y>pixel_y</a>
<dd><a href=#/client/var/pixel_w>pixel_w</a>
<dd><a href=#/client/var/pixel_z>pixel_z</a>
<dd><a href=#/client/var/preload_rsc>preload_rsc</a>
<dd><a href=#/client/var/screen>screen</a>
<dd><a href=#/client/var/script>script</a>
<dd><a href=#/client/var/show_map>show_map</a>
<dd><a href=#/client/var/show_popup_menus>show_popup_menus var</a>
<dd><a href=#/client/var/show_verb_panel>show_verb_panel</a>
<dd><a href=#/client/var/statobj>statobj</a>
<dd><a href=#/client/var/statpanel>statpanel</a>
<dd><a href=#/client/var/tick_lag>tick_lag</a>
<dd><a href=#/client/var/verbs>verbs</a>
<dd><a href=#/client/var/view>view</a>
<dd><a href=#/client/var/virtual_eye>virtual_eye</a>
</dl>

<hr>

<a name=/client/var/CGI>
<h2>CGI var (client)</h2>

<p>In CGI mode, DreamDaemon is normally being executed by a web server and
accessed by a web browser.  The CGI object is an add-on to the basic client
object for handling this case.

<p>The CGI object is defined and documented in a separate code library
<code>html/CGI.dm</code>.  You can find the current version at
<a href="http://www.byond.com/developer/Dantom/CGI">www.byond.com</a>.

<hr>

<a name=/client/var/address>
<h2>address var (client)</h2>

<dl><dt><b>Default value:</b>
<dd>The network address of the player's client.
</dl>

<p>This is a read-only value which contains the player's network address.

<hr>

<a name=/client/var/authenticate>
<h2>authenticate var (client)</h2>

<p>This value may be set to 0 at compile-time to disable BYOND hub-based
authentication of users.  The default value is 1, which enables
authentication.  Hub authentication provides an additional level of
assurance that the user is really the owner of the BYOND key in question.

<p>When a world requests certification, Dream Seeker generates a random
password and passes it through the hub (for certification) to the world.
The certificate is saved for faster access in the future and for protection
against possible hub outages.

<p>Some applications do not depend on the validity of the user's identity.
In that case, it would be more efficient to turn off the extra level of
authentication.  In other situations, the hub may not be available, such as
from behind a firewall or on a LAN without internet access.  In those cases,
all hub access (including authentication) can be disabled by entering the
command ".configuration hub-address none" in Dream Seeker.

<p>Connections to worlds on the same machine are not hub-authenticated to
allow for convenient offline testing.

<hr>

<a name=/client/var/bounds>
<h2>bounds var (client)</h2>

Also bound_x, bound_y, bound_width, and bound_height

<dl><dt><b>See also:</b>
<dd><a href=#/proc/bounds>bounds proc</a>
</dl>

<p>The read-only bounds var returns the map coordinates, in pixels, covered
by the client's viewport when accounting for pixel offsets, eye, step, etc.
(The coordinates are only relevant to the default client.dir value of NORTH,
and the TOPDOWN_MAP or SIDE_MAP map formats.)

<p>If the viewport is not currently on the map (for instance, when the eye is
at a null location), the var reads as null.  Otherwise, it is a list with
five values (x, y, width, height, z) in the same form used by the bounds proc.

<p>The alias vars bound_x, bound_y, bound_width, and bound_height can also
be used to retrieve the individual values from the list.  They too will be
null if the viewport is not on the map.

<hr>

<a name=/client/var/byond_version>
<h2>byond_version var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/preprocessor/DM_VERSION>DM_VERSION macro</a>
<dd><a href=#/world/var/byond_version>byond_version var (world)</a>
<dd><a href=#/world/var/system_type>system_type var (world)</a>
</dl>

<p>This is the version of BYOND being run by this client.  A game designed to
work around known bugs in older versions could use this to adapt its behavior
accordingly.  It is also possible to prevent players with much older versions
from joining the game.

<hr>

<a name=/client/var/ckey>
<h2>ckey var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/ckey>ckey proc</a>
<dd><a href=#/client/var/key>key var (client)</a>
</dl>

<p>This is a read-only value that is the canonical form of the player's key
(ie the value returned by ckey()).  Among other things, this could be used
as a unique directory name in a server-side save file for storing player
information.  See the ckey() proc for an example.

<hr>

<a name=/client/var/color>
<h2>color var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/color>color var (atom)</a>
<dd><a href=#/atom/var/appearance_flags>appearance_flags var (atom)</a>
</dl>

<p>Casts a color multiplication or <a href=#/{notes}/color-matrix>matrix</a>
effect over the entire main map.  This behaves exactly the same as
atom.color, and will be combined with atom.color (which comes first) where
present.  See <a href=#/atom/var/color>atom.color</a> for more information.

<p>If a matrix is used, the alpha column and row will have no effect.

<p>Icons that have the NO_CLIENT_COLOR value in appearance_flags will not be
subject to client.color.  This can be useful for HUD objects.

<p>This value can be animated.

<h3>Example:</h3>
<xmp>
mob/proc/DayNight(is_day)
    if(client)
        client.color = is_day ? \
            null : \
            list(0.2,0.05,0.05, 0.1,0.3,0.2, 0.1,0.1,0.4)
</xmp>

<hr>

<a name=/client/var/command_text>
<h2>command_text (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/verb/arguments>arguments (verb)</a>
<dd><a href=skinparams.html target=_blank>Skin reference</a>
<dd><a href=#/client/var/script/macro>macros (client script)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>null
</dl>

<p>This text is placed onto the command line, to be followed by whatever the
user may type.  It is usually the name of a verb followed by a space, such
as "say ".  The user can clear this and enter a different command by hitting
backspace, escape, delete, or '/'.

<p>(<b>Note:</b> In BYOND 4.0 this var is deprecated. The <tt>command</tt>
parameter for an Input control can be set to <tt>!command</tt> which does the
same thing. See the <a href=skinparams.html target=_blank>skin reference</a>
for details.)</p>

<h3>Example:</h3>
<xmp>
client
   command_text = "say "

   verb/say(T as text)
      world << "[usr] says, '[T]'"
</xmp>

<p>It is also possible to turn on macro mode, in which each keypress
executes a <a href=#/client/var/script/macro>keyboard macro</a>, by setting
<code>command_text</code> to ".alt ".  That stands for the <i>Alt</i> key,
which can be used to execute macros in normal mode.

<p>This variable could also be used to create a specialized command prompt.
For example, a traditional style MUD command-line could be implemented like
this:

<h3>Example:</h3>
<xmp>
client
   command_text = "> "
   verb/command(C as command_text)
      set name = ">"
      usr << "Your command: [C]"
</xmp>

<p>This example uses the <tt>command_text</tt> input type, which accepts raw
text, with no quoting, escaping, or translating, so that you can invent
whatever syntax you want.

<hr>

<a name=/client/var/computer_id>
<h2>computer_id var (client)</h2>

<dl><dt><b>Default value:</b>
<dd>A unique numerical identifier for the player's computer. The value is in text form.
</dl>

<p>This is a read-only text value which contains a unique numerical identifier for the player's computer. 
Its primary purpose is to detect if players are connecting to a server with multiple
accounts on the same machine, while still allowing for multiple accounts on the same network (eg, 
through a router).

<hr>

<a name=/client/var/connection>
<h2>connection</h2>

<p>This is a read-only var describing the type of client that is connected.

<dl><dt><b>Possible values:</b></dt>
<dd>"seeker" - The player is connected through Dream Seeker</dd>
<dd>"telnet" - The player is connected through telnet</dd>
<dd>"world" - The client is actually a world.Export() connection from another server</dd>
<dd>"cgi" - The client is connected via CGI (irrelevant to most worlds)</dd>
<dd>"web" - The client is connected via the Web client</dd>
<dd>"http" - The client is an HTTP connection (used by the Web client's virtual server)</dd>
</dl>

<p>Other values may be supported in the future.

<p>An empty value means the connection type is unknown because a full handshake hasn't been completed yet.

<hr>

<a name=/client/var/control_freak>
<h2>control_freak (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=skinparams.html target=_blank>Skin reference</a>
<dd><a href=#/client/var/script/macro>macros (client script)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>This var lets you set flags to turn off options that are normally present
for the end user. You can combine these flags with the | operator. The value
1 is equivalent to CONTROL_FREAK_ALL and will disable everything.

<dl>
<dt>CONTROL_FREAK_ALL</dt>
<dd>If this value is used, it affects all the options below.
<ul>
  <li>User-defined macros may not be used.</li>
  <li>Only the world's skin or the default BYOND skin will be loaded, not a user-customized version.</li>
  <li>The Options &amp; Messages window in Dream Seeker is inaccessible. It will only come up while first connecting to a remotely hosted world, or if a world takes a long time to load. The .options command will not make it appear.</li>
  <li>The menu items from Options &amp; Messages are unavailable in Dream Seeker's system menu.</li>
  <li>The default F2 macro for the .screenshot command is turned off. The command is then only accessible through the skin you create.</li>
</ul></dd>

<dt>CONTROL_FREAK_SKIN</dt>
<dd>Toggles the ability to create a custom version of the skin.</dd>

<dt>CONTROL_FREAK_MACROS</dt>
<dd>Toggles the ability to use and define custom macros.</dd>
</dl>

<p>Using CONTROL_FREAK_ALL will default to disabling everything, and the other
flags will reenable only the features you want. For example, CONTROL_FREAK_MACROS
alone will disable the ability to use your own macros but nothing else.
CONTROL_FREAK_ALL | CONTROL_FREAK_MACROS will disable everything <i>except</i>
macros.

<p>This value can be changed at runtime. However any changes made at runtime
will not affect users running old BYOND versions. Users whose versions only
recognize "all enabled" or "all disabled" will have everything disabled if you
use any value other than 0.

<p><b>Important:</b> If you define your own skin for the world, and disable the
ability to use a custom skin or user-defined macros, you must be sure to define
any macros your world may need. For instance, arrow keys may be needed for
movement.

<hr>

<a name=/client/var/default_verb_category>
<h2>default_verb_category var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/verb/set/category>category setting (verb)</a>
<dd><a href=#/client/var/show_verb_panel>show_verb_panel var (client)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>"Commands"
</dl>

<p>All verbs with category "" (the default value) are treated as though they
had this category setting instead.  In other words, this is the name of the
panel that contains them.  You could even turn that panel off by setting this
value to null.

<hr>

<a name=/client/var/dir>
<h2>dir var (client)</h2>

<dl><dt><b>Default value:</b>
<dd>NORTH
</dl>

<p>This defines the relationship between the world's coordinate system and the
player's screen.  The default means that the player sees the map exactly as it
was created (in the map-editor or at runtime).  Changing it to one of the
other directions causes the player to see the map as if it were rotated to
that direction.  This means that a player with client.dir = SOUTH would see
the map inverted relative to a person with client.dir = NORTH.  That's handy
in two-player board games where you want both players to see their side in the
same place.

<p>Note that this does not turn icons upside down!  The map is rotated, but
the icons on the map remain in their normal orientation.

<p>Movement keys are remapped so that a player with client.dir = SOUTH hitting
the up arrow will generate a call to client.South() rather than the usual
client.North().


<hr>

<a name=/client/var/edge_limit>
<h2>edge_limit var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/var/eye>eye var (client)</a>
<dd><a href=#/client/var/lazy_eye>lazy_eye var (client)</a>
<dd><a href=#/client/var/perspective>perspective var (client)</a>
<dd><a href=#/client/var/view>view var (client)</a>
<dd><a href=#/atom/movable/var/screen_loc>screen_loc var (movable atoms)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>null
</dl>

<p>This value determines the limits that a client's eye will display.
If <code>client.perspective</code> uses the <code>EDGE_PERSPECTIVE</code> flag,
the view shouldn't scroll beyond the bounds set by <code>edge_limit</code>. If
the bounds of <code>edge_limit</code> are as big as or smaller than the
client's view, no scrolling will occur even if <code>EDGE_PERSPECTIVE</code>
is not used. Normally this value is null, which provides freedom for the eye
to move anywhere on the map. It may be changed to a text value describing the
limits in more detail.

<p>The format is similar to <code>atom.screen_loc</code> which uses
<code>"[x1],[y1]&nbsp;to&nbsp;[x2],[y2]"</code>. It can also use directions
such as <code>"SOUTHWEST&nbsp;to&nbsp;NORTHEAST"</code>, which refer to the
limits of the map.

<h3>Example:</h3>
<xmp>
area/house
  var/x1,x2,y1,y2

  Entered(mob/M)
    if(ismob(M) && M.client)
      M.client.edge_limit = "[x1],[y1] to [x2],[y2]"

  Exited(mob/M)
    if(ismob(M) && M.client)
      M.client.edge_limit = null
</xmp>

<hr>

<a name=/client/var/eye>
<h2>eye var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/var/edge_limit>edge_limit var (client)</a>
<dd><a href=#/client/var/lazy_eye>lazy_eye var (client)</a>
<dd><a href=#/client/var/mob>mob var (client)</a>
<dd><a href=#/client/var/perspective>perspective var (client)</a>
<dd><a href=#/client/var/glide_size>glide_size var (client)</a>
<dd><a href=#/client/var/view>view var (client)</a>
<dd><a href=#/client/var/virtual_eye>virtual_eye var (client)</a>
<dd><a href=#/world/var/view>view var (world)</a>
<dd><a href=#/atom/movable/var/step_x>step_x var (movable atom)</a>
<dd><a href=#/atom/movable/var/step_y>step_y var (movable atom)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>The connected mob, client.mob.
</dl>

<p>This value determines the center of the player's map.  The default value
simply means that the visible region is normally centered on the player's mob.
Effects such as setting <code>perspective</code> to
<code>EDGE_PERSPECTIVE</code> or using <code>lazy_eye</code> can move the map
off-center temporarily. The eye is the <i>ideal</i> center, not
necessarily the actual center; to find the actual center, use
<code>virtual_eye</code>.

<p>The eye's step_x/y vars, if present, are also used to allow smooth
scrolling of the map. These also obey lazy_eye and edge_limit.

<p>Note that the visibility of objects is still computed from the point of
view of the mob rather than the eye.  This allows the use of
<code>lazy_eye</code> or similar effects that control the panning of the map
while still having the player see only what the mob can see.  To determine
visibility from the eye, you can change the value of
<code>client.perspective</code>.

<p>If a player connects to a new mob M, client.eye automatically changes to M.

<h3>Example:</h3>
<xmp>
client
  eye = locate(5,5,1)
</xmp>

<p>This fixes the center of the player's map at the turf coordinate (5,5,1).
Since the eye is fixed, the map will not scroll even as the player's mob
moves out of the visible range.

<hr>

<a name=/client/var/fps>
<h2>fps var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/fps>fps var (world)</a>
<dd><a href=#/client/var/tick_lag>tick_lag var (client)</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0 (uses world.fps value)
</dl>

<p>This is a client version of world.fps, so that the client can run at a
faster speed for animations.  For example, setting client.fps to 40 while
world.fps is the default 10 will mean that all animations and glides are
smoothed out and displayed at 40 FPS, even though the server still runs at
10 FPS.  The result is a nicer-looking game with no additional impact on the
server.

<p>When this value is 0, the client and server tick at the same rate.

<hr>

<a name=/client/var/gender>
<h2>gender var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/New>New proc (client)</a>
<dd><a href=#/atom/var/gender>gender var (atom)</a>
<dd><a href=#/client/var/key>key var (client)</a>
<dd><a href=#/DM/text/macros>macros (text)</a>
</dl>

<p>This is the client's gender, which is an attribute of the player's key.
By default, when a new mob is made for a player (in client.New()), the new
mob gets the same name and gender as the player's key.  This influences text
macros like <code>\he</code>, which may expand to "it", "he", "she", or
"they".  Valid values are:

<xmp>
"neuter"
"male"
"female"
"plural"
</xmp>

<hr>

<a name=/client/var/glide_size>
<h2>glide_size var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/var/eye>eye var (client)</a>
<dd><a href=#/atom/movable/var/glide_size>glide_size var (movable atoms)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p><b>Deprecated.</b> This setting has no impact when used with pixel
movement. See <a href=#/{notes}/gliding>Gliding</a> for more details.

<p>This controls the number of pixels the map is moved in each step during
scrolling of the map.  The default value of 0 chooses automated control over
this value, which generally results in a minimum step of 4 pixels that is
increased when necessary to keep up with motion of the map.

<p>Be careful about using small step sizes.  Icons with high contrast
pixel-level detail can look pretty ugly when displaced by short distances.

<p>This was renamed from pixel_step_size.

<hr>

<a name=/client/var/images>
<h2>images var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/image>image objects</a>
<dd><a href=#/proc/image>image proc</a>
</dl>

<p>This is a list of images that are displayed to the user.  The output
operator is one way to add entries to this list.  Deleting an image object
will automatically remove it from the display, but if you want to retain an
image (so other people can still see it), it can be removed by directly
modifying this list.

<h3>Example:</h3>

<xmp>
var/image/I = new('image.dmi',usr)
usr.client.images += I  //display it
sleep(50)
usr.client.images -= I  //remove it from the display
</xmp>

Displaying the image can also be achieved like this:

<xmp>
usr << I
</xmp>

<hr>

<a name=/client/var/inactivity>
<h2>inactivity var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/tick_lag>tick_lag var (world)</a>
</dl>

<p>This is equal to the amount of time (in server ticks, which default to
1/10s) since the player's last action (such as executing a verb, moving,
clicking an object, or selecting a topic link).  This value is reset to 0
after each new action so you can use it to determine the time that has passed
since the last one.

<h3>Example:</h3>
<xmp>
mob/verb/inactivity()
  usr << "You have been inactive for [client.inactivity/10] seconds."
</xmp>

<hr>

<a name=/client/var/key>
<h2>key var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/mob/var/key>key var (mob)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>The player's key identity.
</dl>

<p>This is a read-only value that contains the player's key.  Once the
player is attached to a mob M, M.key == M.client.key.

<hr>

<a name=/client/var/lazy_eye>
<h2>lazy_eye var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/var/view>view var (client)</a>
<dd><a href=#/world/var/view>view var (world)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>This is the maximum "lag" between client.eye and client.mob.  The mob can
stray up to this many tiles before the eye will move to keep it in view.  The
default value of 0 means that the eye always moves as the mob moves, keeping
the mob at the center of the player's map.

<p>Setting this value to a non-zero value automatically initializes client.eye
to client.mob.loc (or to the center of the full map if that is possible).
Thereafter, client.eye will stray from the mob as it moves about the map,
making one big jump to catch up whenever the mob gets out of range.

<h3>Example:</h3>
<xmp>
client
  lazy_eye = 5
</xmp>

<p>This setting allows client.mob to move onto the entire 11x11 visible
region without changing the value of client.eye.  The moment it steps out of
this region, the entire region will shift 5 tiles in the direction of motion.

<p>You can assign lazy_eye to any value valid as a view size, so, for example,
if you have a non-square setting for client.view, say, "17x11", you could
apply a similar setting to lazy_eye.  You can even make one dimension lazy and
the other one strictly centered: "0x5".

<hr>

<a name=/client/var/mob>
<h2>mob var (client)</h2>

<dl><dt><b>Default value:</b>
<dd>Determined in client.New(), by default world.mob.
</dl>

<p>This is the mob to which the client is connected.  The client and its
connected mob have the following symmetry:

<xmp>
client == mob.client
client.mob == mob
client.key == mob.key
</xmp>

<hr>

<a name=/client/var/mouse_pointer_icon>
<h2>mouse_pointer_icon var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Click>Click proc (client)</a>
<dd><a href=#/client/proc/MouseDown>MouseDown proc (client)</a>
<dd><a href=#/client/proc/MouseDrag>MouseDrag proc (client)</a>
<dd><a href=#/client/proc/MouseDrag>MouseDrag proc (client)</a>
<dd><a href=#/client/proc/MouseUp>MouseUp proc (client)</a>
<dd><a href=#/atom/var/mouse_drag_pointer>mouse_drag_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_drag_pointer>mouse_drag_pointer var (atom)</a>
<dd><a href=#/atom/var/mouse_drop_zone>mouse_drop_zone var (atom)</a>
<dd><a href=#/atom/var/mouse_over_pointer>mouse_over_pointer var (atom)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>null
</dl>

<p>This is an icon file (.dmi) containing custom mouse cursors to use in place
of the standard ones.  The different possible mouse states are distinguished
by special icon state names:

<dl>
<dt>""
<dd>Activated when over empty space or an object with mouse_over_pointer = MOUSE_INACTIVE_POINTER.
<dt>"over"
<dd>Activated when over an object with mouse_over_pointer = MOUSE_ACTIVE_POINTER.
<dt>"drag"
<dd>Activated when dragging an object with mouse_drag_pointer = MOUSE_ACTIVE_POINTER.
<dt>"drop"
<dd>Activated when dragging an object over with mouse_drop_pointer = MOUSE_ACTIVE_POINTER and the object underneath has mouse_drop_zone set.
<dt>"all"
<dd>Always activated, no matter what the state of the mouse.
</dl>

<hr>

<a name=/client/var/perspective>
<h2>perspective var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/var/eye>eye var (client)</a>
<dd><a href=#/client/var/mob>mob var (client)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>MOB_PERSPECTIVE
</dl>

<dl><dt><b>Possible values:</b>
<dd><ul>
<li>MOB_PERSPECTIVE
<li>EYE_PERSPECTIVE
<li>EDGE_PERSPECTIVE
</ul>
</dl>

<p>This controls the eye's apparent center and what can be seen by the client.

<p>EYE_PERSPECTIVE determines how visibility calculations are performed when
<code>client.eye</code> and <code>client.mob</code> are different.  Normally,
visibility is done from the position of the mob, rather than from the eye
(which is actually just the center of the map view). The alternative flag is
MOB_PERSPECTIVE, the default.

<p>EDGE_PERSPECTIVE limits scrolling to the bounds of the map (1,1 to
world.maxx,world.maxy), and does not keep the mob centered if it strays near
the edge.

<p>The above values can be used together via the | operator.

<hr>

<a name=/client/var/pixel_x>
<h2>pixel_x var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/var/glide_size>glide_size var (client)</a>
<dd><a href=#/client/var/pixel_y>pixel_y var (client)</a>
<dd><a href=#/client/var/pixel_w>pixel_w var (client)</a>
<dd><a href=#/client/var/pixel_z>pixel_z var (client)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>This displaces the player's viewpoint on the x-axis by the specified number of
pixels.  Can be animated with the animate() proc.

<hr>

<a name=/client/var/pixel_y>
<h2>pixel_y var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/var/glide_size>glide_size var (client)</a>
<dd><a href=#/client/var/pixel_x>pixel_x var (client)</a>
<dd><a href=#/client/var/pixel_w>pixel_w var (client)</a>
<dd><a href=#/client/var/pixel_z>pixel_z var (client)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>This displaces the player's viewpoint on the y-axis by the specified number of
pixels.  Can be animated with the animate() proc.

<hr>

<a name=/client/var/pixel_w>
<h2>pixel_w var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/var/glide_size>glide_size var (client)</a>
<dd><a href=#/client/var/pixel_x>pixel_x var (client)</a>
<dd><a href=#/client/var/pixel_y>pixel_y var (client)</a>
<dd><a href=#/client/var/pixel_z>pixel_z var (client)</a>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>This displaces the player's viewpoint horizontally by the specified number
of pixels. This value is meant to be used when world.map_format is not set to
a default top-down view.  Can be animated with the animate() proc.

<hr>

<a name=/client/var/pixel_z>
<h2>pixel_z var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/var/glide_size>glide_size var (client)</a>
<dd><a href=#/client/var/pixel_x>pixel_x var (client)</a>
<dd><a href=#/client/var/pixel_y>pixel_y var (client)</a>
<dd><a href=#/client/var/pixel_w>pixel_w var (client)</a>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>This displaces the player's viewpoint vertically by the specified number of
pixels. This value is meant to be used when world.map_format is not set to a
default top-down view.  Can be animated with the animate() proc.

<hr>

<a name=/client/var/pixel_step_size>
<h2>pixel_step_size var (client)</h2>

<p>Renamed to <a href=#/atom/movable/var/glide_size>glide_size</a>.

<hr>

<a name=/client/var/preload_rsc>
<h2>preload_rsc var (client)</h2>

<dl><dt><b>Default value:</b>
<dd>1.
</dl>

<p>This variable controls whether resource files (icons and sounds) are
automatically downloaded by Dream Seeker when first connecting, or whether
they should be downloaded as needed.  Resource files are cached (in
byond.rsc) for future use, so this should only affect people who have not
played the game before or who have not played it for some time.

<p>The three possible settings are:
<dl compact>
<dt>0<dd>do not preload any resources
<dt>1<dd>preload compiled-in resources only
<dt>2<dd>preload all resources including those uploaded by players
<dt>URL<dd>preload resources from specified file
</dl>

<p>Preloading resource files will eliminate delays later on, but may cause
a very long initial delay when logging in.

<p>Resources may also be distributed from a website to save bandwidth on the
machine hosting the game.  Simply zip up the .rsc file, upload it to a web
site, and put the URL here.

<h3>Example:</h3>
<xmp>
client/preload_rsc = "http://dan.byond.com/mygame_rsc.zip"
</xmp>

<p>Instead of putting the .rsc file in the .zip, you can also put the
individual resource files there.  This would allow you to select specific
files that you would like to be preloaded.  For example, you could create a
different resource package for different parts of the game world and assign
client.preload_rsc dynamically as the player moves into each different area.

<p>Once Dream Seeker has downloaded a resource package, it caches it and will
not download it again, even if you upload a new version of the file.  This
allows you to make small changes without forcing a complete refresh.  Any
files which are not found in the preload package are simply downloaded from
the game server directly.

<p>If you want to force a complete refresh, simply change the name of the
resource package.  For example, you could put a version number in the name of
the file: <tt>mygame_rsc_01.zip</tt>, <tt>mygame_rsc_02.zip</tt>, and so on.

<hr>

<a name=/client/var/screen>
<h2>screen var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/{notes}/HUD>HUD / screen objects</a>
<dd><a href=#/atom/movable/var/screen_loc>screen_loc var (movable atoms)</a>
</dl>

<p>This is a list of objects that are displayed on the user's screen.  The
object's screen_loc variable controls where it appears (if it appears at all).
This allows one to create the elements of a graphical user interface, with
such features as buttons, drag/drop areas, and stat monitors.

<p>Screen objects (visible or otherwise) may also be used to make verbs
available to users.  To make them accessible, define verbs on the screen
object like this:

<xmp>
set src in usr.client.screen
</xmp>

<hr>

<a name=/client/var/script>
<h2>script var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/preprocessor/include>#include directive</a>
<dd><a href=#/client/var/script/PASSWORD_TRIGGER>PASSWORD_TRIGGER (client script)</a>
<dd><a href=#/client/var/script/URL>URL (client script)</a>
<dd><a href=#/client/var/script/alias>aliases (client script)</a>
<dd><a href=#/client/var/script/URL/browser>browser configuration</a>
<dd><a href=#/client/var/command_text>command_text (client)</a>
<dd><a href=#/client/var/script/macro>macros (client script)</a>
<dd><a href=#/DM/text/style>style sheets</a>
<dd><a href=#/client/var/script/style>style sheets (in scripts)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>none
</dl>

<p>Client scripts are mini-programs used to configure the client.  The
language they use is called DM Script, and will undoubtedly expand in the
future.  Currently, client scripts can be used to define style sheets,
command aliases, and macros.  When executed directly by a player, they can
also be used to specify an initial URL to open and a password trigger (for
some ancient telnet worlds that don't suppress password echo).

<p>For the specific syntax of DM Script, see the relevant reference sections
listed above.

<p>The <code>client.script</code> variable may be assigned to script code in
a text string (double quotes) or in a file (single quotes).  You can also
simply include the file in your project or explicitly use the
<code>#include</code> statement.  Files containing DM Script should have the
extension <code>.dms</code>.

<p><h3>Example:</h3>
<xmp>
client/script = "<STYLE>BODY {font: monospace}</STYLE>"
</xmp>

<p>This example selects a default monospace font for all output to the
terminal.

<p>In addition to scripts loaded via <code>client.script</code>, the player
may have <em>client-side</em> scripts.  These are either called
<em>connection</em> scripts or <em>post-connection</em> scripts depending on
whether they are used to automatically connect to a world or whether they
are executed automatically after connecting to a world.  In either case, the
player's scripts are always executed before the designer's
<code>client.script</code> script, so style sheets from the designer have
higher precedence by default.

<p>There are three post-connection client-side scripts for the three types
of worlds the client can connect to: <code>byond.dms</code>,
<code>telnet.dms</code>, and <code>irc.dms</code>.  These are automatically
executed if the player connects directly to a world without using a
connection script to do so.  The intention is to load any standard
configurations such as style sheets and command aliases.

<hr>

<a name=/client/var/script/PASSWORD_TRIGGER>
<h2>PASSWORD_TRIGGER (client script)</h2>

<dl><dt><b>Format:</b>
<dd>#define PASSWORD_TRIGGER "assword:"
</dl>

<p>This defines a special text <em>trigger</em> used to detect when the user
is being prompted for a password in telnet mode.  Most MUDs automatically
suppress password echo, but if they do not, it is necessary to use this
setting to hide it.  Multiple triggers may be defined as necessary.

<p>The example above is more robust than the more polite version because it
works whether they capitalize the 'P' or not...

<hr>

<a name=/client/var/script/URL>
<h2>URL (client script)</h2>

<dl><dt><b>Format:</b>
<dd>#define URL "byond://byond.com:6000"
</dl>

<p>Defining a URL in a script, specifies the world to connect to when the
script is executed by the player.  This is referred to as a connection
script, because the player uses it to connect to a world.  Other
post-connection scripts such as <code>byond.dms</code> or a script loaded
through <code>client.script</code> are only used to configure the client
after it has connected to a world.  In those cases, the URL setting has no
effect.

<p>It is important to enclose the URL in double quotes.  Otherwise, the
<code>//</code> symbol would be mistaken for a comment.

<hr>

<a name=/client/var/script/URL/browser>
<h2>browser configuration</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/var/script/URL>URL (client script)</a>
</dl>

<p>DM Script can be used to effectively make a hyperlink in a web document
to a BYOND world.  This is done by making a DM Script file that defines the
desired URL.  It need do nothing more than that.  When a user clicks on the
link in a web browser, DreamSeeker will pop up, execute the script, and
connect to the specified URL.

<p>Some browsers may need to be configured to know what to do with a DM
Script file.  For example, in Netscape, you can add an entry to the list of
helper applications.  You should add a MIME type called
'<code>application/x-dms</code>' with the description 'DM Script' and the
extension <code>dms</code>.  Have this execute DreamSeeker with the
<code>.dms</code> file as an argument.

<h3>Example:</h3>

<h3>myworld.dms</h3>
<xmp>
/*If your browser shows you this, you either need
  to install BYOND (it's free!) from www.byond.com,
  or you need to configure your browser to execute
  DreamSeeker with DM Script (.dms) files.
*/
#define URL "byond://myworld"
</xmp>

<h3>myworld.html</h3>
<xmp>
<html>

<head><title>
Welcome to My World
</title></head>

<body>

<p>You can connect to my world
<a href=myworld.dms>here</a>.

</body>
</html>
</xmp>

<hr>

<a name=/client/var/script/alias>
<h2>aliases (client script)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/var/script/macro>macros (client script)</a>
<dd><a href=#/client/var/script>script var (client)</a>
<dd><a href=#/verb>verbs</a>
</dl>

<p>Command aliases have a syntax similar to verbs.  They define a command
and a series of arguments which can then be used to execute a new command.
The most common use for this is in a telnet world like a MUD.  By defining
aliases corresponding to the MUD commands, the player can have primitive
command expansion and help.

<p>The syntax of an alias definition is best illustrated by the following
example:

<xmp>
alias/say(msg as text)
   set desc = "speak your mind"
   return "say [msg]"
</xmp>

<p>As you can see, it is just like a verb.  Alias have all the same
properties as verbs, except the <code>src</code> setting is always equal to
the player.

<p>The value returned by an alias is executed as a command.  In telnet mode,
the command to execute is often simply the same as the command that was
entered (since the alias was only defined to provide command expansion and
help).  Since that is such a common case, the return value defaults to the
alias name followed by each of the arguments.  The example above, for
instance, would have the same effect without an explicit return statement.

<p>Note that commands executed via an alias are never interpreted as
aliases.  Otherwise, examples such as the one above would result in an
infinite loop.

<hr>

<a name=/client/var/script/macro>
<h2>macros (client script)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/var/script/alias>aliases (client script)</a>
<dd><a href=#/client/var/command_text>command_text (client)</a>
<dd><a href=#/client/var/script>script var (client)</a>
<dd><a href=#/verb>verbs</a>
</dl>

<p>Macros are just like aliases, except that they are triggered by a single
key (or combination of keys) instead of a full command.  When a macro is
executed, it returns a text string which is then executed as a command.  So
a macro is just a short-cut for entering a command.

<p>The following example illustrates the syntax for entering a typical set
of macros.

<h3>Example;</h3>
<xmp>
macro
   ALT+I return "inventory"
   ALT+SHIFT+I return "inventory\nequipment" //multiple commands
   ALT+s return "say \..."             //command to be edited
</xmp>

<p><b>Compatibility note:</b> In old versions of BYOND, character keys
required the Alt key to be pressed to trigger the macro, and did not include
"ALT+" to do so. This behavior has changed, and the name of the macro is just
like the format used in skin files. You use a key name, and modifiers like
SHIFT+, CTRL+, ALT+, +REP, and +UP. Old .dms and client_script files (prior
to version 507) should be updated accordingly when recompiling in a newer
version.

<hr>

<a name=/client/var/script/style>
<h2>style sheets (in scripts)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/var/script>script var (client)</a>
<dd><a href=#/DM/text/style>style sheets</a>
</dl>

<p>Style sheets may be included in DM Script by putting the style sheet
inside the HTML tags <code>&lt;STYLE&gt;</code> and
<code>&lt;/STYLE&gt;</code>.  In general, any text enclosed in start
and end tags will be sent to the player's terminal, so you could use
<code>client.script</code> to output a welcome message as well as loading a
style sheet.

<p><h3>Example:</h3>
<xmp>
client/script = "<STYLE>BODY {background: black; color: aqua}</STYLE>"
</xmp>

<p>This example style sheet makes the player's terminal have a black
background and aqua colored text.  When changing the background color, it is
important to change the color of system and link text as well.  See the
section on <a href=#/DM/text/style>style sheets</a> for an example.

<hr>

<a name=/client/var/show_map>
<h2>show_map var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/var/show_verb_panel>show_verb_panel var (client)</a>
<dd><a href=#/client/var/view>view var (client)</a>
<dd><a href=#/world/var/view>view var (world)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>1
</dl>

<p>This variable may be used to turn off the view of the map in Dream Seeker.
This could be useful for making text MUDs where the rooms are turfs (ie most
rooms can be laid out on a grid but you don't want the user interface to show
the map in any way).

<p>The following example shows one useful combination of settings.  Note that
setting <code>world.view=-1</code> also disables the map, but it also sets
the default value of the <code>view()</code> depth in such a way as to always
return an empty list.

<h3>Example:</h3>
<xmp>
client
   show_map = 0 //Text is best!
world
   view = 0     //You can interact only with objects in same turf.
mob
   density = 0  //Allow multiple mobs in a room.
</xmp>

<hr>

<a name=/client/var/show_popup_menus>
<h2>show_popup_menus var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Click>Click proc (client)</a>
<dd><a href=#/client/proc/DblClick>DblClick proc (client)</a>
<dd><a href=#/client/proc/MouseDown>MouseDown proc (client)</a>
<dd><a href=#/client/proc/MouseDrag>MouseDrag proc (client)</a>
<dd><a href=#/client/proc/MouseDrop>MouseDrop proc (client)</a>
<dd><a href=#/client/proc/MouseEntered>MouseEntered proc (client)</a>
<dd><a href=#/client/proc/MouseExited>MouseExited proc (client)</a>
<dd><a href=#/client/proc/MouseMove>MouseMove proc (client)</a>
<dd><a href=#/client/proc/MouseUp>MouseUp proc (client)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>1
</dl>

<p>This variable may be used to turn off the popup "context" menus that are displayed by default when
an object on the map or stat panels is right-clicked.  If client.show_popup_menus==0, then right-clicks
will instead be passed to the various mouse functions. 

<hr>

<a name=/client/var/show_verb_panel>
<h2>show_verb_panel var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/verb/set/category>category setting (verb)</a>
<dd><a href=#/client/var/default_verb_category>default_verb_category var (client)</a>
<dd><a href=#/client/var/show_map>show_map var (client)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>1
</dl>

<p>Setting this to 0 turns off the verb panel in Dream Seeker.  You might
want to do that, for instance, if you've only got one verb (like "say") and
the panel looks stupid with just one verb in it.

<h3>Example:</h3>
<xmp>
client
   show_verb_panel = 0
</xmp>

<hr>

<a name=/client/var/statobj>
<h2>statobj var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Stat>Stat proc (client)</a>
<dd><a href=#/proc/stat>stat proc</a>
<dd><a href=#/proc/statpanel>statpanel proc</a>
<dd><a href=#/client/var/statpanel>statpanel var (client)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>client.mob (the player's mob).
</dl>

<p>This value indicates which object the player currently has loaded in the
stat panels.

<hr>

<a name=/client/var/statpanel>
<h2>statpanel var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Stat>Stat proc (client)</a>
<dd><a href=#/proc/stat>stat proc</a>
<dd><a href=#/client/var/statobj>statobj var (client)</a>
<dd><a href=#/proc/statpanel>statpanel proc</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>null
</dl>

<p>This value indicates which stat panel is currently visible to the player.
You can assign it to force a different panel to become the top panel.  The
special value "verbs" activates the panel of commands.

<hr>

<a name=/client/var/tick_lag>
<h2>tick_lag var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/tick_lag>tick_lag var (world)</a>
<dd><a href=#/client/var/fps>fps var (client)</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0 (uses world.tick_lag value)
</dl>

<p>This is a client version of world.tick_lag, so that the client can run at
a faster speed for animations.  For example, setting client.fps to 0.25 while
world.fps is the default 1 will mean that all animations and glides are
smoothed out and displayed at 40 FPS, even though the server still runs at
10 FPS.  The result is a nicer-looking game with no additional impact on the
server.

<p>When this value is 0, the client and server tick at the same rate.

<hr>

<a name=/client/var/verbs>
<h2>verbs list var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/list>list</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>The list of verbs defined for the client.
</dl>

<p>This is a list of the client's verbs.  Initially, it contains all of the
verbs defined for the client.  It may be used to add and remove verbs at
runtime.

<hr>

<a name=/client/var/view>
<h2>view var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/var/lazy_eye>lazy_eye var (client)</a>
<dd><a href=#/client/var/show_map>show_map var (client)</a>
<dd><a href=#/proc/view>view proc</a>
<dd><a href=#/world/var/view>view var (world)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>world.view (which is 5 by default)
</dl>

<dl><dt><b>Possible values:</b>
<dd>-1 to 34 or "WIDTHxHEIGHT"
</dl>

<p>This controls the size of the map window in Dream Seeker.  Normally, you
would simply compile with world/view assigned to whatever you want, but in
some cases, you might want to customize the map size for different players,
such as admins or subscribed users.

<p>Like all other view sizes in DM, this may either be a <em>view depth</em>
or an absolute size.  A view depth is a single number that determines how far
from a center point the edges of a square viewable region extend.  A value of
5 creates edges which are 2*5+1 = 11 tiles long.

<p>The newer, more flexible syntax is a text string of the form
"WIDTHxHEIGHT".  For example, a view depth of 5 corresponds to "11x11".  Using
this syntax, you can create non-square views as well.

<p>The maximum view size is about 5000 tiles, or roughly 70x70.

<hr>

<a name=/client/var/virtual_eye>
<h2>virtual_eye var (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/var/edge_limit>edge_limit var (client)</a>
<dd><a href=#/client/var/eye>eye var (client)</a>
<dd><a href=#/client/var/lazy_eye>lazy_eye var (client)</a>
<dd><a href=#/client/var/mob>mob var (client)</a>
<dd><a href=#/client/var/perspective>perspective var (client)</a>
<dd><a href=#/client/var/view>view var (client)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>client.eye
</dl>

<p>This value determines the actual center of the player's map display. It is
based on <code>client.eye</code> and whenever possible matches it; however it
may instead be a turf, or null, when the eye is off-center.

<p>The value of <code>virtual_eye</code> is read-only.

<hr>

<a name=/database>
<h2>database datum</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/database/query>database query datum</a>
<dd><a href=#/database/proc>procs (database)</a>
</dl>

<p>A /database datum gives you the ability to create or access a database
using SQLite, which allows you to run complex database queries on any
platform.

<p>Creating a /database/query datum will let you put together a query, and
once it's ready you can call its Execute() proc to run it.

<p>SQLite databases in BYOND support numerical values (such as INTEGER or
FLOAT), text (TEXT), and cache files such as icons (BLOB). Null values are
also allowed.

<h3>Example:</h3>
<xmp>
var/database/db = new("mydb.db")
var/database/query/q = new("SELECT * FROM my_table WHERE name=?", usr.key)

if(q.Execute(db) && q.NextRow())
    // returns a list such as list(name="MyName", score=123)
    return q.GetRowData()
// no data found
return null
</xmp>

<hr>

<a name=/database/proc>
<h2>procs (database)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/database>database datum</a>
<dd><a href=#/database/query>database query datum</a>
<dd><a href=#/database/query/proc>procs (database query)</a>
</dl>

<p>Built-in database procs:

<dl><dt>database/proc
<dd><a href=#/database/proc/Close>Close</a>
<dd><a href=#/database/proc/Error>Error</a>
<dd><a href=#/database/proc/ErrorMsg>ErrorMsg</a>
<dd><a href=#/database/proc/New>New</a>
<dd><a href=#/database/proc/Open>Open</a>
</dl>

<hr>

<a name=/database/proc/Close>
<h2>Close proc (database)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/database>database datum</a>
<dd><a href=#/database/proc/Open>Open proc (database)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Close()
</dl>

<p>If a database is currently open, this will close the database and any
queries currently running in it. Usually you don't need to call this
directly, because deleting the datum will do it for you.

<hr>

<a name=/database/proc/Error>
<h2>Error proc (database)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/database>database datum</a>
<dd><a href=#/database/query>database query datum</a>
<dd><a href=#/database/proc/ErrorMsg>ErrorMsg proc (database)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Error()
</dl>

<p>Returns the error code last received by the database.

<hr>

<a name=/database/proc/ErrorMsg>
<h2>ErrorMsg proc (database)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/database>database datum</a>
<dd><a href=#/database/query>database query datum</a>
<dd><a href=#/database/proc/Error>Error proc (database)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>ErrorMsg()
</dl>

<p>Returns the error message last received by the database.

<hr>

<a name=/database/proc/Open>
<h2>Open proc (database)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/database>database datum</a>
<dd><a href=#/database/proc/Close>Close proc (database)</a>
<dd><a href=#/database/proc/New>New proc (database)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Open(filename)
</dl>

<dl><dt><b>Args:</b>
<dd>filename: The database filename to open
</dl>

<p>Opens a database file. If another database was already open, it is
closed automatically. It is more common to simply open the database in New().

<hr>

<a name=/database/proc/New>
<h2>New proc (database)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/database>database datum</a>
<dd><a href=#/database/proc/Open>Open proc (database)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>New(filename)
</dl>

<dl><dt><b>Args:</b>
<dd>filename: The database filename to open (optional)
</dl>

<p>Creates a new database datum, and opens the file if a filename is provided.

<hr>

<a name=/database/query>
<h2>database query datum</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/database>database datum</a>
<dd><a href=#/database/query/proc>procs (database query)</a>
</dl>

<p>This datum lets you create a query for a database, which can be run with
the Execute() proc. The datum can be reused after a query is run by calling
Clear() and adding new text with Add().

<hr>

<a name=/database/query/proc>
<h2>procs (database query)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/database>database datum</a>
<dd><a href=#/database/query>database query datum</a>
<dd><a href=#/database/proc>procs (database)</a>
</dl>

<p>Built-in database query procs:

<dl><dt>database/query/proc
<dd><a href=#/database/query/proc/Add>Add</a>
<dd><a href=#/database/query/proc/Clear>Clear</a>
<dd><a href=#/database/query/proc/Close>Close</a>
<dd><a href=#/database/query/proc/Columns>Columns</a>
<dd><a href=#/database/query/proc/Error>Error</a>
<dd><a href=#/database/query/proc/ErrorMsg>ErrorMsg</a>
<dd><a href=#/database/query/proc/Execute>Execute</a>
<dd><a href=#/database/query/proc/GetColumn>GetColumn</a>
<dd><a href=#/database/query/proc/GetRowData>GetRowData</a>
<dd><a href=#/database/query/proc/New>New</a>
<dd><a href=#/database/query/proc/NextRow>NextRow</a>
<dd><a href=#/database/query/proc/Reset>Reset</a>
<dd><a href=#/database/query/proc/RowsAffected>RowsAffected</a>
</dl>

<hr>

<a name=/database/query/proc/Add>
<h2>Add proc (database query)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/database/query>database query datum</a>
<dd><a href=#/database/query/proc/Clear>Clear proc (database query)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Add(text, item1, item2, ...)
</dl>

<dl><dt><b>Args:</b>
<dd>text: Text to add to the query
<dd>item1, item2, etc.: Items that will replace question marks in text
</dl>

<p>Adds text to a database query. If this datum was already used to run a
query, Clear() will be called automatically.

<p>If your text includes question marks, they will be replaced with the other
items listed in the proc arguments. If that item is a string, quotes will be
put around it for the query text. Files in the cache (such as icons) will be
added as BLOB values.

<p>After the query has been built, call Execute() to run it.

<h3>Example:</h3>
<xmp>
var/database/db = new("mydb.db")
var/database/query/q = new
q.Add("INSERT INTO quests (name, quest, complete) VALUES (?,?,?)", usr.key, quest_name, 1)
q.Execute(db)
</xmp>

<p>In the example above, the query text might look like this:

<p><tt>INSERT INTO quests (name, quest, complete) VALUES ('Tom','Save the Dog',1)</tt>

<hr>

<a name=/database/query/proc/Clear>
<h2>Clear proc (database query)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/database/query>database query datum</a>
<dd><a href=#/database/query/proc/Add>Add proc (database query)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Clear()
</dl>

<p>Clears the query text so you can begin creating a new query. This is
called automatically if you already called Execute() for the last query used
by this datum.

<hr>

<a name=/database/query/proc/Close>
<h2>Close proc (database query)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/database/query>database query datum</a>
<dd><a href=#/database/query/proc/Clear>Clear proc (database query)</a>
<dd><a href=#/database/query/proc/Reset>Reset proc (database query)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Close()
</dl>

<p>Ends a query that is in progress. This is usually done automatically and
shouldn't be necessary to call in most cases.

<hr>

<a name=/database/query/proc/Columns>
<h2>Columns proc (database query)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/database/query>database query datum</a>
<dd><a href=#/database/query/proc/Execute>Execute proc (database query)</a>
<dd><a href=#/database/query/proc/GetColumn>GetColumn proc (database query)</a>
<dd><a href=#/database/query/proc/GetRowData>GetRowData proc (database query)</a>
<dd><a href=#/database/query/proc/NextRow>NextRow proc (database query)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Columns()
<br/><i>or</i><br/>
Columns(column)
</dl>

<dl><dt><b>Args:</b>
<dd>column: The Nth column whose name should be read
</dl>

<p>Returns a list of column names for the current query, or the name of the
Nth column.

<p>You must call Execute() before calling Columns().

<hr>

<a name=/database/query/proc/Error>
<h2>Error proc (database query)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/database>database datum</a>
<dd><a href=#/database/query>database query datum</a>
<dd><a href=#/database/query/proc/ErrorMsg>ErrorMsg proc (database query)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Error()
</dl>

<p>Returns the error code last received for this query.

<hr>

<a name=/database/query/proc/ErrorMsg>
<h2>ErrorMsg proc (database query)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/database>database datum</a>
<dd><a href=#/database/query>database query datum</a>
<dd><a href=#/database/query/proc/Error>Error proc (database query)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>ErrorMsg()
</dl>

<p>Returns the error message last received for this query.

<hr>

<a name=/database/query/proc/Execute>
<h2>Execute proc (database query)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/database>database datum</a>
<dd><a href=#/database/query>database query datum</a>
<dd><a href=#/database/query/proc/Add>Add proc (database query)</a>
<dd><a href=#/database/query/proc/Close>Close proc (database query)</a>
<dd><a href=#/database/query/proc/GetColumn>GetColumn proc (database query)</a>
<dd><a href=#/database/query/proc/GetRowData>GetRowData proc (database query)</a>
<dd><a href=#/database/query/proc/NextRow>NextRow proc (database query)</a>
<dd><a href=#/database/query/proc/Reset>Reset proc (database query)</a>
<dd><a href=#/database/query/proc/RowsAffected>RowsAffected proc (database query)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Execute(database)
</dl>

<dl><dt><b>Args:</b>
<dd>database: A /database datum with the database to be queried, or the name of the database file
</dl>

<p>Runs a database query. Once the query is run, if the query is supposed
to returns any rows you can call NextRow() until finished, and then GetColumn() or
GetRowData() to get the information from each row. For queries that cause changes,
RowsAffected() is also a useful call.

<p>The database argument is optional after the first time you use it.

<p>You can use a filename instead of a /database datum, as a shortcut; the datum
will be created for you.

<p>After a query is executed, calling Add() to create new query text will
clear out the old query text automatically.

<h3>Example:</h3>
<xmp>
var/database/db = new("mydb.db")
var/database/query/q = new("SELECT quest,complete FROM quests WHERE name=?", usr.key)

if(!q.Execute(db)) return null

var/list/completed_quests = new
while(q.NextRow())
    var/row = q.GetRowData()
    if(row["complete"]) completed_quests[row["quest"]] = 1
return completed_quests
</xmp>


<hr>

<a name=/database/query/proc/GetColumn>
<h2>GetColumn proc (database query)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/database>database datum</a>
<dd><a href=#/database/query>database query datum</a>
<dd><a href=#/database/query/proc/Columns>Columns proc (database query)</a>
<dd><a href=#/database/query/proc/Execute>Execute proc (database query)</a>
<dd><a href=#/database/query/proc/GetRowData>GetRowData proc (database query)</a>
<dd><a href=#/database/query/proc/NextRow>NextRow proc (database query)</a>
<dd><a href=#/database/query/proc/Reset>Reset proc (database query)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>GetColumn(column)
</dl>

<dl><dt><b>Args:</b>
<dd>column: The column number whose value should be retrieved
</dl>

<p>Gets the value from the Nth column in this row of results. If you haven't
already called Execute() and NextRow(), you should do that first.

<p>To get the name of the column, not the value for this row, call
Columns(column) instead.

<p>The value returned depends on what type the database table thinks it is.
For instance if you defined a column as INTEGER or FLOAT, the value should
be a number. TEXT is still text, and null values are returned as null. If an
icon was saved into a BLOB field, the result is an icon file.

<hr>

<a name=/database/query/proc/GetRowData>
<h2>GetRowData proc (database query)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/database>database datum</a>
<dd><a href=#/database/query>database query datum</a>
<dd><a href=#/database/query/proc/Columns>Columns proc (database query)</a>
<dd><a href=#/database/query/proc/Execute>Execute proc (database query)</a>
<dd><a href=#/database/query/proc/GetColumn>GetColumn proc (database query)</a>
<dd><a href=#/database/query/proc/NextRow>NextRow proc (database query)</a>
<dd><a href=#/database/query/proc/Reset>Reset proc (database query)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>GetRowData()
</dl>

<p>Returns a list with the current result row for this query. If you
haven't already called Execute() and NextRow(), you should do that
first.

<p>The list returned is an associative list with name=value pairs. A
typical result might look like this:

<p><tt>list("name" = "Tom", "quest" = "Save a Dog", complete = 1)</tt>

<p>The values returned depend on what type the database table thinks they
are. For instance if you defined a column as INTEGER or FLOAT, the value
should be a number. TEXT is still text, and null values are returned as null.
If an icon was saved into a BLOB field, the result is an icon file.

<hr>

<a name=/database/query/proc/New>
<h2>New proc (database query)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/database>database datum</a>
<dd><a href=#/database/query>database query datum</a>
<dd><a href=#/database/query/proc/Add>Add proc (database query)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>New(text, item1, item2, ...)
</dl>

<dl><dt><b>Args:</b>
<dd>text: Text to add to the query
<dd>item1, item2, etc.: Items that will replace question marks in text
</dl>

<p>Creates a new query and adds text by automatically calling Add(). See
the <a href=#/database/query/proc/Add>Add proc</a> for more information.

<p>Call Execute() to run the query.

<hr>

<a name=/database/query/proc/NextRow>
<h2>NextRow proc (database query)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/database>database datum</a>
<dd><a href=#/database/query>database query datum</a>
<dd><a href=#/database/query/proc/Execute>Execute proc (database query)</a>
<dd><a href=#/database/query/proc/GetColumn>GetColumn proc (database query)</a>
<dd><a href=#/database/query/proc/GetRowData>GetRowData proc (database query)</a>
<dd><a href=#/database/query/proc/Reset>Reset proc (database query)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>NextRow()
</dl>

<p>If there are result rows in this query (Execute() must be called to run
the query first), NextRow() will retrieve the next row and return 1 if it
found a row, or 0 if the results are all finished. NextRow() is typically
called in a while() loop.

<p>After calling NextRow(), you can call GetColumn() or GetRowData() to get
information about the results in this row.

<p>Call Reset() if you want to rewind the query to the beginning.

<hr>

<a name=/database/query/proc/Reset>
<h2>Reset proc (database query)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/database>database datum</a>
<dd><a href=#/database/query>database query datum</a>
<dd><a href=#/database/query/proc/Execute>Execute proc (database query)</a>
<dd><a href=#/database/query/proc/NextRow>NextRow proc (database query)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Reset()
</dl>

<p>If a query returns any rows of results, Reset() will go back to the
beginning just after Execute() was called. This is useful if you have
called NextRow() repeatedly to retrieve a number of rows, but need to
go back to the start of the query for some other reason. This can also be
used to count the total number of result rows if needed, but for best
performance that isn't recommended.

<hr>

<a name=/database/query/proc/RowsAffected>
<h2>RowsAffected proc (database query)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/database>database datum</a>
<dd><a href=#/database/query>database query datum</a>
<dd><a href=#/database/query/proc/Execute>Execute proc (database query)</a>
<dd><a href=#/database/query/proc/RowsAffected>RowsAffected proc (database query)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>RowsAffected()
</dl>

<p>After running Execute() on a query that changes rows in the database (for
instance, an UPDATE query), this proc returns the number of rows that were
changed. This can be useful if you need to know whether a query actually did
anything.

<hr>

<a name=/datum>
<h2>datum</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom>atom</a>
<dd><a href=#/datum/proc>procs (datum)</a>
<dd><a href=#/datum/var>vars (datum)</a>
</dl>

<p>The datum object is the ancestor of all other data types in DM.  (The
only exceptions are currently /world, /client, /list, and /savefile, but
those will be brought into conformance soon.)  That means that the variables
and procedures of /datum are inherited by all other types of objects.

<p>When you define a new "top level" object, if you do not specify a
parent_type, it defaults to /datum.

<h3>Example:</h3>

<xmp>
datum
   //definitions to be shared by all object types
   proc/DebugMe()
      world.log << "/datum properties:"
      world.log << "type: [type]"
      world.log << "parent_type: [parent_type]"
      return ..()

MyType
   var
      myvar = "test"
   DebugMe()
      world.log << "/MyType properties:"
      world.log << "myvar: [myvar]"
      return ..() //this calls /datum/proc/DebugMe()
</xmp>

<hr>

<a name=/datum/proc>
<h2>procs (datum)</h2>

<p>Built-in datum procs:

<dl><dt>datum/proc
<dd><a href=#/datum/proc/New>New</a>
<dd><a href=#/datum/proc/Del>Del</a>
<dd><a href=#/datum/proc/Write>Write</a>
<dd><a href=#/datum/proc/Read>Read</a>
<dd><a href=#/datum/proc/Topic>Topic</a>
</dl>

<hr>

<a name=/datum/proc/Del>
<h2>Del proc (datum)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/del>del proc</a>
<dd><a href=#/DM/garbage>garbage collection</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Del()
</dl>

<dl><dt><b>When:</b>
<dd>Called when the object is destroyed, for example by using the
<code>del</code> instruction.
</dl>

<dl><dt><b>Default action:</b>
<dd>Delete the object.  The contents of atomic objects are also destroyed at
this time, as though <code>del</code> were called on each one of them.
</dl>

<p>When the world is destroyed, the Del() proc is not automatically called.
The only object for which it is called is <a href=#/world>/world</a>.  If you
need the Del() proc for a particular object to be called at that time, you
should explicitly call it from world/Del().

<hr>

<a name=/datum/proc/New>
<h2>New proc (datum)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/New>New proc (atom)</a>
<dd><a href=#/client/proc/New>New proc (client)</a>
<dd><a href=#/proc/new>new proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>New()
</dl>

<dl><dt><b>When:</b>
<dd>Called when the datum is created, for example by using <code>new</code>,
when reading an object that was stored in a <a href=#/savefile>savefile</a>,
or when the world is initially created.
</dl>

<dl><dt><b>Default action:</b>
<dd>None.
</dl>

<p>You can use the New() procedure to do more complicated initializations
than are possible in the object definition where you assign the initial
value of variables to constants.

<p>The following example makes use of the "Location" parameter that is passed
to objects of type <a href=#/atom>/atom</a>.  You can pass any number of
additional arguments to New() by passing them to the <code>new</code>
instruction which creates the object.

<h3>Example:</h3>
<xmp>
mob/night
   var/mob/squire/my_squire
   New(Location)
      my_squire = new(Location)
      return ..()
</xmp>

<p>Also note that the type of object being created in this case was
automatically inferred from the variable type on the left-hand side of the
assignment.  That's a handy little DM short-cut.

<hr>

<a name=/datum/proc/Read>
<h2>Read proc (datum)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/savefile/operator/&gt;&gt;>&gt;&gt; operator (savefile)</a>
<dd><a href=#/datum/proc/Write>Write proc (datum)</a>
<dd><a href=#/var/tmp>tmp vars</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Read(savefile/F)
</dl>

<dl><dt><b>When:</b>
<dd>Called when the object is read from a save file.
</dl>

<dl><dt><b>Args:</b>
<dd>F: the save file being read
</dl>

<dl><dt><b>Default action:</b>
<dd>Read the value of each variable from a directory by the same name as the
    variable.  Variables marked tmp, global, or const and variables for
    which there is no directory are skipped.
</dl>

<hr>

<a name=/datum/proc/Topic>
<h2>Topic proc (datum)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Topic>Topic proc (client)</a>
<dd><a href=#/DM/text/macros/ref>ref text macro</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Topic(href,href_list[])
</dl>

<dl><dt><b>Args:</b>
<dd>href: the hyperlink data (following ? in the URL).
<dd>href_list: key/value list (from params2list(href)).
</dl>

<p>This procedure is called by the default client.Topic() proc when the href
contains a parameter called "src" containing an object reference.

<h3>Example:</h3>
<xmp>
mob/verb/test()
   usr << "Click <a href='?src=\ref[src];action=startgame'>here</a>!"
mob/Topic(href,href_list[])
   switch(href_list["action"])
      if("startgame")
         usr << "Starting game..."
</xmp>

<p>The above example uses an embedded reference to the player's own mob to
create a hyperlink to that mob's Topic() proc.  You can easily add different
actions, parameters, and so forth.  Just remember that the parameter values
are always stored as text, so you need to convert those to whatever data
format you need using procedures such as text2num(), locate(), etc.

<hr>

<a name=/datum/proc/Write>
<h2>Write proc (datum)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/savefile/operator/&lt;&lt;>&lt;&lt; operator (savefile)</a>
<dd><a href=#/datum/proc/Read>Read proc (datum)</a>
<dd><a href=#/proc/initial>initial proc</a>
<dd><a href=#/proc/issaved>issaved proc</a>
<dd><a href=#/var/tmp>tmp vars</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Write(savefile/F)
</dl>

<dl><dt><b>When:</b>
<dd>Called when the object is written to a save file.
</dl>

<dl><dt><b>Args:</b>
<dd>F: the save file being written to
</dl>

<dl><dt><b>Default action:</b>
<dd>Write the value of each variable to a directory by the same name as the
    variable.  Variables marked tmp, global, or const and variables which
    are equal to their initial value are skipped.
</dl>

<hr>

<a name=/datum/var>
<h2>vars (datum)</h2>

<p>Built-in datum vars:

<dl><dt>datum/var
<dd><a href=#/datum/var/type>type</a>
<dd><a href=#/datum/var/parent_type>parent_type</a>
<dd><a href=#/datum/var/tag>tag</a>
<dd><a href=#/datum/var/vars>vars</a>
</dl>

<hr>

<a name=/datum/var/parent_type>
<h2>parent_type var</h2>

<dl><dt><b>Default value:</b>
<dd>The path of the object definition that contains this one.
</dl>

<p>This variable is set at compile-time to specify the inheritance of an
object type.  Normally, a new type of object inherits its variables and
procedures from the object type that contains it.  For example:

<xmp>
obj
   var
      weight
      color
   sword //parent type of 'sword' defaults to /obj
      weight = 30
      color = "black"
</xmp>

<p>Explicitly setting the parent type allows you to put the object
definition any place you want.  That often means putting it at the top
"root" level.  Example:

<xmp>
Armor
   parent_type = /obj
   var
      strength
   plate //parent type is /Armor, which in turn inherits from /obj
      weight = 100
      color = "rusty"
      strength = 10
</xmp>

<p>If you don't specify the parent_type for an object defined at the top
level, it defaults to <a href=#/datum>/datum</a>, which (with just a couple
exceptions) is the ultimate ancestor of all object types.  You could use
that fact to define procedures or variables that you need all of your
objects to share.

<h3>Example:</h3>
<xmp>
datum
   proc/Copy(datum/O)

MyType
   var
      foo
   Copy(MyType/O)
      foo = O.foo
      return ..()
</xmp>

<hr>

<a name=/datum/var/tag>
<h2>tag var (datum)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/locate>locate proc</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>null
</dl>

<p>This may be assigned to a unique text string identifying a particular
object.  A reference to the object can then be obtained by using locate().

<p>One reason to use tags is when making references in the code to objects and
locations that will be created on the map.  You can simply edit the object in
the map editor, set its tag, and then use that in the code relating to the
object.

<p>The following example demonstrates how to set a tag and use it to obtain a
reference to an object.

<h3>Example:</h3>
<xmp>
mob/verb/test()
	var/obj/O = new()
	O.tag = "My Object"

	var/obj/O2 = locate("My Object")

	ASSERT(O == O2) //this should always be true
</xmp>

<p>Setting a tag to "" or null removes it.  Any object with a non-empty tag is
immune to garbage collection, since the tag is treated as an implicit
reference to that object.

<hr>

<a name=/datum/var/type>
<h2>type var (datum)</h2>

<dl><dt><b>Default value:</b>
<dd>The "type path" of the object definition.
</dl>

<p>This variable is read-only.

<xmp>
mob/verb/test()
   usr << type //displays "/mob"
</xmp>

<hr>

<a name=/datum/var/vars>
<h2>vars list var (datum)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/initial>initial proc</a>
<dd><a href=#/proc/issaved>issaved proc</a>
<dd><a href=#/list>list</a>
<dd><a href=#/list/associations>list associations</a>
</dl>

<p>This is a list of all the variables belonging to an object.  The items in
the list are the variable names.  If the variable name is used as an index
into the list, the value of that variable is accessed.

<h3>Example:</h3>
<xmp>
mob/verb/dump()
   var/V
   for(V in vars)
      usr << "[V] = [vars[V]]"
</xmp>

<p>This example displays all the variables belonging to your mob.

<hr>

<a name=/exception>
<h2>exception</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/try>try and catch keywords</a>
<dd><a href=#/world/proc/Error>Error proc (world)</a>
<dd><a href=#/proc/throw>throw keyword</a>
<dd><a href=#/proc/EXCEPTION>EXCEPTION macro</a>
</dl>

<dl><dt><b>Vars:</b>
<dd>name: A text string (such as an error message) or other value
<dd>file: The filename where the error occurred, if debugging info is present
<dd>line: The line where the error occurred, if debugging info is present
<dd>desc: Detailed error info including call stack, only used when sent to world.Error()
</dl>

<p>This datum is created automatically when a runtime error is encountered,
<b>if</b> it happens within a try/catch block or you have defined a global
error handler with world.Error(). (The New() proc is not called when this
happens.) This provides a convenient package for getting file and line number
info associated with an error.

<p>If you throw your own exceptions, you do not have to use this, but the
EXCEPTION macro is provided to easily create one with the current file and
line number.

<p>The desc value is only filled in when you have a world.Error() handler and
there is no try/catch handling this error. Just like when no handler is
present, less detail will be provided after multiple runtime errors have
occurred. This only exists as a convenience feature for logging errors if you
want to use something other than world.log.

<hr>

<a name=/icon>
<h2>icon</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/icon/proc>icon procs</a>
<dd><a href=#/DM/icon>icons</a>
<dd><a href=#/image>image objects</a>
</dl>

<p>An /icon object is created by loading an icon file into memory for direct
access and manipulation.  In order to be displayed, an /icon object always
gets converted back into an icon file; this happens automatically when you
assign atom.icon to an /icon object, since that variable may only refer to a
static icon file, rather than a dynamic memory object.

<p>To create an /icon object, simply use new/icon(), or the short-cut icon()
instruction.  The following example loads an icon file, reddens it, and then
assigns it back to the player's icon, which implicitly creates a new icon
file.

<h3>Example:</h3>
<xmp>
mob/verb/test()
   var/icon/I = new('player.dmi')
   I.Blend(rgb(40,0,0))
   usr.icon = I
</xmp>

<p>Note that merely displaying different icon states or directions can
generally be achieved without any icon manipulation, which is good, because it
saves quite a bit of overhead.  For example, the variables atom.icon_state and
atom.dir can be used to control how atom.icon is displayed, without any need
for generating a new icon file.

<hr>

<a name=/icon/proc>
<h2>icon procs</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/icon>icon</a>
</dl>

<dl><dt>icon/proc
<dd><a href=#/icon/proc/New>New</a>
<dd><a href=#/icon/proc/IconStates>IconStates</a>
<dd><a href=#/icon/proc/Turn>Turn</a>
<dd><a href=#/icon/proc/Flip>Flip</a>
<dd><a href=#/icon/proc/Shift>Shift</a>
<dd><a href=#/icon/proc/SetIntensity>SetIntensity</a>
<dd><a href=#/icon/proc/Blend>Blend</a>
<dd><a href=#/icon/proc/SwapColor>SwapColor</a>
<dd><a href=#/icon/proc/DrawBox>DrawBox</a>
<dd><a href=#/icon/proc/Insert>Insert</a>
<dd><a href=#/icon/proc/MapColors>MapColors</a>
<dd><a href=#/icon/proc/Scale>Scale</a>
<dd><a href=#/icon/proc/Crop>Crop</a>
<dd><a href=#/icon/proc/GetPixel>GetPixel</a>
<dd><a href=#/icon/proc/Width>Width</a>
<dd><a href=#/icon/proc/Height>Height</a>
</dl>

<hr>

<a name=/icon/proc/Blend>
<h2>Blend proc (icon)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/icon>icon</a>
<dd><a href=#/icon/proc>icon procs</a>
<dd><a href=#/atom/var/overlays>overlays var (atom)</a>
<dd><a href=#/proc/rgb>rgb proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Blend(icon,function=ICON_ADD,x=1,y=1)
</dl>

<dl><dt><b>Args:</b>
<dd>icon: an icon file, /icon object, or color
<dd>function: the blending operation to use
<dd>x, y: the position to blend the icon
</dl>

<p>The valid blending operations are:

<ul>
<li>ICON_ADD
<li>ICON_SUBTRACT
<li>ICON_MULTIPLY
<li>ICON_OVERLAY
<li>ICON_AND
<li>ICON_OR
<li>ICON_UNDERLAY
</ul>

<p>The result is a combination of each corresponding pixel in the two icons.
In all but ICON_OVERLAY, ICON_UNDERLAY, and ICON_OR, the transparent regions of
the two icons are ORed together.  That means if either icon is transparent on a
given pixel, the result will be transparent.  With ICON_OVERLAY or ICON_UNDERLAY,
on the other hand, the original icon shows through wherever the top icon is
transparent, giving the same effect as an overlay object, but resulting in only a
single icon. In ICON_OR, the transparent regions are ANDed together; solid pixels
are added together where they exist in both icons, or just pass through if the
other icon is transparent at that pixel.

<div class="figure">
<img src="data:image/png;charset=utf-8;base64,iVBORw0KGgoAAAANSUhEUgAAAQQAAADeCAIAAABUuOmgAAAYv0lEQVR4XuyXSyisYRjHdUysXGrkGqGhCIlS7jVRiLIkC5dIDaFmyGUxMyiFBVk4sxi3yC2JjbJjoUhYjCJsJLnkWkiDc37HW9PXfB0L2c33rP79n2/e55n6P+//ed3+fIYS4+PjZ2dncn55edlisVit1uPjYwcZERHx7ULZ2dnn5+cCHx4e7u7u3t7e/v6MpaWlp6cn+B+Pr9ve2tri3ykacAMosbe3p1KpWltb5an09PTy8nKDwRATE9PR0SFId3f3b9cKDw8/PT0FfHx8ZGVlgW02m7e3t8lkopCXl9fJycmPC+Drto+OjrRarSKDX26Ey8fIyEh3d/fo6CgClWerq6v7+voWFxcHBwfl2ff3d65zOfny8iJlOPnu7k7KzMzM4BKhoaHgoKAgo9E4NjZWUVExMTHxRasI4PHxUeDX11e73e5U5fr6mm+k5NvbGz+Rd/j8/CywRqNJTEycn593cRkow/BPUuiyrq4uKSlpZWVFLj4CsL6+npeX55RluQoODoavqqp6eHiASUhIMJvN+ElUVFR/f78oMTs7y91fUFCQk5PjGJLJyUmsQFoLdW5vbzMhYHngS5WVlWTZdnQ63dDQUGZmJjqenp4WVQYGBjCWoqIiarHdCbK3txeSutJazFtISEh+fj4HirYdQ+jSoZjj3NxcaWkpgKuxuLjYKZuWlhYWFqZWq1HP1dWVdN84ODjw8/Pj0gXr9fqpqSlAfHx8fX094ObmxtfXF4u4uLjw9PQUS/nGxgYCEGsSOiYL2N/f58DY2FhWtebm5v/12d7enpKSwjWPEfFlbW0tJMOTnJwsTg4MDLy8vATv7Ox4eHjc39+T9ff3F16B7VBFPFRomxkAt7S0MJMATCY6Olp5M7h65ObmdnZ2rq2tra6uIjIU7zQMvGuRMmLy8fFBQ45hGB4eRkCNjY1NTU2FhYVlZWWQOMPm5iaAiIuLYx1fWFjIyMhwlAsICGAYMAHGRjC8GSIjI5kZBF1SUtLQ0AApj7a2tq6uLoFTU1PpFsCaRM9sRzw5pD+kNFbW09NTU1MjGBxJtM1LHdeibQIbERcBAcmkubISVH/ZM3+WhMIwinstQcUCB+kP1FCNlTjctCLSaAlKQVydpDkcA6G+Qm4NRUFQLQ6tuolDObTUVpOR0RCUUkT058d94MHUb3B9Bnl9fF/vGc6955znOuxdTJAqlYrf74eRhmHgOnAv2Wy2dQ+/TlqFISmVSslkUm03jp+vEICzbBOlxZbIBq/XC1ndbje+RY80Gg0WNFtDBYQesgrTFQwGu4YT4Pl8Plm7XC7WclAIgNmj+c8BO50ej0fBcF3NFZ2wKaAiHb3MYN/C9GcymXOrSA77VtFHASCHUFB2crdUq9VYLKZnEQ1EgGcwPh5BgMo09YgWg5pyuVyv11lj5dEEWCjMbjabbekF/UmlUqzxToyVumLWq+hCrgJ+prSsGdfWajUgkR8KhQJGToYEEn7IM8BGl4DNp8BGDwOBQC9A2zovQf10Oq0dIikEhfQ0ebcgexKJBIzBVNDR5ygVCoWwLjh17hBsEm8P9G91j4hAPp+PRqN4m2KxSAIR+obDYQb8sgcbhiagS5glDA8dhkuQuBOwqkTbVYjIOCKmUpFIhGRMgEYTcF80wUnYQCg4JRE/l8uhQsCOx+MCGySmaTpsXn/s2DEKwjAUgGEHzyROvV02DyKuOVFwzSSKWNH4oCBCEEVQl++bC31Df16a1mE6Ycdxor1hHMf4atsr0w1se1BKGYbh2Vvi8/1g7NhmtdZ+wtg5/ZMx9n22SCiWiR/ovyGllHNundhOceb55X1a3AK3LxADiAHEAGIAMYAYQAwgBhADiAHEAGIA5jd27mDHQRiGoigezX8jvvzN0iNFbRBLc+4y8uvuyqYOHDcAqtb7zscwNjIAVd/Ok7e+3AMmrAVkABO6zJhk5mVCFydzZZjf5qtYgc2YpM2j6kFkjAzaPHQGJnQEZGBCB0EGJnyOgwwAGYDkQWSADGYkkxJc1MO1iH+mm0PVO9qCMYkGV23Ok/kmkIEJdwuS+SaQgQn3fViU6PPhzwxgQhf3I0TsGeb+I7j/EdgzQFvYR8gAzJfBpNRxkIEPHQQZ3K0BGeb6wASQYfWBCWeeRKZg6Zbc/FQMUEmOF2LboC3YM+AMEz7JAD4wwUU9PlxFg3/8sXfHNBCEQBiFr1gpZ4IEBVAgAzTghFFDyPToQAEd3OW6axCw+75qDLxM+W8ALPcAxPAHIAaAGABiaK2p6j6CqpZSRKT3Tgz3tNZ6/+wjpJS89zlnY0wIgRhuqNbqnLPWnp8DYowi8j3mnNd1jTH2M3zYNUMUCEAgii4bbCZhmsUqeAzPIaY9gNcxa/AaFhEMggfRsHFX2O4Bdnzph19+mRn4g6iB9t4bY6y1W5ydl9/HWq1VCAEAaGLjYM7JGNujbgtK6VrrYL5nEgBwzgkhvfd/i3c3Q4xRKVVKaa1JKVNKB/PFOZdzDiForccYWGJ/2bFDGwaBOA6j9RgcLMAGJ5igpr4r1JMm4NmBhE6FQSCZg4QrOVXTDkDfW+HyXfL7x/8QQjhG4T05Hriu6/idzTCOY0yOKvq+N6DPY57noij2fY/Jtm15ni/LEn8yoNd1rapqmiYxnEX63tq2jR+apum6Ln4hhizLyrIMIQzD4LR6MiAGEAOIAcQAYgAxgBhADCAGEAOIAcQAYgAxgBhADCAGEAOIAcQAYgAxgBhADCAGEAOIAcQAYgAxgBhADMCbXTvYQRAGoig6r+G/0S9/boy1Epo26SCLe5fDruGEEdkiKUXN0YukOrDjPNLXWXn1WW1xQRpWQdK4CmCsVVEiIw3PSRqck6T+PB9DvhPK8YCTeQx4wAMe3hjwgAc8VAx4wAMeShBRIgbHaGTHWGT7CgxsSmxKbErb4rv5Q9fNVXpIvxO7Phy+rtLzIH+3Pw8HpZ2VbC9gcEZCLFQHBmckJBaqHwZnJCRlLFSF7y/uQsUOGqNiO+s3Q7aHlkR3joeWRGeOhwOJOv/LmsQWNL8m9fcl7vWB9ns9GRw1WnSX0/7Xsyo3ennKsjQcy1IiBiIq/M3MpsSm1GDAAx7wUPgMCQ94aDDgAQ94KLEkT8zxMD7Hw5VOtliVJ16n4mH2dSoenlJk92Ln3k0YhqEwCmcZzeARNI5qg3uXbjWBKmNcuPAD9yo0gkALeAMjbroUSgwJBJLifOWvTnDaK98GcFEPIAaAGABiAIgBIAaAGABiAIhh27YQgrxyHEdVVcWYc1ZKPYbiyTknT7z3+77L21JKWmv5Y+d5zvPctu00TXJhHMe6ruXHfv9R1toYY7EPwxBCkAtN0/R9X4xd1y3LIheMMeu6yifu3J1pSJZZFMcbl3BrwQUMxUIbDa2ItnEvbBnXJdDApXWhDRsFMSZGo7CmDxqugftWo8U0jYU2C2h7Y9FCIWgNjloh6CiuS43jzA8OPLw8T9bL9OV9536Q0+Hce5977jn/8z8P8bzqDwK8e/cuISHh0KFDyNoxPT3d1dWl1ROs77VvbGxsbm7W6vfv379jxw5SBVmfgQdfvXplyF96W7p06fXr1y0sLMrLy2cyGxkZAU20+n379v23fScmJpKTkxGMaLx9+/bgwYOAgq6yu7s7NjYWsJhpFn4bHR1FePr0aVFRkSjXrFnj7u4+05S+vr6xsbFP+jrG1atXQ0JChoaGXrx4oToDT8Otq2J0eHj4A6ufO3dOm1ecx9raeuXKlaS1yp6nZwvVfY+Pjxv4BTc1Ndnb2+fk5BCaly9f/qi93KsyKioqtH4QAbzAA6rpg4ODgiN45sKFCwjGNfDVgwcPdNEtNzfX29tbn+/kPX/+/MmTJ6Lx8/NbtGjRBxxLLH1SMpSUlOzcuXPPnj1lZWWKMi0tjQOsW7cuNTVV2eDMmTNz587duHHjrl275EFVo7Ozc2BgYMWKFSo9K+/evZtd2Es0PT09zs7Ohw8f3rx5M4zr9u3bUoWAEEdHRx8fn5MnTxry7fLMz549a2trUzRQpi1btoh88+ZNZKU4gDU4jUPdunWLOkxJIbL5W1VVde/evfXr12O8YcMGjHHs6tWr165dq8A/9NLNzY3prq6ujx8/9vf3x8PMra+vN6JvP5LeR44cAShFA55euXIlPDxcDDIyMrKzs0U+ffr02bNnlbkADaF4/vz5ZcuW9ff3U1EFC5gLQV2+fDkZtX37dt3yyy5EmshwM25K3/+o9/r1aycnJ6IQwc7ODuBHSfVfsmQJtQKZBCA6EchsBCoRMsFtZmamZWDHjh2rqalRKScnJ1kZbKPUzJ8/v7e3F+WbN284kjA8eoxt27aJQBxIOTp69Kinp6chU+GLFy/OmzcPjoQsTouOjhb5xo0bInOLOApERCZbuDkxMDU1FeHu3bvI+Fb0Dx8+5C5IFQcHByn6uI7VpBmbmpri1gEp4+oZuFArKyvCacGCBVQ2NFlZWZmZmSQAjQEG6enpaMT41KlT6BEOHDhQWVmJUF1dDceWpfbu3YtLEUJDQ4ODg4ko3AXO5ufno4yPj6cPIdIIM9IPzfHjx0ktfXsGwIn+GGAmh/AyNyoxGhMTQxFAjouLE0ua7KioKGwUpZbl0/EwUUvDQDWYEiAH7HEY0c+ZMwfAQwgMDLxz547su3XrVggVMm2MgQMej0rsUu65qg/8KCVlgRqIsGnTptbWVnBdhZouLi5QYVHgcwAlIiKC0MH40aNHUp+xNDExIW1kF2McHI2wIbJJ6cLCQigAZxFHzeQ9lDMxH+wpCLNnz0ZgWeqkWKIHocLCwohkASPM9KJJWEtrwsNRXAD+0tJS9DSFNjY2SkUTwdLSkvAVmavSrkszFBkZyVyVvri4mOdjfQYry47y0PyVlXGQCOyr2sLAyVJLS8ulS5fgh1wMQK4lshxTBCokBtoqrZBgSBeZExQUxBWCUDgHe6Dhf/OVbN725OXlgZhwY1tbW84uenGdwipVP+mp/FOVIUo0UkIpm7qWwBMM5f79+6tWraK06pUMFATyFVpGxWc0NDTQ4EJjiGkuWAqN0uoBV1jyrMhwg/e2zpQ2lRL2RUFgZdavq6u7du0aywKo2uMx2BczWDW1T/Y12PHy5UtJV1yED/E4RY/EIOLRcFLlOnGaAEptba2XlxdBgGxubq7q/BhQJt4mU0BwETJzuUulfcQtDPCCifjHGL8XTw2E+tM8pKSk6Br4+voKFYT2EHiqyoB76Ra0a0KqZQpdBJRJ9zuTAQEBIEtBQQEBqW8DDfWnY1MMACFKPykFLEFg6E64DMirGCxevJgmm+YYWs9dqhZtb2+HHNPqqfTQvsTERFJf0UD72Fc5qu4ZAEWcRcTw3glmZcgX3NHRAaLjDfwO5QWlGElJSfQ5ZIWQSTkjBvAcTnTixAl8K3os6R+EMSoDFko/jT1+xsnMxfkEBxqMuQsgkGSAGSMDK8b4gyO8j8E/Hh4euga8FcB7vBUgKxiqFCIqeFfB6wcYpu5qkAimLFy4kMAjwVQ1hB4a7s3LiY8c4F927R4ngSiK46iFa3EzNm7FltLGtVhQkNi6BJeCCajhw4/rP07D5FJQaIyTc1qohvy4efdNnSZjPceAGtt9qyatZ79RPyETM1PvX9wl5eepscy9/tCifzMzto7JwKmxzIEsUupARk1NRX8gpzyWnApyh5tROaxbumwjs276m9cxslrJwah+DfQYatD+j/JOQO7m0s/0302C7NyyaqtmOKRlr90+FQNMKQYQA4gBxABiADGAGEAMIAYQA4gBxABiADGAGEAMIAYQA4gBxABiADGAGEAMIAbg/ItdM1hxEAiC6HTjf8t8ee1hYRsS1qgzbYt5dQoDQvFqKoVgu0RmrydSQ7diBSuTdKFdYr4vK1h5keOIH92EFay8wDEZ35IVrExSjlnFQfss6XuDtbYzAliFgts8VssFhVW4R6zhxHtl0YoZ8hzH+sc91yNYHQ0SVtutGGflF//PiU1AKfdqAli/Pl2R7oBgldcHL0lXpDsgWCX1wavSFemilHtlA2VACCWWYXc7+dZAsDqiVFZeuPti91HKvToJfJl9ny1+NDELf+pvNNZmf+FZGStmIeQDNdCncyPd3xr0pu1zpbCiCfll6LZ/Mezbm2B7F0OwspImhDzNcfThrRJxTrovfXipRJzDKl9LpmNFDTazJN3eFK8QsCqSn3SfMGYIVr2pkJUn13evLUa/w6pa3hBCg2Xo7P6AYJW1kFLNMvQCxzSBPmSx8lHfN0mXJtAHqf6doZenSxPog3TpO8OqE32w70x31fFHYHWkDxmslmk9jlDne2UN2Ie1WTYrk5T0Acn6xFgfzApWPjBqpPsoVrDyAd+k+yhWsDJJA9NGtA9iBasf9u7QCGAQCoJoeqEEWqMFKIIZBBV8BO38FhgkYC42kkFEJPd6WL14FRHPPUSMgYgxEDEGIsYw5yylhBBijKqKX1LVlJL3XkTWWjjSe7fW4ltaayKCh5zzGAMbjDHY4JyrteLUTc6Zh1SZhWF8JrXQ/hD3rQXEBXdrFHEL1FBUNFxCxTDcl8Il0EAt3GYKFANRo4ERx70QZ5BBNDBcCFwR3EIFd8MtGm2BGbWZHxz4uNxrQwwjce+cP+I97znfte857/s+z3vk+p99uWd9fZ3za2lp0dPT29nZuXLlCq+K/3816urq3N3dV1dXjYyMOjo6XFxcXr9+/S8A+PTp0/LysoqBAxQlJSWynoyMjPfv33/Js1+IBoH34cOHr/9Nt7S0tOjo6KdPn6akpOTn54+MjGRlZa2srEgb4A3OWIUzYX5+/s6dO+Pj40VFRYmJiQ0NDVFRUdnZ2f/wyLt37xSdivEBwzBUACIIQOEv6H0rGyEHBweyq0wVITo6Ovr48aOck2cPDw8V4f0KybC1tfXixYu8vDzJY2pqevPmzfb2dmxra+uHDx/a2NiwR4WTob6+/tatW+fOnZM85AbCYH9/X0dHZ3d3VzivXr3a39+/t7cXFBTk7e3t6ekJneIfHBz08/O7du2av7+/FDQYbPPy8nJyckJ6icc7OzvF6qNHj+7evass+BD3jGPT4/Tp0w8ePOD1zc3Nnz17JpbKy8u1tbVxEkjS/sbGRjMzs8DAwPj4eMQknkuXLqHMbW1tu7u7Jdyam5sdHR0DAgLc3NwIzufPn4OzVGv09fVJp5P6pdvLly8vX74s56yurk5OTsawtLS8ffs2CY2twuP69eucgZzz4sWLMzMzJEltbS3TjY0NzhsDQOBPDGidPXDmwMCAmpra2NgYzjdv3qA2BQCjo6NiG5EBPxArkZGRYsnBwWFhYUFZ8JmennZ2dpb1nD17lhqBoaGhQbRg8PqiWYJgDQ0Nt7e3sRGfIIMxNzcHLBQX7NzcXBIDg89MSkoS0RUXF4c2wZidnQUxjMzMzCdPnrBqYmKCfMXDU+np6SfYM2hpaSmSOxXRwMBA2ATKqVOwkCoPTU1NRRDevn3L+VHGmpqamLa2tnISGPR5aMicnJyCggJIf2JiAid5QijIiQd1dXUYJjw8HIR5BOogbbCJLQjHwsJCiZhBTskQo0S54IfY2FgMSurU1BSlgVrOm4r4iYmJEYD09fUB5v379xGfr1696urqEhBRHaToEjthD4ga3c6NDtiympqa2tbWJggcJY9xUszA2ZDcIvOk4ePjQxOJYWVltbi4iKHao7KykpyX9cAJMLKwUYngg9qBtZmiprhzQy8xOGOoAJmEBGJJlhl6e3uJD6IfWXXhwgXBA+QG5Y3SSGopET6QAEGJjhdTElvUe8EM5IlEF9goQCqF8MAPYmdNTY2vry9wCdAmJydxAik4i50IKsEMdnZ2jx8/5kdAyHSzeAAf4SSueU72NokXoMJBUhRCSc5ik9ySLlT5Qe0haik8Yrq5uQkgFRUVYkpLXVxcTCGH/ZlSKWi46Rm4duPqSVdX91iUyJCIiAi2LS0tcZzCiSogGeCWsLAwJcKH9KYsEqO0xeg9akFwcPDnGuvQ0FDaLdEBc1UtnB4eHsPDw8Q0oPEvuMmxqJhSONbW1ij/VBy6VrHh/Pnz7L937x7+E/+mGz/mzJkz9DEcLTWA/zdVDXqSmEvlB1pxaGgoISEBHkffcyRlZWXkg1i9ceMG3E2TJ6bcKISEhKCLuGmwt7dH1x4LAAqBiO/p6UHyslk4IRkkKH02gCsXRPRUSJrS0lJs7p2FdDx2gAw5Tz9ACsG3wsm0sLDQ2NiY6II9qqqqqCwkkpzMAXzQ5vPxuLq64pGqFXjy1GcB+LtdM7aBEIah6K2SDW6JbHHV9bSMxBJZABagZQLuJEBIIJB5ogMk5IKG4DeC5fz/bUeuBovH5uTBIHu4ovIOpdkr0PqyhbZgRrzv9Y0xSXnGhWN5cQxNdN/Vlq0dUhXPdwyDPmCFjfKJGoMXRb5yzpE243kMRrKCuIoag/jqvQ8hyCkLeZhbPog5eksAAAAASUVORK5CYII=">
</div>

<p>In addition to blending with an icon, an rgb() value may also be specified.
This is treated identically to an icon of that same solid color, except that the
x and y arguments will be ignored. Blending with a color blends the whole icon.

<p>By default, the icons will line up at their lower left corners. If you want
to position the second icon in a different place for blending, use the x and y
arguments to specify where its lower left corner will be. 1,1 is the default,
which is the lower left. 11,1 for instance would be 10 pixels to the right,
and 1,21 would be 20 pixels up.

<hr>

<a name=/icon/proc/Crop>
<h2>Crop proc (icon)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/icon>icon</a>
<dd><a href=#/icon/proc>icon procs</a>
<dd><a href=#/world/var/icon_size>icon_size var (world)</a>
<dd><a href=#/world/var/icon_size>map_format var (world)</a>
<dd><a href=#/{notes}/big-icons>Big icons</a>
<dd><a href=#/{notes}/tiled-icons>Tiled icons</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Crop(x1,y1,x2,y2)
</dl>

<dl><dt><b>Args:</b>
<dd>x1,y1: Coordinates of one corner of the rectangle (1,1 is the lower left)
<dd>x2,y2: Coordinates of the other corner
</dl>

<p>A portion of the current icon is cropped (cut). If the crop region extends
outside the icon, it will be padded with transparent pixels.

<p>If using the TILED_ICON_MAP value for map_format, all icons must be even
multiples of world.tile_size, so the icon will be padded with transparent
pixels to the top and right as needed.

<h3>Example:</h3>
<xmp>
// start with a simple icon
var/icon/I = new('circle.dmi')
// take the upper right 16x16 chunk
I.Crop(17,17,32,32)
// that chunk now appears in the lower left corner
icon = I
</xmp>

<hr>

<a name=/icon/proc/DrawBox>
<h2>DrawBox proc (icon)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/icon>icon</a>
<dd><a href=#/icon/proc>icon procs</a>
<dd><a href=#/proc/rgb>rgb proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>DrawBox(rgb,x1,y1,x2=x1,y2=y1)
</dl>

<dl><dt><b>Args:</b>
<dd>rgb: <tt>rgb(red,green,blue)</tt> or <tt>null</tt>
<dd>x1,y1: Coordinates of one corner of the rectangle (1,1 is the lower left)
<dd>x2,y2: (optional) Coordinates of the other corner
</dl>

<p>A rectangle (filled) of the given color is drawn over every frame in the
icon. If x2 and/or y2 are omitted, a line or a single pixel is drawn. To draw
a transparent box instead of an opaque color, use null as the color.

<hr>

<a name=/icon/proc/Flip>
<h2>Flip proc (icon)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/icon/proc/Turn>Turn proc (icon)</a>
<dd><a href=#/atom/var/dir>dir var (atom)</a>
<dd><a href=#/icon>icon</a>
<dd><a href=#/icon/proc>icon procs</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Flip(dir)
</dl>

<dl><dt><b>Args:</b>
<dd>dir: direction in which to flip over the icon
</dl>

<p>This flips the icon over in the specified direction.  For example,
Flip(NORTH) would be like turning the icon upside down by grabbing the bottom
edge and flipping it up over the top edge.  You would get the same result by
doing Flip(SOUTH).  In general, this is not the same as turning the icon by
180 degrees, because it produces a mirror image.

<p>If an icon is square, it may be flipped diagonally.

<hr>

<a name=/icon/proc/GetPixel>
<h2>GetPixel proc (icon)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/icon>icon</a>
<dd><a href=#/icon/proc>icon procs</a>
<dd><a href=#/proc/rgb>rgb proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>GetPixel(x, y, icon_state, dir=0, frame=0, moving=-1)
</dl>

<dl><dt><b>Args:</b>
<dd>x,y: coordinates of the pixel to grab; 1,1 is the lower left corner
<dd>icon_state: a specific icon_state to use (may be null)
<dd>dir: a specific direction of this icon to use
<dd>frame: a specific animation frame to use (1 is the 1st frame)
<dd>moving: non-zero for only movement states, 0 for non-movement states,
  or null (default) for either
</dl>

<p>This finds the icon_state and the right animation/direction frame of your
choosing (it will pick the first one available if you don't specify) and
returns the rgb() value of a pixel at that location, in "#RRGGBB" form.
If the pixel is totally transparent, it returns null. If the pixel is
partially transparent, an alpha component is also returned in "#RRGGBBAA"
form.

<hr>

<a name=/icon/proc/Width>
<h2>Width proc (icon)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/icon>icon</a>
<dd><a href=#/icon/proc>icon procs</a>
<dd><a href=#/icon/proc/Height>Height proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Width()
</dl>

<p>This finds the width, in pixels, of the icon.

<hr>

<a name=/icon/proc/IconStates>
<h2>IconStates proc (icon)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/icon>icon</a>
<dd><a href=#/icon/proc>icon procs</a>
<dd><a href=#/proc/icon_states>icon_states proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>IconStates(mode=0)
</dl>

<dl><dt><b>Args:</b>
<dd>mode: see <a href=#/proc/icon_states>icon_states proc</a>
</dl>

<p>This returns a list of all icon state text strings that exist in the /icon
object. This works in exactly the same way as icon_states(icon).

<hr>

<a name=/icon/proc/Insert>
<h2>Insert proc (icon)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/icon/proc>icon procs</a>
<dd><a href=#/icon/proc/New>New proc</a>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
<dd><a href=#/{notes}/big-icons>Big icons</a>
<dd><a href=#/{notes}/tiled-icons>Tiled icons</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Insert(new_icon,icon_state,dir,frame,moving,delay)
<dd><small>(supports <a href=#/proc/arguments/named>named arguments</a>)</small>
</dl>

<dl><dt><b>Args:</b>
<dd>new_icon: an icon file or /icon object to insert
<dd>icon_state: an optional text string, specifying a single icon state to
  change or add to this icon
<dd>dir: an optional direction; the inserted icon will only be added for this
  direction
<dd>frame: an optional animation frame (starting at 1); the inserted icon will
  only be added for this frame
<dd>moving: Non-zero to insert as a movement state, 0 for a regular non-movement
  state
<dd>delay: 0 or null to leave unchanged; positive to set delay for a frame and turn
  rewind off; negative to set delay and rewind
</dl>

<p>This adds additional states or images to an existing icon, allowing you to
build directional, animated, and multi-state icons on the fly. If the state
you wish to insert already exists in the file, it will be altered; otherwise
it will be added. An animation may be built a piece at a time, for example by
inserting an icon into the NORTH direction for animation frame 3.

<h3>Example:</h3>
<xmp>
// start with a non-animated arrow icon
var/icon/I = new('arrow.dmi')
// make a new state called "blink"
var/icon/J = new('arrow.dmi')
I.Insert(J, "blink", delay=-1)  // set rewind flag
// create darker shades of the arrow
var/n = 2
for(var/light=9, light>=5, light--)
   J = new('arrow.dmi')
   J.SetIntensity(light/10)
   I.Insert(J, "blink", frame=n++)
// congratulations, you have a pulsating arrow
icon = I
</xmp>

<p>The icon resulting from this example has two states: The original arrow,
and a new state called "blink" that pulsates between full and &frac12;
luminance. To use the blinking state after that, set the atom's icon_state to
"blink".

<p>(Note for animations: When building an animated icon_state from scratch,
you can only add 16 new animation frames at a time; i.e., frame&lt;=total_frames+16.
Higher values for frame will be ignored. This is a safety precaution.)

<p>If you insert an icon of a different size, the src icon will be resized to
match the size of new_icon. (The only exception is if you are using the TILED_ICON_MAP
map_format, and new_icon is a single tile being inserted as a chunk into a larger icon.
If icon_state, such as "2,0" or "open 0,0", already exists in src as one of its smaller
pieces, then new_icon will be inserted in its place.)

<p>When inserting an individual animation frame, you can change the delay for
just that frame only. If you don't specify a delay, the nearest frame's delay
will be used. If this is the first frame being inserted into an icon, then
the delay will default to 1 tick. Remember, if your delay is positive, it will
turn off the rewind flag for that entire icon state; negative will turn it on.

<hr>

<a name=/icon/proc/MapColors>
<h2>MapColors proc (icon)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/icon>icon</a>
<dd><a href=#/icon/proc>icon procs</a>
<dd><a href=#/proc/rgb>rgb proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>MapColors(rr, rg, rb, gr, gg, gb, br, bg, bb, r0=0, g0=0, b0=0)
  <br/><i>or</i><br/>
  MapColors(r_rgb, g_rgb, b_rgb, rgb0=rgb(0,0,0))
  <br/><i>or</i><br/>
  MapColors(rr, rg, rb, ra, gr, gg, gb, ga, br, bg, bb, ba, ar, ag, ab, aa, r0=0, g0=0, b0=0, a0=0)
  <br/><i>or</i><br/>
  MapColors(r_rgba, g_rgba, b_rgba, a_rgba, rgba0)
</dl>

<dl><dt><b>Args:</b>
<dd>rr: portion of old red component -&gt; new red component
<dd>rg: portion of old red component -&gt; new green component
<dd>rb: portion of old red component -&gt; new blue component
<dd>ra: portion of old red component -&gt; new alpha component
<dd>r0: new base red component
<dd>...
<dt><i>or</i>
<dd>r_rgb: red component is converted to this color
<dd>g_rgb: green component is converted to this color
<dd>b_rgb: blue component is converted to this color
<dd>rgb0: this color is added to the result
</dl>

<p>This is used for complex color mapping that can be used for many special
effects. For the number form, values usually range from 0 to 1, but you can
use anything you like, including negative numbers. 1 means 100% of the
original color will be used. If rg=1, for example, then the amount of red in
the original icon becomes the same amount of green in the new icon's colors.

<p>There is also an alternate form that can use <tt>rgb()</tt> values
instead, though it is less flexible. r_rgb is the color that will be used in
place of 100% red; any darker shades of red will become a darker shade of
that color. g_rgb converts green to another color, and b_rgb converts blue to
still another color, and all of them are added together.

<p>Either of these calls change the icon to grayscale:

<xmp>icon.MapColors(0.3,0.3,0.3, 0.59,0.59,0.59, 0.11,0.11,0.11, 0,0,0)
// or...
icon.MapColors(rgb(77,77,77), rgb(150,150,150), rgb(28,28,28), rgb(0,0,0))</xmp>

<p>The calculations are as follows:

<ul>
  <li>For any red in the original icon, add 30% gray to the output.</li>
  <li>For any green in the original icon, add 59% gray to the output.</li>
  <li>For any blue in the original icon, add 11% gray to the output.</li>
  <li>Add an additional 0% (nothing).</li>
</ul>

<p>Or this will make a nice moonlight effect:

<xmp>icon.MapColors(0.2,0.05,0.05, 0.1,0.3,0.2, 0.1,0.1,0.4, 0,0,0)
// or...
icon.MapColors(rgb(51,13,13), rgb(26,77,51), rgb(26,26,102), rgb(0,0,0))
</xmp>

<ul>
  <li>For any red in the original icon, add rgb(51,12.75,12.75) (dark pink) to the output.</li>
  <li>For any green in the original icon, add rgb(25.5,76.5,51) (dark bluish green) to the output.</li>
  <li>For any blue in the original icon, add rgb(25.5,25.5,102) (dark grayish blue) to the output.</li>
  <li>Add an additional 0% (nothing).</li>
</ul>

<p>Or a negative icon (invert all colors):

<xmp>MapColors(-1,0,0, 0,-1,0, 0,0,-1, 1,1,1)</xmp>

<p>The longer formats of MapColors() will allow you to also change alpha colors.

<hr>

<a name=/icon/proc/New>
<h2>New proc (icon)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/icon>icon</a>
<dd><a href=#/icon/proc>icon procs</a>
<dd><a href=#/proc/image>image proc</a>
<dd><a href=#/proc/new>new proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>New(icon,icon_state,dir,frame,moving)
<dd><small>(supports <a href=#/proc/arguments/named>named arguments</a>)</small>
</dl>

<dl><dt><b>Args:</b>
<dd>icon: an icon file or /icon object
<dd>icon_state: an optional text string, specifying a single icon state to load
<dd>dir: an optional direction to extract
<dd>frame: an optional animation frame to extract
<dd>moving: Non-zero to extract only movement states, 0 for non-movement states,
  or null (default) for both
</dl>

<p>You generally don't call this directly but via new().  The specified icon
file is loaded into memory for direct access and manipulation.

<p>If the icon state is not specified, all icon states are loaded.  Ditto for
the direction, animation frame, or preference for movement states.  Animation
frames are numbered from 1 and up, so frame=4 is the 4th frame.

<p>(Movement states are special versions of an existing icon_state with the
same name, but appear in the Dream Maker editor with an "M" indicator. These
states are used for animation when the atom using the icon_state moves from
one tile to the next; otherwise only the normal non-moving state is displayed.)

<p>The following contrived example, loads the EAST facing default icon state
"" from the user's icon file, rotates that a bit, and then creates a new icon
file for the user.

<h3>Example:</h3>
<xmp>
mob/verb/test()
   var/icon/I = new(usr.icon,icon_state = "",dir = EAST)
   I.Turn(90)   //rotate clockwise 90 degrees
   usr.icon = I
</xmp>

<p>Note that merely displaying different icon states or directions can
generally be achieved without any icon manipulation, which is good, because it
saves quite a bit of overhead.  For example, the variables atom.icon_state and
atom.dir can be used to control how atom.icon is displayed, without any need
for generating a new icon file.

<hr>

<a name=/icon/proc/Scale>
<h2>Scale proc (icon)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/icon>icon</a>
<dd><a href=#/icon/proc>icon procs</a>
<dd><a href=#/world/var/icon_size>icon_size var (world)</a>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
<dd><a href=#/{notes}/big-icons>Big icons</a>
<dd><a href=#/{notes}/tiled-icons>Tiled icons</a>

</dl>

<dl><dt><b>Format:</b>
<dd>Scale(width, height)
</dl>

<dl><dt><b>Args:</b>
<dd>width,height: size of the new icon
</dl>

<p>The current icon is scaled to a new size.

<p>If world.map_format is set to TILED_ICON_MAP and the new size is not in
multiples of world.icon_size, the icon will be padded with transparent pixels
to the top and right as needed. See map_format for more information.

<p>Scale() automatically performs antialiasing to avoid unwanted artifacts.


<hr>

<a name=/icon/proc/SetIntensity>
<h2>SetIntensity proc (icon)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/icon>icon</a>
<dd><a href=#/icon/proc>icon procs</a>
<dd><a href=#/icon/proc/MapColors>MapColors() proc (icon)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>SetIntensity(r,g=r,b=r)
</dl>

<dl><dt><b>Args:</b>
<dd>r: red component
<dd>g: green component
<dd>b: blue component
</dl>

<p>This multiplies the pixel intensities by the specified amounts.  A value
greater than 1.0 increases the intensity and a value less than 1.0 decreases
the intensity.

<hr>

<a name=/icon/proc/Shift>
<h2>Shift proc (icon)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/dir>dir var (atom)</a>
<dd><a href=#/icon>icon</a>
<dd><a href=#/icon/proc>icon procs</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Shift(dir,offset,wrap=0)
</dl>

<dl><dt><b>Args:</b>
<dd>dir: direction in which to shift the icon
<dd>offset: distance to shift the pixels
<dd>wrap: if true, causes shifted pixels to wrap around to the other side
</dl>

<p>This moves all of the pixels by the specified amount in a direction.  For
example, Shift(NORTH,1) would move everything one pixel to the north.

<p>By default, pixels that move off the edge are not wrapped around;
transparent pixels are shifted onto the other side.  Calling with wrap=1
causes it to shift the pixels around to the other side.

<hr>

<a name=/icon/proc/SwapColor>
<h2>SwapColor proc (icon)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/icon>icon</a>
<dd><a href=#/icon/proc>icon procs</a>
<dd><a href=#/proc/rgb>rgb proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>SwapColor(old_rgb,new_rgb)
  <br/><i>or</i><br/>
  SwapColor(old_rgba,new_rgba)
</dl>

<dl><dt><b>Args:</b>
<dd>old_rgba: the old rgba value to be replaced
<dd>new_rgba: the new rgba value to use in its place
</dl>

<p>This causes a color value in the icon's palette to be changed. You can use
null in place of an RGB or RGBA value.

<p>If the old color is a full RGBA color with an alpha value, such as
rgb(1,2,3,4) or "#01020304", then that exact color is the only one changed.

<p>If the old color is an RGB value with no alpha specified, such as
rgb(1,2,3) or "#010203", then that color will change to the new one
regardless of its alpha value, and the original icon's alpha will be kept
intact. (If the new color is totally transparent, however, then the old color
will be replaced with full transparency.)

<hr>

<a name=/icon/proc/Turn>
<h2>Turn proc (icon)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/icon/proc/Flip>Flip proc (icon)</a>
<dd><a href=#/atom/var/dir>dir var (atom)</a>
<dd><a href=#/icon>icon</a>
<dd><a href=#/icon/proc>icon procs</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Turn(angle)
</dl>

<dl><dt><b>Args:</b>
<dd>angle: an angle in degrees
</dl>

<p>This rotates the icon clockwise by the specified amount.

<h3>Example:</h3>
<xmp>
mob/verb/drink()
   //this effect is very confusing!
   var/icon/I = new(usr.icon)
   I.Turn(90)
   usr.icon = I
   usr << "You feel a little tipsy!"

   sleep(200)

   I.Turn(-90)  //turn it back
   usr.icon = I //should have just saved original value
</xmp>

<p>If an icon is not square, it cannot be turned.

<hr>

<a name=/icon/proc/Height>
<h2>Height proc (icon)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/icon>icon</a>
<dd><a href=#/icon/proc>icon procs</a>
<dd><a href=#/icon/proc/Width>Width proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Height()
</dl>

<p>This finds the height, in pixels, of the icon.

<hr>

<a name=/image>
<h2>image objects</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/icon>icon var (atom)</a>
<dd><a href=#/proc/image>image proc</a>
<dd><a href=#/image/var>image vars</a>
<dd><a href=#/client/var/images>images var (client)</a>
<dd><a href=#/atom/var/overlays>overlays var (atom)</a>
<dd><a href=#/atom/var/override>override var (atom)</a>
</dl>

<p>The /image type contains data used to create a virtual image.  Unlike other
atomic objects, this object is a purely visual effect.  It always appears
attached to some other object and it behaves in every way as though it were
part of that object (e.g. if the user clicks on it, this counts as a click on
the atomic object, not the image).

<p>One reason for creating images is player-by-player control over visibility.
Images only become visible when they are explicitly output to players:

<h3>Example:</h3>
<xmp>
var/image/I = image('icon.dmi',usr)  //make an image attached to usr
usr << I    //allow usr to see it
</xmp>

<p>Images are also useful in the creation of overlays.  Overlays are like
images, since they are always attached to another object, but overlays obey
the normal rules of visibility, so they are more convenient when you do not
want to hide the effect from anybody.  An overlay can be created directly from
an icon file (or icon state), but when one wishes to override some additional
parameter, the image() instruction is a convenient way to do it.

<h3>Example:</h3>
<xmp>
usr.overlays += image('shirt.dmi',icon_state = "red")
</xmp>

<p>In the above example, the icon state of an overlay was set by creating the
overlay from an image with the desired icon state.  Note that after the
creation of an overlay, no link remains between the overlay and the object
that was used to create it.  If you change the image after that time, it will
not change the overlay, which is simply a "snapshot" of the original image.

<hr>

<a name=/image/var>
<h2>image vars</h2>

<dl><dt>/image/var
<dd><a href=#/atom/var/alpha>alpha</a>
<dd><a href=#/atom/var/appearance>appearance</a>
<dd><a href=#/atom/var/appearance_flags>appearance_flags</a>
<dd><a href=#/atom/var/blend_mode>blend_mode</a>
<dd><a href=#/atom/var/color>color</a>
<dd><a href=#/atom/var/icon>icon</a>
<dd><a href=#/atom/var/icon_state>icon_state</a>
<dd><a href=#/atom/var/text>text</a>
<dd><a href=#/atom/var/dir>dir</a>
<dd><a href=#/atom/var/overlays>overlays</a>
<dd><a href=#/atom/var/underlays>underlays</a>
<dd><a href=#/image/var/loc>loc</a>
<dd><a href=#/atom/var/layer>layer</a>
<dd><a href=#/atom/var/maptext>maptext</a>
<dd><a href=#/atom/var/maptext_width>maptext_width</a>
<dd><a href=#/atom/var/maptext_height>maptext_height</a>
<dd><a href=#/atom/var/maptext_x>maptext_x</a>
<dd><a href=#/atom/var/maptext_y>maptext_y</a>
<dd><a href=#/atom/var/pixel_x>pixel_x</a>
<dd><a href=#/atom/var/pixel_y>pixel_y</a>
<dd><a href=#/atom/var/pixel_w>pixel_w</a>
<dd><a href=#/atom/var/pixel_z>pixel_z</a>
<dd><a href=#/atom/var/plane>plane</a>
<dd><a href=#/atom/var/x>x</a>
<dd><a href=#/atom/var/y>y</a>
<dd><a href=#/atom/var/z>z</a>
<dd><a href=#/atom/var/override>override</a>
<dd><a href=#/atom/var/transform>transform</a>
<dd><a href=#/datum/var/type>type</a>
<dd><a href=#/datum/var/parent_type>parent_type</a>
<dd><a href=#/datum/var/tag>tag</a>
</dl>

<hr>

<a name=/image/var/loc>
<h2>loc var (image)</h2>

<p>The location of an image specifies the object to which the image is
attached.  Unless the image drawing layer is specified, the default will make
it appear above this object, as though it were an overlay.

<p>Note that the image is not <em>inside</em> the specified location.  In
other words, this loc variable does not behave like /atom/movable/var/loc
which specifies the container object.  It is more like the image is on top of
the specified object.  If the object moves, the image will automatically move
around with it.

<hr>

<a name=/list>
<h2>list</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/list/associations>list associations</a>
<dd><a href=#/proc/list>list proc</a>
<dd><a href=#/list/proc>procs (list)</a>
<dd><a href=#/list/var>vars (list)</a>
</dl>

<p>Lists are used to represent groups of objects.  Like objects, they have
vars and procs associated with them.  In order to access these attributes,
list vars must be declared of type /list.  These may then be assigned to
existing lists, or used to create new lists.

<h3>Example:</h3>
<xmp>
var/list/L         // list reference
L = world.contents // assign to existing list
L = new/list()     // make a new list
L = new()          // make a new list (implicit type)
L.Add("futz")      // L contains: "futz"
del(L)             // delete L
</xmp>

<p>Lists created with 'new()' have a default length of 0; this can be
overridden by specifying the size; that is, new/list(size) creates a list
with size (null) elements.

<p>The 'list()' proc may be used to more easily initialize list data.

<h3>Example:</h3>
<xmp>
var/list/L
L = list("futz",3)   // L contains: ("futz", 3)
</xmp>

<p>Alternatively, lists may be declared by using brackets, '[]'.  Empty
brackets indicate a list reference, exactly as /list does, so list/L is
equivalent to L[].  Setting an initial size within the brackets, for
instance, L[10], creates a list of that initial size.

<h3>Example:</h3>
<xmp>
var/L[]   // same as var/list/L: list reference
var/M[10] // initially empty list of size 10
L = M     // L is now an empty list of size 10
</xmp>

<p>Once a list L is declared, a specific item can be accessed by putting its
index in the brackets: L[index].

<p>Indices range from 1 to len.  If the length of the list is changed,
existing elements in the list will be preserved if they are less than the
new length.  New elements in the list will be given the initial value of
null.

<h3>Example:</h3>
<xmp>
var/L[5]  // initial length of 5
var/i

for(i=1, i<=L.len, i++)
  L[i] = i
// L contains: (1,2,3,4,5)

L.len = 7           // expand list
// L contains: (1,2,3,4,5,null,null)

del(L)          // destroy list
</xmp>

<p>Multi-dimensional lists may be created by making a list of lists.

<h3>Example:</h3>
<xmp>
var/grid[10][5]
grid[1][1] = 1
grid[1][2] = 2
...
</xmp>

<p>Such a list may also be created by using new().  As in the previous
example, the next one creates a list of 10 lists each having 5 elements.

<h3>Example:</h3>
<xmp>
var/grid = new/list(10,5)
</xmp>

<hr>

<a name=/list/associations>
<h2>list associations</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/list>list</a>
<dd><a href=#/proc/list>list proc</a>
<dd><a href=#/proc/list2params>list2params proc</a>
<dd><a href=#/world/var/params>params var (world)</a>
<dd><a href=#/proc/params2list>params2list proc</a>
<dd><a href=#/datum/var/vars>vars list var (datum)</a>
</dl>

<p>Each unique text string or object in a list may be associated with another
value.  This is done by using the item as an index into the list.

<h3>Example:</h3>
<xmp>
var/params[0]

params["player"] = "James Byond"
params["score"] = 2000

//List now contains ("player","score")
//These are associated with ("James Byond",2000)

usr << "Looping through list items:"
var/p
for(p in params)
   usr << "[p] = [params[p]]"

usr << "Looping through array indices:"
var/i
for(i=1,i<=params.len,i++)
   p = params[i]
   usr << "[p] = [params[p]]"
</xmp>

<p>The above example illustrates the typical way in which list associations
are managed.  Note that an item in the list may be added by assigning its
associated value.  The example could have started by doing
<code>params.Add("player","score")</code>, but that would have been
redundant.

<p>Both <code>for</code> loops in the example have the same effect.  The
first one loops through each item in the list, and displays it along with
its associated value.  The second loop achieves the same thing by looping
through the numerical indices (referred to as <em>array</em> indices as
opposed to <em>associative</em> indices).

<p>Since numerical indices are treated differently, you may not assign an
associated value to a numerical list item.  Associations must have a text
string or object reference as the index item.

<p>Associated values default to null if none is assigned.  This is also the
value returned when the supplied index item does not exist in the list.  The
list defined above, for example, would return null for
<code>params["time"]</code>.

<p>The <code>list()</code> instruction may also be used to create associative
lists.

<h3>Example:</h3>
<xmp>
var/list/lst = list("player" = "James Byond", "score" = 2000)
</xmp>

<p>When the index values happen to be text strings that satisfy all the
requirements for variable names, this may also be written in a convenient
short-hand:

<xmp>
var/list/lst = list(player = "James Byond", score = 2000)
</xmp>

<p>In other words, this is exactly the same syntax as for
<a href=#/proc/arguments/named>named arguments</a>.

<hr>

<a name=/list/operators>
<h2>list operators</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/+>+ operator</a>
<dd><a href=#/operator/+=>+= operator</a>
<dd><a href=#/operator/->- operator</a>
<dd><a href=#/operator/-=>-= operator</a>
<dd><a href=#/operator/|>| operator</a>
<dd><a href=#/operator/|=>|= operator</a>
<dd><a href=#/operator/&>& operator</a>
<dd><a href=#/operator/&=>&= operator</a>
<dd><a href=#/operator/^>^ operator</a>
<dd><a href=#/operator/^=>^= operator</a>
<dd><a href=#/operator/in>in operator</a>
</dl>

<p>The operators listed above have special meaning when applied to lists.

<hr>

<a name=/list/proc>
<h2>procs (list)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/list>list</a>
<dd><a href=#/list/operators>list operators</a>
</dl>

<p>Built-in list procs:

<dl><dt>list/proc
<dd><a href=#/list/proc/Add>Add</a>
<dd><a href=#/list/proc/Copy>Copy</a>
<dd><a href=#/list/proc/Cut>Cut</a>
<dd><a href=#/list/proc/Find>Find</a>
<dd><a href=#/list/proc/Insert>Insert</a>
<dd><a href=#/list/proc/Join>Join</a>
<dd><a href=#/list/proc/Remove>Remove</a>
<dd><a href=#/list/proc/Swap>Swap</a>
</dl>

<hr>

<a name=/list/proc/Add>
<h2>Add proc (list)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/+>+ operator</a>
<dd><a href=#/list/proc/Remove>Remove proc (list)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>list.Add(Item1,Item2,...)
</dl>

<dl><dt><b>Args:</b>
<dd>One or more items to add to the list.
</dl>

<p>Appends the specified items to the list.  If an argument is itself a
list, each item in the list will be added.

<hr>

<a name=/list/proc/Copy>
<h2>Copy proc (list)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/list/proc/Cut>Cut proc (list)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>list.Copy(Start=1,End=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>A new list.
</dl>

<dl><dt><b>Args:</b>
<dd>Start: The list position in which to begin the copy.
<dd>End: The list position immediately following the last element to be
     copied.
</dl>

<p>Copy list[Start] through list[End-1] into a new list. The default end
position of 0 stands for the position immediately after the end of the list,
so by default the entire list is copied.

<hr>

<a name=/list/proc/Cut>
<h2>Cut proc (list)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/list/proc/Copy>Copy proc (list)</a>
<dd><a href=#/list/proc/Insert>Insert proc (list)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>list.Cut(Start=1,End=0)
</dl>

<dl><dt><b>Args:</b>
<dd>Start: The list position in which to begin the cut.
<dd>End: The list position immediately following the last element to be
     removed.
</dl>

<p>Remove the elements between list[Start] and list[End-1], decreasing the
size of the list appropriately.  The default end position of 0 stands for
the position immediately after the end of the list, so by default the entire
list is deleted.

<hr>

<a name=/list/proc/Find>
<h2>Find proc (list)</h2>

<dl><dt><b>Format:</b>
<dd>list.Find(Elem,Start=1,End=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>The first position of elem in list, or 0 if not found.
</dl>

<dl><dt><b>Args:</b>
<dd>Elem: The element to find.
<dd>Start: The list position in which to begin the search.
<dd>End: The list position immediately following the end of the search.
</dl>

<p>Find the first position of Elem in the list.  Elements between Start and
End are searched.  The default end position of 0 stands for the position
immediately after the end of the list, so by default the entire list is
searched.

<hr>

<a name=/list/proc/Insert>
<h2>Insert proc (list)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/list/proc/Cut>Cut proc (list)</a>
<dd><a href=#/list/proc/Copy>Copy proc (list)</a>
<dd><a href=#/list/proc/Swap>Swap proc (list)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>list.Insert(Index,Item1,Item2...)
</dl>

<dl><dt><b>Returns:</b>
<dd>The index following the inserted items.
</dl>

<dl><dt><b>Args:</b>
<dd>Index: The index where the new item will be inserted. Any value
  already at that index will be pushed forward.
<dd>Item1: A value or list of values to insert.
<dd>Item2...: (optional) Additional items to insert, immediately after the
  previous item(s).
</dl>

<p>Insert values into a list at a specific point. Using Index=0 or
Index=list.len+1 is the same as adding to the list.

<p>Note: This proc doesn't work with many special lists such as
<code>contents</code>.

<hr>

<a name=/list/proc/Join>
<h2>Join proc (list)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/jointext>jointext proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>list.Join(Glue,Start=1,End=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>A text string made up of the items in this list, joined together by Glue.
</dl>

<dl><dt><b>Args:</b>
<dd>Glue: The text that will go between each item.
<dd>Start: The list item on which to begin.
<dd>End: The list item immediately following the last item to be joined.
<dd>include_delimiters: True if any delimiters found should be included in
     the result.
</dl>

<p>This is exactly the same as calling jointext(List,Glue,Start,End), and
is provided for convenience.

<hr>

<a name=/list/proc/Remove>
<h2>Remove proc (list)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/->- operator</a>
<dd><a href=#/list/proc/Add>Add proc (list)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>list.Remove(Item1,Item2,...)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if any items removed, 0 if not.
</dl>

<dl><dt><b>Args:</b>
<dd>One or more items to remove from the list.
</dl>

<p>Removes the specified items from the list.  If an argument is itself a
list, each item contained in it will be removed.  Removal starts at the end
of the list (highest index) so that this operation is an exact reversal of
Add().

<hr>

<a name=/list/proc/Swap>
<h2>Swap proc (list)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/list/proc/Cut>Cut proc (list)</a>
<dd><a href=#/list/proc/Copy>Copy proc (list)</a>
<dd><a href=#/list/proc/Insert>Insert proc (list)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>list.Swap(Index1,Index2)
</dl>

<dl><dt><b>Returns:</b>
<dd>Nothing.
</dl>

<dl><dt><b>Args:</b>
<dd>Index1: The index (1 to list.len) of one of the items to swap.
<dd>Index2: The index of the other item.
</dl>

<p>Swap two items in a list. If the list has associated values, they
will be preserved. This is most useful for user-defined sorting routines.

<h3>Example:</h3>
<xmp>
var/item
var/list/L = list("orange" = 3, "green" = 2, "blue" = 5)
for(item in L) world << "[item] -> [L[item]]"
world << ""
L.Swap(1, 3)
for(item in L) world << "[item] -> [L[item]]"
</xmp>

<h3>Result:</h3>
<xmp>
orange -> 3
green -> 2
blue -> 5

blue -> 5
green -> 2
orange -> 3
</xmp>

<p>Note: This proc doesn't work with many special lists such as
<code>contents</code>.

<hr>

<a name=/list/var>
<h2>vars (list)</h2>

<p>Built-in list vars:

<dl><dt>list/var
<dd><a href=#/list/var/len>len</a>
</dl>

<hr>

<a name=/list/var/len>
<h2>len var (list)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/+>+ operator</a>
<dd><a href=#/operator/+=>+= operator</a>
<dd><a href=#/operator/->- operator</a>
<dd><a href=#/operator/-=>-= operator</a>
</dl>

<p>This is the length of the list. Increasing it expands the list,
initializing all new elements with null.  Decreasing it contracts the list,
making old elements inaccessible.

<hr>

<a name=/map>
<h2>map</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/preprocessor/include>#include directive</a>
<dd><a href=#/world/var/area>area var (world)</a>
<dd><a href=#/world/var/maxx>maxx var (world)</a>
<dd><a href=#/world/var/turf>turf var (world)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>#include "mapname.dmm"
</dl>

<p>One or more map files may be loaded into the world's map.  These are
loaded into successive z-levels.  If no map files are specified, the default
project map file will be used.  This file has the same name as the project
but has the extension .dmm.

<p>If no map files are loaded, the world's map size is determined by the
world variables maxx, maxy, and maxz.  The default content of this map is
determined by the world variables turf and area.

<h3>Example:</h3>
<xmp>
#include "level1.dmm"
#include "level2.dmm"
#include "level3.dmm"
</xmp>

<hr>

<a name=/matrix>
<h2>matrix</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/matrix/operators>matrix operators</a>
<dd><a href=#/matrix/proc>matrix procs</a>
<dd><a href=#/atom/var/transform>transform var (atom)</a>
<dd><a href=#/proc/matrix>matrix proc</a>
</dl>

<p>To display rotation, scaling, and other transformations on atoms, DM uses
matrices. The /matrix datum is a convenient way of handling the numbers
involved, as it can be easily manipulated. There are six vars, a through f,
laid out like so:

<xmp>          a d 0
x y 1  *  b e 0  =  x' y' 1
          c f 1</xmp>

<p>When an x,y point is multiplied by the matrix, it becomes the new point
x',y'. This is equivalent to:

<xmp>x' = a*x + b*y + c
y' = d*x + e*y + f</xmp>

<p>The default matrix is:

<xmp>1 0 0
0 1 0
0 0 1</xmp>

<p>Matrices are created with the matrix() proc, or by calling new/matrix().
(See the matrix() proc for examples.) They are also created as needed
whenever you read from atom.transform or use certain operators.

<p>Manipulation of matrices can be done with operators, or with procs. You
can do the following with them:

<ul>
<li><b>Multiply:</b> Multiplying two matrices together will chain together
the transformations they represent. For instance, a scaling matrix
multiplied by a rotation matrix says: Scale, then rotate. Multiplication of
two matrices is sensitive to the order you use.</li>
<li><b>Scale:</b> A simple scale matrix uses only the a and e values, to
scale x and y by a certain amount.</li>
<li><b>Rotate:</b> A rotation matrix can rotate an atom by whatever amount
you like.</li>
<li><b>Translate:</b> Translation is like a pixel offset, changing the atom's
position.</li>
<li><b>Interpolate:</b> You can calculate a matrix that lies somewhere
between two other matrices, which can be helpful for animation.</li>
</ul>

<p>When you've built your matrix, you can assign it to atom.transform to
change the way that atom is displayed.

<p>The matrices supported by this datum are <b>not</b> the same kind used to
transform colors, as in the atom.color var and icon.MapColors() proc.  For
color matrices, see <a href=#/{notes}/color-matrix>color matrix</a>.

<hr>

<a name=/matrix/operators>
<h2>matrix operators</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/matrix>matrix</a>
<dd><a href=#/matrix/proc>matrix procs</a>
</dl>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/+>+ operator</a>
<dd><a href=#/operator/+=>+= operator</a>
<dd><a href=#/operator/->- operator</a>
<dd><a href=#/operator/-=>-= operator</a>
<dd><a href=#/operator/*>* operator</a>
<dd><a href=#/operator/*=>*= operator</a>
<dd><a href=#/operator//>/ operator</a>
<dd><a href=#/operator//=>/= operator</a>
<dd><a href=#/operator/~>~ operator</a>
</dl>

<p>The operators listed above have special meaning when applied to matrices.

<p>The assignment operators will modify an existing matrix, and can also be
used directly with atom.transform. Other operators will create a new matrix.

<hr>

<a name=/matrix/proc>
<h2>matrix procs</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/matrix>matrix</a>
<dd><a href=#/matrix/operators>matrix operators</a>
<dd><a href=#/proc/turn/matrix>turn proc (applied to a matrix)</a>
</dl>

<dl><dt>matrix/proc
<dd><a href=#/proc/matrix>New</a>
<dd><a href=#/matrix/proc/Add>Add</a>
<dd><a href=#/matrix/proc/Interpolate>Interpolate</a>
<dd><a href=#/matrix/proc/Invert>Invert</a>
<dd><a href=#/matrix/proc/Multiply>Multiply</a>
<dd><a href=#/matrix/proc/Scale>Scale</a>
<dd><a href=#/matrix/proc/Subtract>Subtract</a>
<dd><a href=#/matrix/proc/Translate>Translate</a>
<dd><a href=#/matrix/proc/Turn>Turn</a>
</dl>

<hr>

<a name=/matrix/proc/Add>
<h2>Add proc (matrix)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/matrix>matrix</a>
<dd><a href=#/matrix/operators>matrix operators</a>
<dd><a href=#/matrix/proc>matrix procs</a>
<dd><a href=#/operator/+=>+= operator</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Add(Matrix2)
</dl>

<dl><dt><b>Args:</b>
<dd>Matrix2: another matrix
</dl>

<dl><dt><b>Return value:</b>
<dd>src
</dl>

<p>This adds Matrix2 to the current matrix.

<hr>

<a name=/matrix/proc/Interpolate>
<h2>Interpolate proc (matrix)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/matrix>matrix</a>
<dd><a href=#/matrix/operators>matrix operators</a>
<dd><a href=#/matrix/proc>matrix procs</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Interpolate(Matrix2, t)
</dl>

<dl><dt><b>Args:</b>
<dd>Matrix2: Another matrix
<dd>t: The interpolation factor: from 0 (src) to 1 (Matrix2). Usually this is a value between 0 and 1.
</dl>

<p>Calculates and returns a new matrix between src and Matrix2. If t is 0.5,
then the result will be exactly halfway between both matrices.

<p>There are many ways to interpolate matrices. Whenever possible, DM will
interpolate by doing scaling and/or shearing first, then rotation, then
translation. This is done by trying to find the angle of rotation of each
matrix first; a rotation of 180 is counted as a flip rather than a rotation.

<p>It is not strictly necessary for t to be between 0 and 1. Using a value
out of bounds will extrapolate a matrix, continuing the change as far as t.

<hr>

<a name=/matrix/proc/Invert>
<h2>Invert proc (matrix)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/matrix>matrix</a>
<dd><a href=#/matrix/operators>matrix operators</a>
<dd><a href=#/matrix/proc>matrix procs</a>
<dd><a href=#/operator/~>~ operator</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Invert()
</dl>

<dl><dt><b>Return value:</b>
<dd>src
</dl>

<p>This inverts the current matrix, if possible.

<p>Not all matrices can be inverted. If it's not possible, the matrix is said
to be degenerate. This happens if, for example, all of the values in the
matrix are zero. A degenerate matrix will not be changed by this proc.

<hr>

<a name=/matrix/proc/Multiply>
<h2>Multiply proc (matrix)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/matrix>matrix</a>
<dd><a href=#/matrix/operators>matrix operators</a>
<dd><a href=#/matrix/proc>matrix procs</a>
<dd><a href=#/operator/*>*= operator</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Multiply(Matrix2)<br/><i>or</i>
<dd>Multiply(n)
</dl>

<dl><dt><b>Args:</b>
<dd>Matrix2: another matrix
<dd>n: a number
</dl>

<dl><dt><b>Return value:</b>
<dd>src
</dl>

<p>This multiplies the current matrix by Matrix2 or n. If the n format is
used, this is just like scaling the whole matrix. If another matrix is
multiplied, then it is like doing the two transformations in order: src,
then Matrix2.

<p>Multiplication of one matrix by another depends on the order. You may
get a different result multiplying A * B vs. B * A.

<hr>

<a name=/matrix/proc/Scale>
<h2>Scale proc (matrix)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/matrix>matrix</a>
<dd><a href=#/matrix/operators>matrix operators</a>
<dd><a href=#/matrix/proc>matrix procs</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Scale(x,y)
</dl>

<dl><dt><b>Args:</b>
<dd>x: The amount of scaling to do in the x direction
<dd>y: The amount of scaling to do in the y direction
</dl>

<dl><dt><b>Return value:</b>
<dd>src
</dl>

<p>The matrix is scaled by the appropriate amounts.

<p>If y is omitted, x is used for both. E.g., Scale(2) is equivalent to
Scale(2,2).

<hr>

<a name=/matrix/proc/Subtract>
<h2>Subtract proc (matrix)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/matrix>matrix</a>
<dd><a href=#/matrix/operators>matrix operators</a>
<dd><a href=#/matrix/proc>matrix procs</a>
<dd><a href=#/operator/+=>-= operator</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Subtract(Matrix2)
</dl>

<dl><dt><b>Args:</b>
<dd>Matrix2: another matrix
</dl>

<dl><dt><b>Return value:</b>
<dd>src
</dl>

<p>This subtracts Matrix2 from the current matrix.

<hr>

<a name=/matrix/proc/Translate>
<h2>Translate proc (matrix)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/matrix>matrix</a>
<dd><a href=#/matrix/operators>matrix operators</a>
<dd><a href=#/matrix/proc>matrix procs</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Translate(x,y)
</dl>

<dl><dt><b>Args:</b>
<dd>x: The amount of scaling to do in the x direction
<dd>y: The amount of scaling to do in the y direction
</dl>

<dl><dt><b>Return value:</b>
<dd>src
</dl>

<p>The matrix is translated (moved) by the appropriate amounts. The x and y
offsets applied by translation are in pixels.

<p>If y is omitted, x is used for both. E.g., Translate(2) is equivalent to
Translate(2,2).

<hr>

<a name=/matrix/proc/Turn>
<h2>Turn proc (matrix)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/matrix>matrix</a>
<dd><a href=#/matrix/operators>matrix operators</a>
<dd><a href=#/matrix/proc>matrix procs</a>
<dd><a href=#/proc/turn/matrix>turn proc (applied to a matrix)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Turn(angle)
</dl>

<dl><dt><b>Args:</b>
<dd>angle: The angle of clockwise rotation, in degrees
</dl>

<dl><dt><b>Return value:</b>
<dd>src
</dl>

<p>The matrix is rotated clockwise, by the angle given.

<hr>

<a name=/mutable_appearance>
<h2>mutable appearance</h2>

<p>All atoms and images have an appearance, which is an immutable object
that can be shared by many atoms.  Making changes to an object's appearance
generates new appearances, many of which may be temporary.  For
high-performance games, this can be a drawback.  The /mutable_appearance type
exists so that you can make multiple changes to an appearance without
creating all the temporary objects, then turn it into a regular immutable
appearance when finished.

<p>A new mutable appearance is created via new/mutable_appearance, and giving
it an atom, image, or appearance as a source object.  Assigning it to an
object's appearance var will create a new immutable appearance.

<h3>Example:</h3>
<xmp>
mob/proc/GetAngry()
    var/mutable_appearance/ma = new(src)
    ma.color = rgb(51,255,51)   // green
    ma.transform = matrix(2,0,0,0,2,0)  // scale x2
    appearance = ma
</xmp>

<hr>

<a name=/mutable_appearance/var>
<h2>vars (mutable appearance)</h2>

<p>Built-in mutable appearance vars:

<dl><dt>mob/var
<dd><a href=#/atom/var/alpha>alpha</a>
<dd><a href=#/atom/var/appearance>appearance</a>
<dd><a href=#/atom/var/appearance_flags>appearance_flags</a>
<dd><a href=#/atom/var/blend_mode>blend_mode</a>
<dd><a href=#/atom/var/color>color</a>
<dd><a href=#/atom/var/density>density</a>
<dd><a href=#/atom/var/desc>desc</a>
<dd><a href=#/atom/var/dir>dir</a>
<dd><a href=#/atom/var/gender>gender</a>
<dd><a href=#/atom/var/icon>icon</a>
<dd><a href=#/atom/var/icon_state>icon_state</a>
<dd><a href=#/atom/var/invisibility>invisibility</a>
<dd><a href=#/atom/var/underlays>underlays</a>
<dd><a href=#/atom/var/overlays>overlays</a>
<dd><a href=#/atom/var/layer>layer</a>
<dd><a href=#/atom/var/luminosity>luminosity</a>
<dd><a href=#/atom/var/maptext>maptext</a>
<dd><a href=#/atom/var/maptext_width>maptext_width</a>
<dd><a href=#/atom/var/maptext_height>maptext_height</a>
<dd><a href=#/atom/var/maptext_x>maptext_x</a>
<dd><a href=#/atom/var/maptext_y>maptext_y</a>
<dd><a href=#/atom/movable/var/animate_movement>animate_movement</a>
<dd><a href=#/atom/var/mouse_over_pointer>mouse_over_pointer</a>
<dd><a href=#/atom/var/mouse_drag_pointer>mouse_drag_pointer</a>
<dd><a href=#/atom/var/mouse_drop_pointer>mouse_drop_pointer</a>
<dd><a href=#/atom/var/mouse_drop_zone>mouse_drop_zone var</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var</a>
<dd><a href=#/atom/var/name>name</a>
<dd><a href=#/atom/var/opacity>opacity</a>
<dd><a href=#/atom/var/pixel_x>pixel_x</a>
<dd><a href=#/atom/var/pixel_y>pixel_y</a>
<dd><a href=#/atom/var/pixel_w>pixel_w</a>
<dd><a href=#/atom/var/pixel_z>pixel_z</a>
<dd><a href=#/atom/var/plane>plane</a>
<dd><a href=#/atom/var/suffix>suffix</a>
<dd><a href=#/atom/var/text>text</a>
<dd><a href=#/atom/var/transform>transform</a>
<dd><a href=#/atom/var/verbs>verbs</a>
</dl>

<hr>

<a name=/mob>
<h2>mob</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom>atom</a>
<dd><a href=#/atom/movable>movable atoms</a>
<dd><a href=#/mob/proc>procs (mob)</a>
<dd><a href=#/mob/var>vars (mob)</a>
</dl>

<p>Mobs are "mobile objects" derived from /mob.  Human players are
associated with a mob when they log on.

<h3>Example:</h3>
<xmp>
mob
  guzzler
    desc = "Mean, mad, and wicked bad."
</xmp>

<p>This example defines the mob type /mob/guzzler.

<hr>

<a name=/mob/proc>
<h2>procs (mob)</h2>

<p>Built-in mob procs:

<dl><dt>mob/proc
<dd><a href=#/atom/movable/proc/Bump>Bump</a>
<dd><a href=#/atom/proc/Click>Click</a>
<dd><a href=#/atom/proc/DblClick>DblClick</a>
<dd><a href=#/datum/proc/Del>Del</a>
<dd><a href=#/atom/proc/Enter>Enter</a>
<dd><a href=#/atom/proc/Entered>Entered</a>
<dd><a href=#/atom/proc/Exit>Exit</a>
<dd><a href=#/atom/proc/Exited>Exited</a>
<dd><a href=#/mob/proc/Login>Login</a>
<dd><a href=#/mob/proc/Logout>Logout</a>
<dd><a href=#/atom/proc/MouseDown>MouseDown</a>
<dd><a href=#/atom/proc/MouseDrag>MouseDrag</a>
<dd><a href=#/atom/proc/MouseDrop>MouseDrop</a>
<dd><a href=#/atom/proc/MouseEntered>MouseEntered</a>
<dd><a href=#/atom/proc/MouseExited>MouseExited</a>
<dd><a href=#/atom/proc/MouseMove>MouseMove</a>
<dd><a href=#/atom/proc/MouseUp>MouseUp</a>
<dd><a href=#/atom/proc/MouseWheel>MouseWheel</a>
<dd><a href=#/atom/movable/proc/Move>Move</a>
<dd><a href=#/atom/proc/New>New</a>
<dd><a href=#/datum/proc/Read>Read</a>
<dd><a href=#/atom/proc/Stat>Stat</a>
<dd><a href=#/datum/proc/Topic>Topic</a>
<dd><a href=#/datum/proc/Write>Write</a>
</dl>

<hr>

<a name=/mob/proc/Login>
<h2>Login proc (mob)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/mob/proc/Logout>Logout proc (mob)</a>
<dd><a href=#/mob/var/client>client var (mob)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Login()
</dl>

<dl><dt><b>When:</b>
<dd>Called when a player's client tries to connect to a mob.  This is called
    by default from client.New(), when the player logs into the world.
</dl>

<dl><dt><b>Default action:</b>
<dd>If the mob has no location, place it near (1,1,1) if possible.  Change
     the player's stat object (client.statobj) to the mob.
</dl>

<p>One can typically tell if a player is connecting to a fresh mob versus
reconnecting to an existing one by testing if the mob's location is null.

<hr>

<a name=/mob/proc/Logout>
<h2>Logout proc (mob)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/mob/proc/Login>Login proc (mob)</a>
<dd><a href=#/mob/var/client>client var (mob)</a>
<dd><a href=#/mob/var/key>key var (mob)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Logout()
</dl>

<dl><dt><b>When:</b>
<dd>Called when a player's client has disconnected from a mob.  This happens
    in client.Del() when the player logs out of the world.  It may also
    happen when the player switches from one mob to another.
</dl>

<dl><dt><b>Default action:</b>
<dd>None.
</dl>

<p>One may wish to distinguish between a player who has disconnected from
the game and one who is simply switching from one mob to another.  In the
case of a player switching to another mob, by the time <code>Logout()</code>
is called, the original mob's key will be null, whereas the key will still
be non-null in the case of a player disconnecting from the game.

<hr>

<a name=/mob/var>
<h2>vars (mob)</h2>

<p>Built-in mob vars:

<dl><dt>mob/var
<dd><a href=#/atom/var/alpha>alpha</a>
<dd><a href=#/atom/var/appearance>appearance</a>
<dd><a href=#/atom/var/appearance_flags>appearance_flags</a>
<dd><a href=#/atom/var/blend_mode>blend_mode</a>
<dd><a href=#/mob/var/ckey>ckey</a>
<dd><a href=#/mob/var/client>client</a>
<dd><a href=#/atom/var/color>color</a>
<dd><a href=#/atom/var/contents>contents</a>
<dd><a href=#/atom/var/density>density</a>
<dd><a href=#/atom/var/desc>desc</a>
<dd><a href=#/atom/var/dir>dir</a>
<dd><a href=#/atom/var/gender>gender</a>
<dd><a href=#/mob/var/group>group</a>
<dd><a href=#/atom/var/icon>icon</a>
<dd><a href=#/atom/var/icon_state>icon_state</a>
<dd><a href=#/atom/var/invisibility>invisibility</a>
<dd><a href=#/atom/var/underlays>underlays</a>
<dd><a href=#/atom/var/overlays>overlays</a>
<dd><a href=#/mob/var/key>key</a>
<dd><a href=#/atom/var/layer>layer</a>
<dd><a href=#/atom/var/luminosity>luminosity</a>
<dd><a href=#/atom/var/maptext>maptext</a>
<dd><a href=#/atom/var/maptext_width>maptext_width</a>
<dd><a href=#/atom/var/maptext_height>maptext_height</a>
<dd><a href=#/atom/var/maptext_x>maptext_x</a>
<dd><a href=#/atom/var/maptext_y>maptext_y</a>
<dd><a href=#/atom/movable/var/animate_movement>animate_movement</a>
<dd><a href=#/atom/var/loc>loc</a>
<dd><a href=#/atom/var/mouse_over_pointer>mouse_over_pointer</a>
<dd><a href=#/atom/var/mouse_drag_pointer>mouse_drag_pointer</a>
<dd><a href=#/atom/var/mouse_drop_pointer>mouse_drop_pointer</a>
<dd><a href=#/atom/var/mouse_drop_zone>mouse_drop_zone var</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var</a>
<dd><a href=#/atom/var/name>name</a>
<dd><a href=#/atom/var/opacity>opacity</a>
<dd><a href=#/mob/var/parent_type>parent_type</a>
<dd><a href=#/atom/var/pixel_x>pixel_x</a>
<dd><a href=#/atom/var/pixel_y>pixel_y</a>
<dd><a href=#/atom/var/pixel_w>pixel_w</a>
<dd><a href=#/atom/var/pixel_z>pixel_z</a>
<dd><a href=#/atom/var/plane>plane</a>
<dd><a href=#/mob/var/see_infrared>see_infrared</a>
<dd><a href=#/mob/var/see_invisible>see_invisible</a>
<dd><a href=#/mob/var/see_in_dark>see_in_dark</a>
<dd><a href=#/mob/var/sight>sight</a>
<dd><a href=#/atom/var/suffix>suffix</a>
<dd><a href=#/datum/var/tag>tag</a>
<dd><a href=#/atom/var/text>text</a>
<dd><a href=#/atom/var/transform>transform</a>
<dd><a href=#/datum/var/type>type</a>
<dd><a href=#/datum/var/vars>vars</a>
<dd><a href=#/atom/var/verbs>verbs</a>
<dd><a href=#/atom/var/x>x</a>
<dd><a href=#/atom/var/y>y</a>
<dd><a href=#/atom/var/z>z</a>
</dl>

<hr>

<a name=/mob/var/ckey>
<h2>ckey var (mob)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/ckey>ckey proc</a>
<dd><a href=#/mob/var/key>key var (mob)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>null
</dl>

<p>This is the value of mob.key converted to canonical form (ie the form
returned by the ckey() proc).  Among other things, this could be used as a
unique directory name in a server-side save file for storing player
information.  See the ckey() proc for an example.

<hr>

<a name=/mob/var/client>
<h2>client var (mob)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client>client</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>null
</dl>

<p>This is a reference to a set of properties specific to the player.
Therefore non-player mobs (NPCs) do not have a client (client = null).

<p>Setting a mob's client connects that player's client to the mob.

<hr>

<a name=/mob/var/group>
<h2>group list var (mob)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/movable/proc/Bump>Bump proc (movable atom)</a>
<dd><a href=#/list>list</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>(empty list)
</dl>

<p>This is a list of mobs in the same group.  By default, a mob will swap
positions with another mob in its group if bumped.  It is also possible to
make verbs that are accessible only to members of the group.

<p>The following example handles addition of somebody else to your group.

<h3>Example:</h3>
<xmp>
mob/verb/join(mob/M)
   usr.group.Add(M)    // add M to usr's group
   view() << "[usr] joins [M]."
mob/verb/disband(mob/M)
   usr.group.Remove(M) // remove M from group
   view() << "[usr] disbands [M]."
</xmp>

<p>Note that group lists may be asymmetric.  Mob A may have mob B in his group
list, but mob B may or may not.  It is up to you to define whether mobs are
added into both lists or not.

<p>Here is an example of a verb accessible to a group:

<h3>Example:</h3>
<xmp>
mob/verb/summon()
   set src in usr.group
   loc = usr.loc
   view() << "[usr] summons [src]."
</xmp>

<hr>

<a name=/mob/var/key>
<h2>key var (mob)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/mob/var/ckey>ckey var (mob)</a>
<dd><a href=#/client>client</a>
<dd><a href=#/client/var/key>key var (client)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>null
</dl>

<p>For player mobs (PCs) this is the value of the player's key.  For
non-player mobs (NPCs), this is the value of the "desired" key.  This means
that if a player with that key logs into the world, he will be connected to
that mob (as opposed to a new one of type world.mob).

<p>Setting the mob's key will cause a client with the same key to connect to
the mob.  Any other mob with the same key will lose it.

<p>Key values are always compared in canonical form (ie the form returned by
ckey()) so setting a mob's key to "Dan", "dan" are equivalent as far as
controlling player linkage.

<hr>

<a name=/mob/var/parent_type>
<h2>parent_type var (mob)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/datum/var/parent_type>parent_type var</a>
</dl>

<p>The default parent_type of <a href=#/mob>/mob</a> is
<a href=#/atom/movable>/atom/movable</a>.

<hr>

<a name=/mob/var/see_in_dark>
<h2>see_in_dark var (mob)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/luminosity>luminosity var (atom)</a>
<dd><a href=#/mob/var/see_infrared>see_infrared var (mob)</a>
<dd><a href=#/mob/var/see_invisible>see_invisible var (mob)</a>
<dd><a href=#/mob/var/sight>sight var (mob)</a>
<dd><a href=#/proc/view>view proc</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>2
</dl>

<p>This determines how far the mob can see in the dark.  The scale is just
like luminosity: a value of 1 illuminates the mob and its location; 2
illuminates the immediate surrounds; and so on.

<hr>

<a name=/mob/var/see_infrared>
<h2>see_infrared var (mob)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/infra_luminosity>infra_luminosity var (atom)</a>
<dd><a href=#/mob/var/see_in_dark>see_in_dark var (mob)</a>
<dd><a href=#/mob/var/see_invisible>see_invisible var (mob)</a>
<dd><a href=#/mob/var/sight>sight var (mob)</a>
<dd><a href=#/proc/view>view proc</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>Setting this to 1 enables infravision, allowing the mob to see infrared
objects in the dark.

<hr>

<a name=/mob/var/see_invisible>
<h2>see_invisible var (mob)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/invisibility>invisibility var (atom)</a>
<dd><a href=#/mob/var/see_in_dark>see_in_dark var (mob)</a>
<dd><a href=#/mob/var/see_infrared>see_infrared var (mob)</a>
<dd><a href=#/mob/var/sight>sight var (mob)</a>
<dd><a href=#/proc/view>view proc</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>This is the maximum level of invisibility that the mob can see.

<hr>

<a name=/mob/var/sight>
<h2>sight var (mob)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/verb/set/invisibility>invisibility setting (verb)</a>
<dd><a href=#/atom/var/invisibility>invisibility var (atom)</a>
<dd><a href=#/mob/var/see_in_dark>see_in_dark var (mob)</a>
<dd><a href=#/mob/var/see_infrared>see_infrared var (mob)</a>
<dd><a href=#/mob/var/see_invisible>see_invisible var (mob)</a>
<dd><a href=#/proc/view>view proc</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>This controls which objects on the map the mob can see.  The default
value of 0 means that the mob can see all objects that are visible and lit.
Different flags in this var can be set to extend or limit this range.

<p>The following bit flags are encoded in mob.sight:

<xmp>
SEE_INFRA // can see infra-red objects
SEE_SELF  // can see self, no matter what
SEE_MOBS  // can see all mobs, no matter what
SEE_OBJS  // can see all objs, no matter what
SEE_TURFS // can see all turfs (and areas), no matter what
SEE_PIXELS// if an object is located on an unlit area, but some of its pixels are
          // in a lit area (via pixel_x,y or smooth movement), can see those pixels
SEE_THRU  // can see through opaque objects
SEE_BLACKNESS // render dark tiles as blackness
BLIND     // can't see anything
</xmp>

<h3>Example:</h3>
<xmp>
usr.sight |= BLIND     // turn on the blind bit
usr.sight &= ~BLIND    // turn off the blind bit
usr.sight |= (SEE_MOBS|SEE_OBJS|SEE_TURFS)  // turn on several bits at once
usr.sight &= ~(SEE_MOBS|SEE_OBJS|SEE_TURFS) // turn off several bits at once
</xmp>

<p>SEE_PIXELS draws everything and then covers hidden turfs with blackness.
It is supported in topdown maps only, not in SIDE_MAP or ISOMETRIC_MAP
formats. It does not mix well with other flags.  In practice, SEE_PIXELS acts
as if SEE_BLACKNESS, SEE_TURFS, SEE_OBJS, and SEE_MOBS are all turned on.
That is, all atoms are drawn even on hidden tiles, and black squares are also
drawn to cover them.

<p>The black tiles rendered by SEE_BLACKNESS and SEE_PIXELS are drawn on the
default plane 0.

<hr>

<a name=/obj>
<h2>obj</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom>atom</a>
<dd><a href=#/atom/movable>movable atoms</a>
<dd><a href=#/obj/proc>procs (obj)</a>
<dd><a href=#/obj/var>vars (obj)</a>
</dl>

<p>Objects are derived from /obj.

<p>The following example defines the obj type /obj/scooper.

<h3>Example:</h3>
<xmp>
obj
  scooper
    desc = "Super pooper scooper."
</xmp>

<hr>

<a name=/obj/proc>
<h2>procs (obj)</h2>

<p>Built-in obj procs:

<dl><dt>obj/proc
<dd><a href=#/atom/movable/proc/Bump>Bump</a>
<dd><a href=#/atom/proc/Click>Click</a>
<dd><a href=#/atom/proc/DblClick>DblClick</a>
<dd><a href=#/datum/proc/Del>Del</a>
<dd><a href=#/atom/proc/Enter>Enter</a>
<dd><a href=#/atom/proc/Entered>Entered</a>
<dd><a href=#/atom/proc/Exit>Exit</a>
<dd><a href=#/atom/proc/Exited>Exited</a>
<dd><a href=#/atom/proc/MouseDown>MouseDown</a>
<dd><a href=#/atom/proc/MouseDrag>MouseDrag</a>
<dd><a href=#/atom/proc/MouseDrop>MouseDrop</a>
<dd><a href=#/atom/proc/MouseEntered>MouseEntered</a>
<dd><a href=#/atom/proc/MouseExited>MouseExited</a>
<dd><a href=#/atom/proc/MouseMove>MouseMove</a>
<dd><a href=#/atom/proc/MouseUp>MouseUp</a>
<dd><a href=#/atom/proc/MouseWheel>MouseWheel</a>
<dd><a href=#/atom/movable/proc/Move>Move</a>
<dd><a href=#/atom/proc/New>New</a>
<dd><a href=#/datum/proc/Read>Read</a>
<dd><a href=#/atom/proc/Stat>Stat</a>
<dd><a href=#/datum/proc/Topic>Topic</a>
<dd><a href=#/datum/proc/Write>Write</a>
</dl>

<hr>

<a name=/obj/var>
<h2>vars (obj)</h2>

<p>Built-in obj vars:

<dl><dt>obj/var
<dd><a href=#/atom/var/alpha>alpha</a>
<dd><a href=#/atom/var/appearance>appearance</a>
<dd><a href=#/atom/var/appearance_flags>appearance_flags</a>
<dd><a href=#/atom/var/blend_mode>blend_mode</a>
<dd><a href=#/atom/var/color>color</a>
<dd><a href=#/atom/var/contents>contents</a>
<dd><a href=#/atom/var/density>density</a>
<dd><a href=#/atom/var/desc>desc</a>
<dd><a href=#/atom/var/dir>dir</a>
<dd><a href=#/atom/var/gender>gender</a>
<dd><a href=#/atom/var/icon>icon</a>
<dd><a href=#/atom/var/icon_state>icon_state</a>
<dd><a href=#/atom/var/invisibility>invisibility</a>
<dd><a href=#/atom/var/underlays>underlays</a>
<dd><a href=#/atom/var/overlays>overlays</a>
<dd><a href=#/atom/var/layer>layer</a>
<dd><a href=#/atom/var/luminosity>luminosity</a>
<dd><a href=#/atom/var/maptext>maptext</a>
<dd><a href=#/atom/var/maptext_width>maptext_width</a>
<dd><a href=#/atom/var/maptext_height>maptext_height</a>
<dd><a href=#/atom/var/maptext_x>maptext_x</a>
<dd><a href=#/atom/var/maptext_y>maptext_y</a>
<dd><a href=#/atom/movable/var/animate_movement>animate_movement</a>
<dd><a href=#/atom/var/loc>loc</a>
<dd><a href=#/atom/var/mouse_over_pointer>mouse_over_pointer</a>
<dd><a href=#/atom/var/mouse_drag_pointer>mouse_drag_pointer</a>
<dd><a href=#/atom/var/mouse_drop_pointer>mouse_drop_pointer</a>
<dd><a href=#/atom/var/mouse_drop_zone>mouse_drop_zone var</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var</a>
<dd><a href=#/atom/var/name>name</a>
<dd><a href=#/atom/var/opacity>opacity</a>
<dd><a href=#/obj/var/parent_type>parent_type</a>
<dd><a href=#/atom/var/pixel_x>pixel_x</a>
<dd><a href=#/atom/var/pixel_y>pixel_y</a>
<dd><a href=#/atom/var/pixel_w>pixel_w</a>
<dd><a href=#/atom/var/pixel_z>pixel_z</a>
<dd><a href=#/atom/var/plane>plane</a>
<dd><a href=#/atom/var/suffix>suffix</a>
<dd><a href=#/datum/var/tag>tag</a>
<dd><a href=#/atom/var/text>text</a>
<dd><a href=#/atom/var/transform>transform</a>
<dd><a href=#/datum/var/type>type</a>
<dd><a href=#/datum/var/vars>vars</a>
<dd><a href=#/atom/var/verbs>verbs</a>
<dd><a href=#/atom/var/x>x</a>
<dd><a href=#/atom/var/y>y</a>
<dd><a href=#/atom/var/z>z</a>
</dl>

<hr>

<a name=/obj/var/parent_type>
<h2>parent_type var (obj)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/datum/var/parent_type>parent_type var</a>
</dl>

<p>The default parent_type of <a href=#/obj>/obj</a> is
<a href=#/atom/movable>/atom/movable</a>.

<hr>

<a name=/operator>
<h2>operators</h2>

<p>Operators are used extensively in DM to compute numerical values.

<p>The DM operators are:

<xmp>
[] () . / :
~ ! - ++ --
**
* / %
+ -
< <= > >=
<< >>
== != <>
& ^ |
&&
||
?
= += -= *= /= &= |= ^= <<= >>=
</xmp>

<p>Each line has higher order of operations than the next.  Operators within
a line have equal precedence and therefore are processed from left to right
as they occur in an expression.

<p>To see an individual reference section, look up /operator/=, /operator/!,
etc.

<p>Expressions of the form: A #= B are shorthand for:  A = A # B

<h3>Example:</h3>
<xmp>
var/N
N = 0                          // 0
N += 1+1*2                     // 3
if(1 + 1 == 2) N = 2           // 2
if(N==2 && 1/2==0.5) N = 0.5   // 0.5
</xmp>

<hr>

<a name=/operator/!>
<h2>! operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&&>&& operator</a>
<dd><a href=#/operator>operators</a>
<dd><a href=#/operator/||>|| operator</a>
</dl>

<dl><dt><b>Format:</b>
<dd>!A
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if A is a false value (zero, an empty string, or null); 0 otherwise.
</dl>

<hr>

<a name=/operator/!=>
<h2>!= operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&gt;>&gt; operator</a>
<dd><a href=#/operator/&lt;>&lt; operator</a>
<dd><a href=#/operator/&lt;&gt;>&lt;&gt; operator</a>
<dd><a href=#/operator/==>== operator</a>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A != B
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if A is not equal to B; 0 otherwise
</dl>

<p>This is identical to the &lt;&gt; operator.

<hr>

<a name=/operator/%>
<h2>% operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/%=>%= operator</a>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A % B
</dl>

<dl><dt><b>Returns:</b>
<dd>The remainder of A / B.
</dl>

<p>A % B is read "A modulo B", which stands for the remainder of A divided
by B.

<hr>

<a name=/operator/%=>
<h2>%= operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/%>% operator</a>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A %= B
</dl>

<p>Set A equal to A % B.  It is shorthand for A = A % B.

<p>A % B is read "A modulo B", which stands for the remainder of A divided
by B.

<hr>

<a name=/operator/&>
<h2>& operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&=>&= operator</a>
<dd><a href=#/operator>operators</a>
<dd><a href=#/operator/|>| operator</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A & B
</dl>

<dl><dt><b>Returns:</b>
<dd>The binary "and" of A and B.
</dl>

<p>A and B must be between 0 and 65535 (2**16 - 1), giving an effective
width of 16 bits.

<p>If A and B are lists, the result is a list that contains only items that
were in both lists, in the order of list A.

<p>If A is an icon or /icon datum, it is blended with B which can be either
a color or another icon. This is identical to the + operator. Transparent
areas in either icon will be transparent in the result.

<hr>

<a name=/operator/&&>
<h2>&& operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/!>! operator</a>
<dd><a href=#/operator>operators</a>
<dd><a href=#/operator/||>|| operator</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A && B
</dl>

<dl><dt><b>Returns:</b>
<dd>True value if both A and B are true (neither zero, an empty string, nor null); the first false value otherwise
</dl>

<p>The first false value from left to right completes the evaluation (a
practice known as short-circuiting).  The return value is equal to the last
argument to be evaluated.

<hr>

<a name=/operator/&=>
<h2>&= operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&>& operator</a>
<dd><a href=#/operator>operators</a>
<dd><a href=#/operator/|=>|= operator</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A &= B
</dl>

<p>Set A equal to A & B.  It is shorthand for A = A & B.

<p>This is commonly used to turn off certain bitfields in a word.

<h3>Example:</h3>
<xmp>
usr.sight &= ~BLIND // turn off the blind bit
</xmp>

<p>If A and B are lists, items in A that are not in B are removed.

<p>If A is an /icon or /matrix datum, the datum will be changed rather than
creating a new one and re-assigning it to A.

<hr>

<a name=/operator/&gt;>
<h2>&gt; operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&gt;=>&gt;= operator</a>
<dd><a href=#/operator/&lt;>&lt; operator</a>
<dd><a href=#/operator/==>== operator</a>
<dd><a href=#/operator>operators</a>
<dd><a href=#/proc/sorttextEx>sorttextEx proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A &gt; B
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if A is greater than B; 0 otherwise.
</dl>

<p>If A and B are text strings, a case sensitive comparison is performed
(like sorttextEx()).

<hr>

<a name=/operator/&gt;&gt;>
<h2>&gt;&gt; operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&gt;&gt;/input>&gt;&gt; input operator</a>
<dd><a href=#/savefile/operator/&gt;&gt;>&gt;&gt; operator (savefile)</a>
<dd><a href=#/operator/&gt;&gt;/shift>&gt;&gt; shift operator</a>
</dl>

<hr>

<a name=/operator/&gt;&gt;/input>
<h2>&gt;&gt; input operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/savefile/operator/&gt;&gt;>&gt;&gt; operator (savefile)</a>
<dd><a href=#/proc/file>file proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>F &gt;&gt; Var
</dl>

<p>Cause input to be read from a file into a variable.  The file may be a
savefile or a file object corresponding to a text file.

<hr>

<a name=/operator/&gt;&gt;/shift>
<h2>&gt;&gt; shift operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&gt;&gt;=>&gt;&gt;= operator</a>
<dd><a href=#/operator/&lt;&lt;/shift>&lt;&lt; shift operator</a>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A &gt;&gt; B
</dl>

<dl><dt><b>Returns:</b>
<dd>The bits of A shifted right B times.
</dl>

<p>A and B must be between 0 and 65535 (2**16 - 1), giving an effective
width of 16 bits.

<p>Bits shifted below the 16 low bits are lost.

<hr>

<a name=/operator/&gt;&gt;=>
<h2>&gt;&gt;= operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&gt;&gt;/shift>&gt;&gt; shift operator</a>
<dd><a href=#/operator/&lt;&lt;=>&lt;&lt;= operator</a>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A &gt;&gt;= B
</dl>

<p>Set A equal to A >> B.  It is shorthand for A = A >> B.

<hr>

<a name=/operator/&gt;=>
<h2>&gt;= operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&gt;>&gt; operator</a>
<dd><a href=#/operator/&lt;>&lt; operator</a>
<dd><a href=#/operator/==>== operator</a>
<dd><a href=#/operator>operators</a>
<dd><a href=#/proc/sorttextEx>sorttextEx proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A &gt;= B
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if A is greater or equal to B; 0 otherwise.
</dl>

<p>If A and B are text strings, a case sensitive comparison is performed
(like sorttextEx()).

<hr>

<a name=/operator/&lt;>
<h2>&lt; operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&lt;>&lt; operator</a>
<dd><a href=#/operator/&lt;=>&lt;= operator</a>
<dd><a href=#/operator/==>== operator</a>
<dd><a href=#/operator>operators</a>
<dd><a href=#/proc/sorttextEx>sorttextEx proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A &lt; B
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if A is less than B; 0 otherwise.
</dl>

<p>If A and B are text strings, a case sensitive comparison is performed
(like sorttextEx()).

<hr>

<a name=/operator/&lt;&gt;>
<h2>&lt;&gt; operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/!=>!= operator</a>
<dd><a href=#/operator/&gt;>&gt; operator</a>
<dd><a href=#/operator/&lt;>&lt; operator</a>
<dd><a href=#/operator/==>== operator</a>
<dd><a href=#/operator>operators</a>
<dd><a href=#/proc/sorttextEx>sorttextEx proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A &lt;&gt; B
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if A is not equal to B; 0 otherwise
</dl>

<p>This is identical to the != operator.

<hr>

<a name=/operator/&lt;&lt;>
<h2>&lt;&lt; operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/savefile/operator/&lt;&lt;>&lt;&lt; operator (savefile)</a>
<dd><a href=#/operator/&lt;&lt;/output>&lt;&lt; output operator</a>
<dd><a href=#/operator/&lt;&lt;/shift>&lt;&lt; shift operator</a>
</dl>

<hr>

<a name=/operator/&lt;&lt;/output>
<h2>&lt;&lt; output operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/savefile/operator/&lt;&lt;>&lt;&lt; operator (savefile)</a>
<dd><a href=#/proc/output>output proc</a>
<dd><a href=#/proc/browse>browse proc</a>
<dd><a href=#/proc/browse_rsc>browse_rsc proc</a>
<dd><a href=#/proc/file>file proc</a>
<dd><a href=#/proc/ftp>ftp proc</a>
<dd><a href=#/proc/image>image proc</a>
<dd><a href=#/proc/link>link proc</a>
<dd><a href=#/proc/run>run proc</a>
<dd><a href=#/proc/sound>sound proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A &lt;&lt; B
</dl>

<p>Cause the value B to be output to any players connected to mobs specified
in A.

<p>B may be an image, sound, or text.  A may be a mob, the whole world, or
any list containing mobs.

<h3>Example:</h3>
<xmp>
usr << "Hi, [usr.name]"
view() << "To all in view"
world << "Hi everybody!"

usr << 'giggle.wav'
view() << image(/obj/Fireball,usr)
</xmp>

<hr>

<a name=/operator/&lt;&lt;/shift>
<h2>&lt;&lt; shift operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&gt;&gt;>&gt;&gt; operator</a>
<dd><a href=#/operator/&lt;&lt;=>&lt;&lt;= operator</a>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A &lt;&lt; B
</dl>

<dl><dt><b>Returns:</b>
<dd>The bits of A shifted left B times.
</dl>

<p>A and B must be between 0 and 65535 (2**16 - 1), giving an effective
width of 16 bits.

<p>Bits shifted beyond the 16 low bits are lost.

<hr>

<a name=/operator/&lt;&lt;=>
<h2>&lt;&lt;= operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&gt;&gt;=>&gt;&gt;= operator</a>
<dd><a href=#/operator/&lt;&lt;/shift>&lt;&lt; shift operator</a>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A &lt;&lt;= B
</dl>

<p>Set A equal to A << B.  It is shorthand for A = A << B.

<hr>

<a name=/operator/&lt;=>
<h2>&lt;= operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&gt;>&gt; operator</a>
<dd><a href=#/operator/&lt;>&lt; operator</a>
<dd><a href=#/operator/==>== operator</a>
<dd><a href=#/operator>operators</a>
<dd><a href=#/proc/sorttextEx>sorttextEx proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A &lt;= B
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if A is less than or equal to B; 0 otherwise.
</dl>

<p>If A and B are text strings, a case sensitive comparison is performed
(like sorttextEx()).

<hr>

<a name=/operator/()>
<h2>() operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator>operators</a>
<dd><a href=#/proc>procs</a>
<dd><a href=#/verb>verbs</a>
</dl>

<p>This is used to call procs and verbs.  It may also be used in expressions
to force the contained expression to be evaluated first.

<h3>Example:</h3>
<xmp>
usr << 2 + 3 * 2   //8
usr <<(2 + 3)* 2   //10
</xmp>

<hr>

<a name=/operator/*>
<h2>* operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/*=>*= operator</a>
<dd><a href=#/operator/+>+ operator</a>
<dd><a href=#/operator/->- operator</a>
<dd><a href=#/operator//>/ operator</a>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A * B
</dl>

<dl><dt><b>Returns:</b>
<dd>The product of A and B.
</dl>

<p>If A is an icon, the result is a new icon with B (a number, color, or
another icon) multiplied. This works with the /icon datum as well.

<p>If A is a /matrix datum, the result is a new matrix. B can be a number
(which scales the whole matrix) or another matrix. Multiplying two matrices
together can have different results depending on the order.

<hr>

<a name=/operator/**>
<h2>** operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/log>log proc</a>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A ** B
</dl>

<dl><dt><b>Returns:</b>
<dd>A to the power of B.
</dl>

<h3>Example:</h3>
<xmp>
usr << 2 ** 3 // outputs 8
</xmp>

<hr>

<a name=/operator/*=>
<h2>*= operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/*>* operator</a>
<dd><a href=#/operator/+=>+= operator</a>
<dd><a href=#/operator/-=>-= operator</a>
<dd><a href=#/operator//=>/= operator</a>
<dd><a href=#/operator/=>= operator</a>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A *= B
</dl>

<p>Set A equal to A * B.  It is shorthand for A = A * B.

<p>If A is an /icon or /matrix datum, the datum will be changed rather than
creating a new one and re-assigning it to A.

<hr>

<a name=/operator/+>
<h2>+ operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/*>* operator</a>
<dd><a href=#/operator/+=>+= operator</a>
<dd><a href=#/operator/->- operator</a>
<dd><a href=#/operator//>/ operator</a>
<dd><a href=#/list/proc/Add>Add proc (list)</a>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A + B
</dl>

<dl><dt><b>Returns:</b>
<dd>If A is a number, returns the sum of A and B.
<dd>If A is null, returns B.
<dd>If A is a list, a new list is returned with B appended to the contents
     of A.  If B is a list as well, its contents are appended rather than
     the list itself.
<dd>If A is a text string, returns a new string with A and B concatenated.
<dd>If A is an icon, returns a new icon with B (a color or another icon)
     added. Areas that are transparent in either icon are transparent in
     both; for more opacity use | (OR) instead. This works with the /icon
     datum as well.
<dd>If A and B are both /matrix datums, returns a new matrix with their
     components added together.
</dl>

<hr>

<a name=/operator/++>
<h2>++ operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/+>+ operator</a>
<dd><a href=#/operator/+=>+= operator</a>
<dd><a href=#/operator/-->-- operator</a>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>++A   // pre-increment
<dd>A++   // post-increment
</dl>

<p>The pre-increment has the value (A+1) and the effect of adding 1 to A.

<p>The post-increment has the value (A) and has the effect of adding 1 to A.

<h3>Example:</h3>
<xmp>
var/A = 0
world << "A++ = [A++]" // outputs "A++ = 0"
world << "++A = [++A]" // outputs "++A = 2"
</xmp>

<hr>

<a name=/operator/+=>
<h2>+= operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/*=>*= operator</a>
<dd><a href=#/operator/+>+ operator</a>
<dd><a href=#/operator/-=>-= operator</a>
<dd><a href=#/operator//=>/= operator</a>
<dd><a href=#/operator/=>= operator</a>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A += B
</dl>

<p>Set A equal to A + B.  It is shorthand for A = A + B.

<p>If A is an /icon or /matrix datum, the datum will be changed rather than
creating a new one and re-assigning it to A.

<hr>

<a name=/operator/->
<h2>- operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/*>* operator</a>
<dd><a href=#/operator/+>+ operator</a>
<dd><a href=#/operator/-=>-= operator</a>
<dd><a href=#/operator//>/ operator</a>
<dd><a href=#/list/proc/Remove>Remove proc (list)</a>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A - B
<dd>-B
</dl>

<dl><dt><b>Returns:</b>
<dd>If A is a number, returns A minus B.
<dd>If A is a list, a new list is returned with B removed from the contents
     of A.  If B is a list as well, each of its contents are removed rather
     than the list itself.
<dd>If A is an icon, returns a new icon with B (a color or another icon)
     subtracted. Areas that are transparent in either icon are transparent in
     both. This works with the /icon datum as well.
<dd>If A and B are both /matrix datums, returns a new matrix with their
     components subtracted.
</dl>

<hr>

<a name=/operator/-->
<h2>-- operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/++>++ operator</a>
<dd><a href=#/operator/->- operator</a>
<dd><a href=#/operator/-=>-= operator</a>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>--A   // pre-decrement
<dd>A--   // post-decrement
</dl>

<p>The pre-decrement has the value (A-1) and the effect of subtracting 1
from A.

<p>The post-decrement has the value (A) and has the effect of subtracting 1
from A.

<h3>Example:</h3>
<xmp>
var/A = 0
world << "A-- = [A--]" // outputs "A = 0"
world << "--A = [--A]" // outputs "A = -2"
</xmp>

<hr>

<a name=/operator/-=>
<h2>-= operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/*=>*= operator</a>
<dd><a href=#/operator/+=>+= operator</a>
<dd><a href=#/operator/->- operator</a>
<dd><a href=#/operator//=>/= operator</a>
<dd><a href=#/operator/=>= operator</a>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A -= B
</dl>

<p>Set A equal to A - B.  It is shorthand for A = A - B.

<p>If A is an /icon or /matrix datum, the datum will be changed rather than
creating a new one and re-assigning it to A.

<hr>

<a name=/operator//>
<h2>/ operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/*>* operator</a>
<dd><a href=#/operator/+>+ operator</a>
<dd><a href=#/operator/->- operator</a>
<dd><a href=#/operator/path//>/ path operator</a>
<dd><a href=#/operator//=>/= operator</a>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A / B
</dl>

<dl><dt><b>Returns:</b>
<dd>A divided by B.
</dl>

<p>If A is an icon, the result is a new icon whose color values (except alpha)
are divided by B, which must be a number. This works with the /icon datum as
well.

<p>If A is a /matrix datum, the result is a new matrix. B can be a number
(which scales the whole matrix) or another matrix. Dividing by matrix B is the
same as multiplyng by its inverse. That is, A / B is identical to A * ~B.

<hr>

<a name=/operator//=>
<h2>/= operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/*=>*= operator</a>
<dd><a href=#/operator/+=>+= operator</a>
<dd><a href=#/operator/-=>-= operator</a>
<dd><a href=#/operator//>/ operator</a>
<dd><a href=#/operator/=>= operator</a>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A /= B
</dl>

<p>Set A equal to A / B.  It is shorthand for A = A / B.

<p>If A is an /icon or /matrix datum, the datum will be changed rather than
creating a new one and re-assigning it to A.

<hr>

<a name=/operator/:>
<h2>: operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/@dt;>. operator</a>
<dd><a href=#/operator/path/:>: path operator</a>
<dd><a href=#/operator>operators</a>
</dl>

<p>This is the runtime search operator.  It is used to access a property of
a var that is not explicitly prototyped.  If the variable doesn't have the
specified variable, a run-time error occurs.

<h3>Example:</h3>
<xmp>
var/M
M = usr
M:name = "futz"  // access a mob property from a non-mob var
</xmp>

<hr>

<a name=/operator/=>
<h2>= operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/*=>*= operator</a>
<dd><a href=#/operator/+=>+= operator</a>
<dd><a href=#/operator/-=>-= operator</a>
<dd><a href=#/operator//=>/= operator</a>
<dd><a href=#/operator/%=>%= operator</a>
<dd><a href=#/operator/|=>|= operator</a>
<dd><a href=#/operator/&=>&= operator</a>
<dd><a href=#/operator/^=>^= operator</a>
<dd><a href=#/operator/&lt;&lt;=>&lt;&lt;= operator</a>
<dd><a href=#/operator/&gt;&gt;=>&gt;&gt;= operator</a>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A = B
</dl>

<p>Set A equal to B.

<p>Note that this is not the same as the equality test (==), which tests if
A is equal to B.

<p>All assignment operators, including calculate-and-assign (such as the +=
operator), can be chained together, and they are evaluated in right-to-left
order.  Therefore, a = b += c is a legal statement.  It is equivalent to
adding b and c, storing the result in b, then setting a to use the new value
of b.  (a = b) += c will, on the other hand, set a to equal b, then add c to
a and store the result in a; b is never changed.

<hr>

<a name=/operator/==>
<h2>== operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/!=>!= operator</a>
<dd><a href=#/operator/&gt;=>&gt;= operator</a>
<dd><a href=#/operator/&lt;=>&lt;= operator</a>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A == B
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if A and B are equal; 0 otherwise
</dl>

<p>Note that this is not the same as the assignment operator (=), which sets
A equal to B.

<hr>

<a name=/operator/@dt; toc=".">
<h2>. operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/:>: operator</a>
<dd><a href=#/operator>operators</a>
</dl>

<p>This is used to access the procs and vars of a prototyped object.  The
variable need not actually contain a value with the specified type, but must
at least be a type with the specified variable or a run-time error will
occur, causing the proc to crash.

<h3>Example:</h3>
<xmp>
var/mob/M
M.name = "futz"  // assign 'name' mob var
M.Move(0)        // call 'Move()' mob proc
</xmp>

<hr>

<a name=/operator/@qu; toc="?">
<h2>? operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Expr ? TrueExpr : FalseExpr
</dl>

<p>If Expr is true, this evaluates and returns TrueExpr.  Otherwise, it
evaluates and returns FalseExpr.

<hr>

<a name=/operator/[]>
<h2>[] operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/list>list</a>
<dd><a href=#/operator>operators</a>
</dl>

<p>This is used to access an element of a list.

<h3>Example:</h3>
<xmp>
var/L[2]  // declares list of size 2
L[1] = 10 // assign first element
</xmp>

<hr>

<a name=/operator/^>
<h2>^ operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/^=>^= operator</a>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A ^ B
</dl>

<dl><dt><b>Returns:</b>
<dd>The binary "xor" of A and B.
</dl>

<p>A and B must be between 0 and 65535 (2**16 - 1), giving an effective
width of 16 bits.

<p>If A and B are lists, the result is a list containing items that are in
either list but not both. list(1,2) ^ list(2,3) is equivalent to list(1,3).
The items found only in A come first in the result, followed by any items
found only in B.

<hr>

<a name=/operator/^=>
<h2>^= operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/^>^ operator</a>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A ^= B
</dl>

<p>Set A equal to A ^ B.  It is shorthand for A = A ^ B.

<p>If A and B are lists, any items that are found in both lists are removed
from A, and then any items found only in B are added to A.

<hr>

<a name=/operator/in>
<h2>in operator</h2>

<dl><dt><b>Format:</b>
<dd>A in List
</dl>
<dl><dt><b>Returns:</b>
<dt><b> 1 if A exists in List; 0 if not</b>
</dl>

<hr>

<a name=/operator/path>
<h2>path operators</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/path/@dt;>. path operator</a>
<dd><a href=#/operator/path//>/ path operator</a>
<dd><a href=#/operator/path/:>: path operator</a>
<dd><a href=#/proc>procs</a>
<dd><a href=#/var>vars</a>
</dl>

<p>A "path" in DM is a constant value that identifies a particular definition
in the code tree (i.e. an object, procedure, or variable definition).  An
example of this is the default mob type for new players <code>/mob</code>.

<p>Paths are used in two contexts.  One is to "get to" a particular point in
the code tree in order to modify the definition.  The other is to reference a
particular definition made elsewhere in the code tree.  The syntax of a path
is similar in both cases.

<p>When you are making a definition, you simply put the path at the beginning
of a line like this:

<xmp>
obj/clothes/gloves
</xmp>

<p>That automatically creates that path in the code tree if it does not
already exist.  When starting at the beginning of the line (no indentation)
there is no need to begin the path with '/', but that is perfectly acceptable.

<p>When making definitions, DM equates the path separator '/' with
indentation, so the above example is really just a more compact way of
writing:

<xmp>
obj
   clothing
      gloves
</xmp>

<p>One generally uses indentation when you have several things to define with
a common parent path:

<xmp>
obj
   clothing
      gloves
      sandals
</xmp>

<p>An important element of DM is that you can get to the same path in the
code tree from multiple places in the source code.  For example, given the
above definition of <code>gloves</code> and <code>sandals</code>, you could
modify a property of one of them from somewhere else using any path syntax you
like:

<xmp>
obj/clothing/sandals
   name = "Winged Sandals"
</xmp>

<p>While that was not a useful thing to do in this case, it can be a very
powerful tool when organizing source code in large projects.  Also note that
the use of "/" can save your source code from getting too deeply indented,
which may sound mundane, but which is quite important!

<p>The above examples used paths to make definitions.  The other time when you
use paths is when you need to refer to a particular definition.  Creation of
an object is one example:

<xmp>
mob/Login()
   if(length(contents) == 0) //poor fellow has nothing
      //create sandals in his contents list
      new /obj/clothing/sandals (src)
   return ..()
</xmp>

<p>Another common use of paths is to declare the data type of a variable.  In
DM, variable types do not affect what type of data the variable may
contain--variables that you define may contain any type of value.  Instead,
the variable type affects what properties of the data you can attempt to
access.

<p>The following example defines variables for clothing that is occupying
various positions on the body.

<xmp>
mob
   var/clothing
      feet
      hands
      torso
</xmp>

<p>Since there were several variables of the same type, they were grouped
under <code>var/clothing</code>.  It can be done any number of ways, depending
on the situation.  The same path syntax applies to variable definitions as
it does to anything else.  This example produces the same effect:

<xmp>
mob/var/clothing/feet
mob/var
   clothing
      hands
      torso
</xmp>

<h3>Provisos</h3>

<p>Just do not make a mistake like the following:

<xmp>
mob/var
   /clothing/feet
</xmp>

<p>Beginning a path with '/' effectively ignores whatever indentation may
precede it.  That is why it is called an <em>absolute</em> path.  The above
example would therefore be the same as the following, which is not what you
want:

<xmp>
mob/var        //empty variable definition
clothing/feet  //definition of object type /clothing/feet
</xmp>

<p>On a related note, parameter definitions in procedures should not begin
with a "/".

<xmp>
mob/Move(atom/Dest)     //correct
   src << "Moving to [Dest.x],[Dest.y]."
   return ..()

mob/Move(var/atom/Dest) //ok
mob/Move(/atom/Dest)    //WRONG
</xmp>

<p>Essentially, "var/" is prepended to each entry in the parameter list.

<hr>

<a name=/operator/path//>
<h2>/ path operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/path/@dt;>. path operator</a>
<dd><a href=#/operator/path/:>: path operator</a>
</dl>

<p>This is used to delimit paths in the DM code tree.  A path beginning with
'/' is an absolute path (which is independent of where in the code it is
used).  Otherwise, a path is relative, meaning it starts from the current
position in the code.

<p>The following example uses a path in the code tree to define the type of
object to create when leaving a corpse behind.

<h3>Example:</h3>
<xmp>
obj
   var
      poison
      nutrition

   corpse
      frog
         nutrition = 10
      spider
         nutrition = 6
         poison = 5
mob
   var
      corpse = /obj/corpse
   Die()
      new corpse(src.loc) //create the corpse here
      del src

   spider
      corpse = /obj/corpse/spider
   frog
      corpse = /obj/corpse/frog
</xmp>

<hr>

<a name=/operator/path/:>
<h2>: path operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/path/@dt;>. path operator</a>
<dd><a href=#/operator/path//>/ path operator</a>
</dl>

<p>The colon operator may be used as a short-cut when specifying a path in the
DM code tree.  Instead of specifying the full path, you can insert a colon and
the compiler will search down in the tree with the node you specify.  This is
known as a "downward" search.  You should only use it when the target node is
unique.

<p>The following example demonstrates the principle but it obviously doesn't
save much typing!

<h3>Example:</h3>
<xmp>
world
   mob = :player  //short-cut to /mob/player

mob/player
   Login()
      src << "Welcome, [name]."
</xmp>

<hr>

<a name=/operator/path/@dt; toc=".">
<h2>. path operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/path//>/ path operator</a>
<dd><a href=#/operator/path/:>: path operator</a>
</dl>

<p>The dot operator may be used as a short-cut when specifying a path in the
DM code tree.  Instead of specifying the full path, you can start a path with
a dot and the compiler will search up in the code tree for the following node.
This is known as a relative path with an "upward" search.

<p>Here are the beginnings of a text MUD that allows you to walk around
between rooms using the arrow keys.  The links between rooms are created in
this example by referencing the object type of the destination room.  Since
there could potentially be a lot of rooms, they are grouped into sub-classes,
and to avoid lengthy type paths such as /area/Village/Square, they are
referenced using a relative path from the point of reference.

<h3>Example:</h3>
<xmp>
area
   var/area
      north_exit
      south_exit
      east_exit
      west_exit

   Entered(O)
      O << name
      return ..()

   Castle
      Main_Gate
         north_exit = .Castle_Entryway
         south_exit = .Moat_Bridge
      Castle_Entryway
         south_exit = .Main_Gate
      Moat_Bridge
         north_exit = .Main_Gate
         south_exit = .Village/Guard_Post
   Village
      Guard_Post
         north_exit = .Castle/Moat_Bridge
         south_exit = .Square
      Square
         north_exit = .Guard_Post

//handle movement
client/Move(Dest,Dir)
   var/area/room = usr.loc
   if(istype(room)) //in a room
      switch(Dir)
         if(NORTH) Dest = room.north_exit
         if(SOUTH) Dest = room.south_exit
         if(EAST)  Dest = room.east_exit
         if(WEST)  Dest = room.west_exit
   return ..()

//set the starting position for new logins
mob/Login()
   if(!loc) Move(locate(/area/Castle/Main_Gate))
   return ..()
</xmp>

<hr>

<a name=/operator/|>
<h2>| operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&>& operator</a>
<dd><a href=#/operator>operators</a>
<dd><a href=#/operator/|=>|= operator</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A | B
</dl>

<dl><dt><b>Returns:</b>
<dd>The binary "or" of A and B.
</dl>

<p>A and B must be between 0 and 65535 (2**16 - 1), giving an effective
width of 16 bits.

<p>If A and B are lists, the result is a list containing items that are in
either list. list(1,2) | list(2,3) is equivalent to list(1,2,3). The items
from A come first in the result, followed by any extra items from B.

<p>If A is an icon or /icon datum, it is blended with B which can be either
a color or another icon. Unlike the + or & operation, the result is
transparent only in places where both icons were transparent.

<hr>

<a name=/operator/|=>
<h2>|= operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&=>&= operator</a>
<dd><a href=#/operator>operators</a>
<dd><a href=#/operator/|>| operator</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A |= B
</dl>

<p>Set A equal to A | B.  It is shorthand for A = A | B.

<p>This is commonly used to turn on certain bitfields in a word.

<h3>Example:</h3>
<xmp>
usr.sight |= BLIND // turn on the blind bit
</xmp>

<p>If A and B are lists, any items in B that are not already in A are added
to A.

<p>If A is an /icon or /matrix datum, the datum will be changed rather than
creating a new one and re-assigning it to A.

<hr>

<a name=/operator/||>
<h2>|| operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/!>! operator</a>
<dd><a href=#/operator/&&>&& operator</a>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>A || B
</dl>

<dl><dt><b>Returns:</b>
<dd>true value if either A or B is true (neither zero, an empty string, nor null); false value otherwise
</dl>

<p>The first true value from left to right completes the evaluation (a
practice known as short-circuiting).  The entire expression takes the value
of the last argument to be evaluated.

<hr>

<a name=/operator/~>
<h2>~ operator</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator>operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>~ A
</dl>

<dl><dt><b>Returns:</b>
<dd>The binary "not" of A.
</dl>

<p>A must be between 0 and 65535 (2**16 - 1), giving an effective width of
16 bits.

<p>If A is a /matrix datum, the result is a new matrix which is the inverse
of A.

<hr>

<a name=/proc>
<h2>procs</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/arguments>arguments (proc)</a>
<dd><a href=#/area/proc>procs (area)</a>
<dd><a href=#/mob/proc>procs (mob)</a>
<dd><a href=#/obj/proc>procs (obj)</a>
<dd><a href=#/turf/proc>procs (turf)</a>
<dd><a href=#/proc/var>vars (procs)</a>
</dl>

<p>Procs may be derived from /proc.  These procs are "global", in that they
can be called anywhere in the code.

<h3>Example:</h3>
<xmp>
proc/poof()
  world << "POOF!"
</xmp>

<p>The proc 'poof()' may now be called
anywhere in the code.

<p>Procs may also be attached to objects
by defining them under the appropriate
object/proc subnode.  Currently DM allows
procs to be defined or overridden for
/mob, /obj, /turf, /area, and /client, as
well as for data objects derived from /.
Predefined procs are discussed under the
"procs" entry for the object type.

<h3>Example:</h3>
<xmp>
mob/proc/poof()
  world << "POOF!"
</xmp>

<p>This can be called by a mob var M, using 'M.poof()'.

<hr>

<a name=/proc/@dt; toc=".">
<h2>. proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/@dt;@dt;>.. proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>.(Args)
</dl>

<dl><dt><b>Returns:</b>
<dd>The return value of the current proc.
</dl>

<dl><dt><b>Args:</b>
<dd>The arguments to pass to the new invocation of the current proc.  This
     defaults to current arguments.
</dl>

<p>Call the current proc.  A proc that calls itself is said to be recursive.

<h3>Example:</h3>
<xmp>
proc/factorial(N as num)
  if(N<=0) return 1
  return .(N-1)*N
</xmp>

<p>This computes the factorial N! by calling itself recursively.

<hr>

<a name=/proc/@dt;@dt; toc="..">
<h2>.. proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/@dt;>. proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>..(Args)
</dl>

<dl><dt><b>Returns:</b>
<dd>The return value of the parent proc.
</dl>

<dl><dt><b>Args:</b>
<dd>The arguments to pass to the parent proc.  This defaults to the
     arguments to the current proc.
</dl>

<p>If object O is derived from object P, P is called the parent of O.  If a
proc (or verb) is defined in both O and P, O can call P's version by using
..().

<h3>Example:</h3>
<xmp>
mob
  P
    verb/history()
      world << "P"

    O
      history()
        world << "O"
        ..()          // call P.history()
</xmp>

<p>Here O is derived from P.  When P calls "history", his name is
displayed.  When O calls "history", his name is displayed, followed by the
name of his parent, P.

<p>If O overrides the same proc more than once, ..() will search for the
previous version and use that.  For instance, you could have two O.history()
procs; the second overrides the first, but the original could still be called
via ..(). The original in turn could call ..() to reach P.history().
Overriding the same proc more than once in the same type should be avoided
wherever possible, because it incurs extra overhead, it makes the code
harder to read, and it isn't always clear which one gets called first.
(Usually, the only time you'll want this to happen is when using libraries.)

<p>..() can also be used for predefined procs.

<h3>Example:</h3>
<xmp>
mob/Move()            // override proc
  world << "moving..."
  return ..()         // call default
</xmp>

<p>This proc will print "moving..." whenever
the mob moves.

<hr>

<a name=/proc/ASSERT>
<h2>ASSERT proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/CRASH>CRASH proc</a>
<dd><a href=#/DM/preprocessor/define/DEBUG>DEBUG definition</a>
</dl>

<dl><dt><b>Format:</b>
<dd>ASSERT(expression)
</dl>

<dl><dt><b>Args:</b>
<dd>expression: an expression which should always be true
</dl>

<p>This is used to make a sanity check.  If the given expression is false, the
current procedure crashes, generating diagnostic debugging output, which
includes the expression, a stack dump, and so forth.

<hr>

<a name=/proc/CRASH>
<h2>CRASH proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/ASSERT>ASSERT proc</a>
<dd><a href=#/DM/preprocessor/define/DEBUG>DEBUG definition</a>
</dl>

<dl><dt><b>Format:</b>
<dd>CRASH(msg)
</dl>

<p>Crashes the current procedure, displaying the specified message and
generating diagnostic debugging output, such as a stack dump.

<hr>

<a name=/proc/abs>
<h2>abs proc</h2>

<dl><dt><b>Format:</b>
<dd>abs(A)
</dl>

<dl><dt><b>Returns:</b>
<dd>The absolute value of A.
</dl>

<dl><dt><b>Args:</b>
<dd>A: A number.
</dl>

<h3>Example:</h3>
<xmp>
usr << abs(1)  // outputs 1
usr << abs(-1) // outputs 1
</xmp>

<hr>

<a name=/proc/addtext>
<h2>addtext proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/+>+ operator</a>
</dl>

<dl><dt><b>Format:</b>
<dd>addtext(Arg1,Arg2,...)
</dl>

<dl><dt><b>Returns:</b>
<dd>A text string with the arguments concatenated.
</dl>

<dl><dt><b>Args:</b>
<dd>Any number of text strings.
</dl>

<p>This instruction returns text containing the first argument followed by
the second, followed by the third, etc.  The arguments may be constants or
variables containing text.

<h3>Example:</h3>
<xmp>
var/T
T = "1"
T = addtext(T,"*1 = ",T)  // T = "1*1 = 1"
world << "The answer is: [T]"
</xmp>

<p>This instruction exists primarily for backwards-compatibility.  You can
accomplish the same thing with the + operator or by using embedded
expressions.

<hr>

<a name=/proc/alert>
<h2>alert proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/input>input proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>alert(Usr=usr,Message,Title,Button1="Ok",Button2,Button3)
</dl>

<dl><dt><b>Returns:</b>
<dd>Selected button
</dl>

<p>This sleeps the current proc until the user clicks one of the named
buttons.  As with input(), the first argument may be entirely left out.

<h3>Example:</h3>
<xmp>
mob/verb/self_destruct()
   alert("Prepare to die.")
   del usr
</xmp>

<p>A slightly more complicated example provides the user with a choice in
the matter:

<h3>Example:</h3>
<xmp>
mob/verb/self_destruct()
   switch(alert("Would you like to die?",,"Yes","No","Maybe"))
      if("Yes")
         del usr
      if("No")
         usr << "You have second thoughts."
      if("Maybe")
         usr << "You flip a coin..."
         if(rand(0,1))
            usr << "Heads -- you lose."
            del usr
         else
            usr << "Tails -- you win!"
</xmp>

<hr>

<a name=/proc/animate>
<h2>animate proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var>vars (atom)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>animate(Object, var1=new_value1, var2=new_value2, ..., time, loop, easing, flags)
<dd>animate(var1=new_value1, var2=new_value2, ..., time, easing, flags)
<dd>animate(Object)
</dl>

<dl><dt><b>Args:</b>
<dd>Object: The atom, image, or client to animate.
<dd>var1=new_value1, var2=new_value2, ...: Vars to change in the animation step.
<dd>time: Time of this step, in 1/10s.
<dd>loop: Number of times to show the animation, or -1 to loop forever
<dd>easing: The "curve" followed by this animation step
<dd>flags: Flags that impact how the animation acts
</dl>

<p>This proc creates an animation sequence that will be displayed to players.
Starting with an atom or image, you can change one or more vars that affect
its apprearance.  This change will take place immediately, but will be
displayed to users as a gradual change over a period of time.  The actual
interpolation between frames is all done on the client.

<p>If the Object argument is left out, a new animation step will be created
for the last object that was animated.  If all other arguments are left out,
this is tantamount to saying you want to start a new animation that does
nothing, effectively ending the animation entirely.

<h3>Example:</h3>
<xmp>
mob/proc/GrowAndFade()
    // expand (scale by 2x2) and fade out over 1/2s
    animate(src, transform = matrix()*2, alpha = 0, time = 5)

obj/spell/proc/Spin()
    // cast a spell on a monster: make the icon spin
    // this animation takes 3s total (6 ticks * 5)
    animate(src, transform = turn(matrix(), 120), time = 2, loop = 5)
    animate(transform = turn(matrix(), 240), time = 2)
    animate(transform = null, time = 2)
</xmp>

<p>The following vars will animate smoothly:

<ul>
<li>alpha</li>
<li>color</li>
<li>infra_luminosity</li>
<li>layer</li>
<li>maptext_width</li>
<li>maptext_height</li>
<li>maptext_x</li>
<li>maptext_y</li>
<li>luminosity</li>
<li>pixel_x</li>
<li>pixel_y</li>
<li>pixel_w</li>
<li>pixel_z</li>
<li>transform</li>
</ul>

<p>These vars can be changed, but will change immediately on each step rather than smoothly:

<ul>
<li>dir</li>
<li>icon</li>
<li>icon_state</li>
<li>invisibility</li>
<li>maptext</li>
<li>suffix</li>
</ul>

<h3>Easing</h3>

<p>Animation doesn't have to be strictly linear. Some changes look much better if they follow a curve. A cubic curve, for instance, will start slow, accelerate very quickly in the middle, and slow down again at the end. A sine curve could be used with a flip transformation to make a coin appear to spin. A text bubble can jump into place and bounce a little before it settles. The choice of curve you use is called easing, and you have several good choices to pick from.

<ul>
<li><b>LINEAR_EASING</b>: Default. Go from one value to another at a constant rate.</li>
<li><b>SINE_EASING</b>: The animation follows a sine curve, so it starts off and finishes slowly, with a quicker transition in the middle.</li>
<li><b>CIRCULAR_EASING</b>: Similar to a sine curve, but each half of the curve is shaped like a quarter circle.</li>
<li><b>QUAD_EASING</b>: A quadratic curve, good for gravity effects.</li>
<li><b>CUBIC_EASING</b>: A cubic curve, a little more pronounced than a sine curve.</li>
<li><b>BOUNCE_EASING</b>: This transitions quickly like a falling object, and bounces a few times. By default this includes EASE_OUT, unless you combine with EASE_IN, EASE_OUT, or both.</li>
<li><b>ELASTIC_EASING</b>: This transitions quickly and overshoots, rebounds, and finally settles down. By default this includes EASE_OUT, unless you combine with EASE_IN, EASE_OUT, or both.</li>
<li><b>BACK_EASING</b>: Goes a little bit backward at first, and overshoots a little at the end.</li>
</ul>

<p>These can be combined with EASE_IN or EASE_OUT using the | operator, to use just the first or last part of the curve.

<h3>Example:</h3>
<xmp>
obj/coin/proc/Spin()
    var/matrix/M = matrix()
    M.Scale(-1, 1)  // flip horizontally
    animate(src, transform = M, time = 5, loop = 5, easing = SINE_EASING)
    animate(transform = null, time = 5, easing = SINE_EASING)

obj/speech_bubble/New(newloc, msg)
    icon = 'bubble.dmi'

    var/obj/O = new
    O.maptext = msg
    O.maptext_width = width
    O.maptext_height = height
    overlays = O

    // start below final position and jump into place
    pixel_z = -100
    alpha = 0
    animate(src, pixel_z = 0, alpha = 255, time = 10, easing = ELASTIC_EASING)
</xmp>

<h3>Flags</h3>

<p>Any combination of these flags may be used for animation (use + or | to
combine them):

<dl>
  <dt><b>ANIMATION_END_NOW</b>
  <dd>Normally if you interrupt another animation, it transitions from its
    current state.  This flag will start the new animation fresh by bringing
    the old one to its conclusion.  It is only meaningful on the first step
    of a new animation.
  <dt><b>ANIMATION_LINEAR_TRANSFORM</b>
  <dd>The transform var is interpolated in a way that preserves size during
    rotation, by pulling the rotation step out.  This flag forces linear
    interpolation, which may be more desirable for things like beam effects,
    mechanical arms, etc.
  <dt><b>ANIMATION_PARALLEL</b>
  <dd>Start a parallel animation that runs alongside the current animation.
    It may affect the same vars, or different vars. This can for instance
    let you animate pixel_y in a separate way from pixel_x. (When using this
    flag, the src var may be included, but it is optional.)
  <dt><b>ANIMATION_RELATIVE</b>
  <dd>The vars specified are relative to the current state. This works for
    maptext_x/y/width/height, pixel_x/y/w/z, glide_size, luminosity, layer,
    plane, alpha, transform, and color. For transform and color, the current
    value is multiplied by the new one. Vars not in this list are simply
    changed as if this flag is not present.
</dl>

<hr>

<a name=/proc/arccos>
<h2>arccos proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/arcsin>arcsin proc</a>
<dd><a href=#/proc/cos>cos proc</a>
<dd><a href=#/proc/turn>turn proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>arccos(X)
</dl>

<dl><dt><b>Returns:</b>
<dd>The inverse cos of X in degrees.
</dl>

<h3>Example:</h3>
<xmp>
mob/verb/test()
   usr << arccos(0)        //90
   usr << arccos(0.707107) //45
   usr << arccos(1)        //0
</xmp>

<hr>

<a name=/proc/arcsin>
<h2>arcsin proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/arccos>arccos proc</a>
<dd><a href=#/proc/sin>sin proc</a>
<dd><a href=#/proc/turn>turn proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>arcsin(X)
</dl>

<dl><dt><b>Returns:</b>
<dd>The inverse sin of X in degrees.
</dl>

<h3>Example:</h3>
<xmp>
mob/verb/test()
   usr << arcsin(0)        //0
   usr << arcsin(0.707107) //45
   usr << arcsin(1)        //90
</xmp>

<hr>

<a name=/proc/arglist>
<h2>arglist proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/arguments>arguments (proc)</a>
<dd><a href=#/proc/call>call proc</a>
<dd><a href=#/proc/list>list proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>arglist(List)
</dl>

<dl><dt><b>Args:</b>
<dd>List: a list to be used as the arguments to a procedure
</dl>

<p>Normally, if you were to pass a list directly to a procedure, it would only
come through as a singe argument to that procedure.  In some cases, you might
instead want the items in the list to become the arguments to the procedure.
That is what <code>arglist()</code> achieves.

<p>If the items in the list are associations, these are treated as
<a href=#/proc/arguments/named>named arguments</a>.  Each such list item is
matched against the names of the procedure arguments and its associated value
is assigned to that parameter.

<p>Most built-in DM instructions do not support use of
<code>arglist()</code>, but all user-defined procedures automatically
support it.  The built-in instructions which support named arguments will also
support <code>arglist()</code>.

<p>The following example shows how to use <code>arglist()</code> with both
positional parameters and named arguments.  Both of these examples could be
replaced by a much simpler direct call without need for a list to hold the
arguments; this is just to illustrate the syntax.

<h3>Example:</h3>
<xmp>
proc/MyProc(a,b)
   usr << "MyProc([a],[b])"

mob/verb/test()
   var/lst = list(1,2)
   MyProc(arglist(lst))  //MyProc(1,2)

   lst = list(b=2,a=1)   //just to illustrate that order does not matter
   MyProc(arglist(lst))  //MyProc(b=2,a=1)  -->  MyProc(1,2)
</xmp>

<hr>

<a name=/proc/arguments>
<h2>arguments (proc)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/arguments/named>named arguments (proc)</a>
<dd><a href=#/operator/path>path operators</a>
</dl>

<p>The parameters to a proc are referred to as arguments.  To define
argument variables, place them inside the ()'s in the proc definition.  A
default value may be specified.  Otherwise, arguments default to null.

<h3>Example:</h3>
<xmp>
proc/Sum(a,b)
  return a + b
</xmp>

<h3>Example:</h3>
<xmp>
proc/set_mob_desc(mob/M,desc="big and bad")
  M.desc = desc
  world << "The new desc for [M] is [desc]."
</xmp>

<p>Note how the variable type may be specified.  It is just like any other
variable definition, except "<code>var/</code>" is implicit and does not need
to be typed.

<hr>

<a name=/proc/arguments/named>
<h2>named arguments (proc)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/New>New proc (atom)</a>
<dd><a href=#/proc/arglist>arglist proc</a>
<dd><a href=#/proc/arguments>arguments (proc)</a>
</dl>

<p>The parameters passed to a procedure are called arguments.  These may
either be passed in positional order, or they can be passed as <em>named
arguments</em>.  Not all procedures are defined with the intention of
supporting named arguments, so consult the documentation for the procedure in
question first.  (This is mainly an issue of whether the argument names might
change in the future.)

<p>The following example shows several ways of producing the same call to a
procedure.

<h3>Example:</h3>
<xmp>
mob/proc/MyProc(a,b,c)
	src << "MyProc([a],[b],[c])"

mob/verb/test()
	MyProc(1,2,3)       //positional parameters
	MyProc(a=1,b=2,c=3) //named arguments
	MyProc(1,b=2,c=3)   //positional and named arguments
	MyProc(c=3,a=1,b=2) //named arguments can come in any order
</xmp>

<p>To prevent silent errors, named arguments that do not match any of the
arguments of the procedure being called will generate a runtime error.  This
is somewhat different from the behavior of positional arguments in DM where it
is perfectly acceptable to pass more arguments than were explicitly defined in
the procedure.

<p>As always, arguments that are not assigned in the call will simply be given
the value null (or whatever default value is specified in the definition).

<p>When an object procedure is overridden, the variable names in the new
definition are the ones that get matched against named arguments in a call to
that procedure.  A procedure which is intended to support named arguments
should therefore be defined with care so as to conform to the interface
expected by users of the procedure.  That doesn't stop you from changing that
interface when overriding a procedure, but the normal case would be to
preserve the argument names of the base procedure when overriding it.

<p>The following example is not useful, but it illustrates a situation where a
procedure is overridden so as to preserve the same argument names and
positions.  As mentioned above, you are not <em>required</em> to preserve
either the names or positions, but that is usually what you want.

<h3>Example:</h3>
<xmp>
mob
   proc/MyProc(a,b,c)
      usr << "mob.MyProc([a],[b],[c])"

   mob/verb/test()
      MyProc(a=1,b=2,c=3)

   special_mob
      MyProc(a,b,c,d)
         if(d) ..()      //pass in same order
         else ..(c,b,a)  //pass in reverse order

      test()
         MyProc(a=1,b=2,c=3,d=0) //normal order
         MyProc(a=1,b=2,c=3,d=1) //reverse the order

</xmp>

<p>This example merely used positional parameters in the call to
<code>..()</code>, but one can use named arguments there too if it is
desirable.

<p>The best time to use named arguments is when calling a procedure that takes
a lot of optional parameters.  You can just name the ones that you want to
assign and leave the rest unspecified.  Trying to do the same thing with
positional parameters can be much more awkward--especially when the arguments
you do want to assign are preceded by a number of ones that you don't care to
assign.  It's easy to lose your place in the list or to forget what it does.

<p>Since named arguments involve a slight amount of extra overhead, one should
avoid them in code that is highly cpu intensive due to being called many many
times.  Otherwise, code clarity may be a bigger priority.

<hr>

<a name=/proc/ascii2text>
<h2>ascii2text proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/text/entities>entities (text)</a>
<dd><a href=#/proc/text2ascii>text2ascii proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>ascii2text(N)
</dl>

<dl><dt><b>Returns:</b>
<dd>A text string.
</dl>

<dl><dt><b>Args:</b>
<dd>N: A number.
</dl>

<p>ASCII codes are numerical values corresponding to keyboard and special characters.
Among other things, they are used to represent many symbols in HTML.  This proc converts
an ASCII code to its corresponding text representation.

<h3>Example:</h3>
<xmp>
T = ascii2text(65)  // = "A"
</xmp>

<hr>

<a name=/proc/block>
<h2>block proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/list>list</a>
</dl>

<dl><dt><b>Format:</b>
<dd>block(Start,End)
</dl>

<dl><dt><b>Returns:</b>
<dd>The list of turfs in the 3D block defined by Start and End (inclusive).
</dl>

<dl><dt><b>Args:</b>
<dd>Start:  A turf to be the lower-left corner of the block.
<dd>End:    A turf to be the upper-right corner of the block.
</dl>

<p>The following example shows how to loop over a block of turfs.

<h3>Example:</h3>
<xmp>
world
   maxx = 20
   maxy = 20

mob/verb/block_test()
   var/turf/T
   for(T in block(locate(1,1,1),locate(10,10,1)))
      T.text = " "
</xmp>

<hr>

<a name=/proc/bounds>
<h2>bounds proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/movable/var/bound_x>bound_x var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_y>bound_y var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_width>bound_width var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_height>bound_height var (movable atom)</a>
<dd><a href=#/atom/movable/var/step_x>step_x var (movable atom)</a>
<dd><a href=#/atom/movable/var/step_y>step_y var (movable atom)</a>
<dd><a href=#/atom/movable/var/locs>locs list var (movable atom)</a>
<dd><a href=#/proc/obounds>obounds proc</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
<dd><a href=#/client/var/bounds>bounds var (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>bounds(Ref=src, Dist=0)
<dd>bounds(Ref, x_offset, y_offset, extra_width=0, extra_height=0)
<dd>bounds(x, y, width, height, z)
</dl>

<dl><dt><b>Returns:</b>
<dd>A list of atoms within the given bounding box.
</dl>

<dl><dt><b>Args:</b>
<dd>Ref:    A turf, obj, or mob.
<dd>Dist:   A number (distance in pixels).
<dd>x_offset, y_offset: Shift to bounding box position (from Ref's bounding box)
<dd>extra_width, extra_height: Adjustment to bounding box size (from Ref's bounding box)
<dd>x, y, z: Lower left corner of bounding box in absolute coords; x=1,y=1 is lower left of map
<dd>width, height: Size of bounding box in absolute coords
</dl>

<p>To leave Ref out of the results, use obounds() instead.

<p>Calling bounds() will default to bounds(src,0), if src is a turf, obj, or
mob. This returns all turfs, objs, and mobs (including src) within src's
bounding box.

<p>Changing the distance will return all objects within that distance from the
bounding box. E.g., bounds(turf,12) will show you everything within 12 pixels
of that turf.

<p>An object's bounding box can also be offset. bounds(src,-6,0) shows what src
would touching if it moved 6 pixels west. bounds(turf,-12,-12,24,24) is
equivalent to bounds(turf,12).

<p>In the final form, bounds() can use absolute coordinates and does not need
an object to be Ref. Absolute coordinates start at 1,1 at the lower left corner
of the map, by tradition.

<hr>

<a name=/proc/bounds_dist>
<h2>bounds_dist proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/movable/var/bound_x>bound_x var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_y>bound_y var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_width>bound_width var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_height>bound_height var (movable atom)</a>
<dd><a href=#/atom/movable/var/step_x>step_x var (movable atom)</a>
<dd><a href=#/atom/movable/var/step_y>step_y var (movable atom)</a>
<dd><a href=#/proc/bounds>bounds proc</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
</dl>

<dl><dt><b>Format:</b>
<dd>bounds_dist(Ref, Target)
</dl>

<dl><dt><b>Returns:</b>
<dd>The distance, in pixels, between Ref's and Target's bounding boxes.
</dl>

<dl><dt><b>Args:</b>
<dd>Ref:    A turf, obj, or mob.
<dd>Target: A turf, obj, or mob.
</dl>

<p>The value returned by bounds_dist() is the number of pixels that
the two objects would have to move closer together (if this is even
possible, of course) to be touching but not overlapping.

<p>A return value of 12 for instance means the two objects have a gap
of 12 pixels between them.

<p>A return value of 0 means the two objects are not overlapping, but
their bounding boxes touch.

<p>A return value of -2 means the two objects are overlapping by 2
pixels; they would have to move 2 pixels apart to separate.

<hr>

<a name=/proc/break>
<h2>break proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/continue>continue proc</a>
<dd><a href=#/proc/do>do proc</a>
<dd><a href=#/proc/for/loop>for loop proc</a>
<dd><a href=#/proc/while>while proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>break Label
</dl>

<p>Terminate the loop with the given label.  If no label is specified, the
innermost loop containing the <code>break</code> statement is assumed.

<h3>Example:</h3>
<xmp>
obj/zapper
  verb/use()
    var/mob/M

    for(M in view())
      if(!M.key) break

    if(!M) M = usr
    M << "ZAP!"
    del(M)
</xmp>

<p>The zapper object kills the first mob it finds that doesn't belong to a
player.  If none can be found, it kills the user.  Be careful!  Note how
this code takes advantage of the fact that the loop variable <var>M</var>
will be <code>null</code> if the loop terminates normally.

<p>For an example of how to use labeled loops, see the reference section for
the <code>continue</code> statement.

<hr>

<a name=/proc/browse>
<h2>browse proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&lt;&lt;/output>&lt;&lt; output operator</a>
<dd><a href=#/proc/browse_rsc>browse_rsc proc</a>
<dd><a href=#/proc/file>file proc</a>
<dd><a href=#/proc/link>link proc</a>
<dd><a href=#/proc/run>run proc</a>
<dd><a href=#/proc/output>output proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>usr &lt;&lt; browse(Body,Options)
</dl>

<dl><dt><b>Args:</b>
<dd>Body: html text, file, or null to close the browser.
<dd>Options: optional parameters
</dl>

<p>This sends the html text or file to the user and optionally displays it in
the web browser.  The default action is to use the embedded browser panel in the Dream
Seeker window; specifying an alternate window name (see below) causes it to appear in a
popup window.  Passing in 'null' for the html text causes the browser panel or named
window to be closed.

<p>The option parameters should either be omitted or they should be in a text
string of the following format:

<code>
"<var>window</var>=name;<var>file</var>=name;<var>display</var>=1;
<br><var>size</var>=300x300;<var>border</var>=0;<var>can_close</var>=1;
<br><var>can_resize</var>=1;<var>can_minimize</var>=1;<var>titlebar</var>=1"
</code>

<p>You may use commas (,), ampersands (&amp;), or semicolons (;) as the
delimiter.  Any or all of the parameters may be specified and they may be
included in any order.

<h3>General options</h3>
These control how to handle the text or file.
<p>
<dl>
<dt>window
<dd>This is the name used to identify the popup window.  It is not visible to
the user.  Multiple calls to browse() with the same window name overwrite
previous contents of the same popup window.  If window is not specified, the
embedded browser panel will be used.

<dt>file
<dd>When this is unspecified, the client will store the generated html file in the
user's byond "cache" directory with an appropriate name.  If Body is a
text string, the client will generate a unique name.  If it is a file, it will use
the name of the file.  You can override this by setting this parameter.  This is
only useful when you need to reference the file later, typically in tandem with the
display setting below.

<dt>display
<dd>This controls whether the browser actually displays Body in the web browser
or not.  If it is turned off (display=0), the text or file is simply sent
to the user and expected to be referenced later.  This might be useful, for instance, to first send an image to a user and then display a web page that uses that image:
<xmp>
usr << browse('monster.png',"display=0")
usr << browse("<img src=monster.png>A scary monster appears from the mist!")
</xmp>
Note that this performs the same function as the <a href=#/proc/browse_rsc>browse_rsc</a> proc (preserved for legacy reasons).  It is a little more powerful because you can use
it to send html text as well as files.  In that case, you'll have to also supply the file=name argument so that you can reference the html text from within a later browse().
<p>
When display=0, all of the other arguments besides file are ignored.
</dl>

<h3>Popup options</h3>
These control how the popup window initially appears.  Setting these parameters for
an existing popup window or the embedded browser has no effect.
<p>
<dl>
<dt>border

<dd>This is the width of the border between the edges of the dialogue and the window
content.  The default value is 0, meaning that the entire window is filled with
html content.

<dt>size

<dd>This is the size of the popup window in pixels.  The format is
<code>WIDTHxHEIGHT</code>.

<dt>can_close

<dd>This specifies whether the window should be closable.  The default value
is 1, which enables the standard "X" button for closing.

<dt>can_resize

<dd>This controls whether the window is resizable.  The default value is 1,
enabling resizing and maximizing.

<dt>can_minimize

<dd>This controls whether the window is minimizable.  The default value is 1,
enabling the standard minimization button.

<dt>titlebar

<dd>The default titlebar=1 enables the standard bar at the top of the window.
Turning it off disables can_close and can_minimize.

</dl>

<p>Note also that many display options can be controlled through the html
itself.  For instance, to turn off the scrollbars, you can do:
<nobr><code>&lt;body scroll=no&gt;</code></nobr>; to add a title, you can do:
<nobr><code>&lt;head&gt;&lt;title&gt;My Title&lt;/title&gt;&lt;/head&gt;</code></nobr>; and so forth.

<p>The following example displays a help page in a popup window.

<h3>Example:</h3>

<xmp>
var/const/help = {"
<html>
<head><title>Help!</title></head>
<body>

You are beyond help!

</body>
</html>
"}
client/verb/help()
   usr << browse(help,"window=help")
</xmp>

You can use commands like <a href=#/proc/output>output()</a> and
<a href=#/proc/winset>winset()</a> to interact with popups. The name of the
window is the same name you gave the popup, and the browser is
"[windowname].browser".

<h3>Example:</h3>

<xmp>
client/verb/more_help()
   usr << output("You are still beyond help!", "help.browser")
</xmp>


<hr>

<a name=/proc/browse_rsc>
<h2>browse_rsc proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/browse>browse proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>usr &lt;&lt; browse_rsc(File,FileName)
</dl>

<dl><dt><b>Args:</b>
<dd>File: a resource file (such as an image)
<dd>FileName: name of file (if different from source file)
</dl>

<p>This sends the specified resource file to usr (or anybody else) and
stores it in their <code>cache</code> directory with the specified name.  In
subsequent <code>browse()</code> output, you can then refer to that file.

<p>If your world is always running on the internet, you can save yourself
the trouble and simply link to the image files through a web server.
However, if it may be played offline, you can compile in the resource files
and manually send them to players with <code>browse_rsc()</code>.

<p>Note that no data is transmitted if it already exists in the user's
cache, so there is little overhead in calling this every time you are about
to use <code>browse()</code>.

<h3>Example:</h3>
<xmp>
area
   var
      room_graphic = 'cozy_room.jpg'
   Enter(O)
      . = ..() //do default checks
      if(.)    //if we got clearance to enter
         O << browse_rsc(room_graphic,"room.jpg")
         O << browse("<p><img src=room.jpg></p>[desc]")
</xmp>

<hr>

<a name=/proc/call>
<h2>call proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/arglist>arglist proc</a>
<dd><a href=#/proc/hascall>hascall proc</a>
<dd><a href=#/operator/path>path operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>call(ProcRef)(Arguments)
<dd>call(Object,ProcName)(Arguments)
<dd>call(LibName,FuncName)(Arguments)
</dl>

<dl><dt><b>Args:</b>
<dd>ProcRef: path of proc (/proc/MyProc)
<dd>Object: source of proc or verb
<dd>ProcName: name of proc or verb ("MyProc")
<dd>LibName: name of external library ("test.DLL")
<dd>FuncName: name of function in external library ("func")
</dl>

<dl><dt><b>Returns:</b>
<dd>The return value of the proc being called.
</dl>

<p>This instruction exists in order to call procs dynamically, since the proc
reference or name may be an expression rather than a hard-coded value.  This
may serve the same purpose as a "function pointer" in C programs.

<p>The following examples do not demonstrate why you would want to do this,
but the syntax is illustrated.  The first one calls a specific procedure by
using a path reference to that procedure.

<h3>Example:</h3>
<xmp>
/proc/MyProc(Arg)
   usr << "MyProc([Arg])"
mob
   var
      MyProc = /proc/MyProc
   verb
      call_myproc()
         call(MyProc)("Hello, world!")
</xmp>

<p>The next example calls an object procedure (or verb) by name, rather than
by path.

<h3>Example:</h3>
<xmp>
mob
   proc
      Proc1(Arg)
         usr << "Proc1([Arg])"
      Proc2(Arg)
         usr << "Proc2([Arg])"
   verb
      call_proc(Proc in list("Proc1","Proc2"))
         call(src,Proc)("Hello, world!")
</xmp>
call() may also be used to access third-party libraries (.DLL files on windows, 
.SO files on unix), as long as the one or more of the following conditions is met:
<ul>
<li> The library is located in the BYOND user bin/ folder (~/.byond/bin on unix,
typically "My Documents/BYOND/bin/" on windows).  This is intended to allow the user 
to install permanently "trusted" libraries. -OR-
<li> The server is run in -trusted mode. -OR-
<li> The server grants permission to access the DLL at runtime, through a prompt query.
</ul> 
These functions must be prototyped in the DLL as:
<xmp>
extern "C" char *func(int argc, char *argv[]) 
// argc = #arguments, argv[] = array of arguments
</xmp>
<h3>Example:</h3>
<xmp>
// test.dll, a win32 C++ library compiled in VC++:
#include <string.h>
// This is an example of an exported function.
// windows requires __declspec(dllexport) to be used to 
// declare public symbols
// the name of the function from within the dll may be compiler-dependent
// (in this case it will usually be "merge" or "_merge)
// Google "name decoration" for more information on this exciting topic.
extern "C" __declspec(dllexport) char *merge(int n, char *v[]) 
{
   static char buf[500]; 
   *buf=0;
   for(int i=0;i<n;i++) {
      strcat(buf,v[i]); // we should bounds-check but it's a stupid example!
   }
   return buf;
}
</xmp>
<xmp>
// DM code to use test.dll
mob/verb/test()
   usr << call("test.dll","merge")("fee","fi","fo") // returns "feefifo"

// As with the other call() versions, arglist() may be used to do runtime arguments:
mob/verb/argtest()
   var/L = list("fee","fi","fo")
   usr << call("test.dll","func")(arglist(L)) // returns "feefifo"
</xmp>
As the library prototype is char**, the call() arguments must be strings.  Other types 
(like numbers) will be passed as the empty string ("") into the library function.
<p> Note for advanced users: on windows, call() uses the __cdecl convention by default.  
If you are designing or linking to a dll that uses the __stdcall convention instead, you 
can inform call() by  prefacing the function name with the "@" symbol, eg, call("test.dll","@merge") 
would call a version of "merge" declared with the __stdcall convention.  Typically these names are 
further decorated by the linker (in VC++, "merge" would be "_merge@8", so it'd be accessed with  
call("test.dll",@_merge@8")).   
<p>
<hr>

<a name=/proc/ckey>
<h2>ckey proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/ckeyEx>ckeyEx proc</a>
<dd><a href=#/mob/var/ckey>ckey var (mob)</a>
<dd><a href=#/savefile>savefile</a>
</dl>

<dl><dt><b>Format:</b>
<dd>ckey(Key)
</dl>

<dl><dt><b>Args:</b>
<dd>Key: The player key to convert to canonical form.
</dl>

<dl><dt><b>Returns:</b>
<dd>The key in canonical form.  To do this, it strips all punctuation and
    space from the key and converts to lowercase.  The result is still
    unique for each different key.
</dl>

<p>The result could be used as a unique directory name in a server-side save
file.  Each player could be stored in a separate directory.  By converting
to canonical form, possible problems resulting from punctuation (like the
path delimiter '/') in the key would be avoided.  If players are saved in
stand-alone files, it could be equally useful for generating a unique file
name.

<p>Note that this may be used on any text string.  It is not just limited to
keys.

<h3>Example:</h3>
<xmp>
var/savefile/SaveFile = new("world.sav")
proc/SavePlayer(mob/M)
  var/keydir = ckey(M.key)
  SaveFile.cd = "/players"
  SaveFile.cd = keydir
  M.Write(SaveFile)

proc/LoadPlayer(mob/M)
  var/keydir = ckey(M.key)
  SaveFile.cd = "/players"
  if(!SaveFile.Find(keydir)) return 0
  SaveFile.cd = keydir
  M.Read(SaveFile)
  return 1
</xmp>

<p>This example defines two procs for saving and loading players to a
server-side file.  These could be called in mob.Login() and mob.Logout().
Notice that instead of calling SaveFile.Write(M), this example instead calls
M.Write(SaveFile) directly.  The difference is that in this example we did
not want a new mob to be created when loading the player but instead wanted
to load information into an existing mob.

<p>In this example, the ckey() proc was used, but it would be more efficient
to use mob.ckey, which is the same value precomputed.

<hr>

<a name=/proc/ckeyEx>
<h2>ckeyEx proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/ckey>ckey proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>ckeyEx(Text)
</dl>

<dl><dt><b>Args:</b>
<dd>Text: The text string to convert to case-sensitive canonical key form.
</dl>

<dl><dt><b>Returns:</b>
<dd>The same text stripped of all punctuation and space.  Unlike, ckey(),
    case is preserved as are the '-' and '_' characters.
</dl>

<p>The true canonical form of a key is in all lowercase, but occasionally,
it is nice to preserve case when stripping a key (or other text) of any
special characters.

<p>Note: This proc used to be named cKey, like ckey but with a capital k.
To avoid confusion it has been renamed, but old code will still compile.

<hr>

<a name=/proc/cmptext>
<h2>cmptext proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/cmptextEx>cmptextEx proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>cmptext(T1,T2,...)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if all arguments are equal; 0 otherwise.
</dl>

<dl><dt><b>Args:</b>
<dd>Any number of text strings to compare.
</dl>

<p>This instruction is NOT sensitive to case.  It also ignores the
<code>\proper</code> and <code>\improper</code> text macros.  The
case-sensitive version is cmptextEx().

<h3>Example:</h3>
<xmp>
if(cmptext("Hi","HI"))
   world << "Equal!"
else
  world << "Not equal!"
</xmp>

<p>This outputs "Equal!" since "Hi" and "HI" are the same, ignoring case.

<hr>

<a name=/proc/cmptextEx>
<h2>cmptextEx proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/cmptext>cmptext proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>cmptextEx(T1,T2,...)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if all arguments are equal; 0 otherwise.
</dl>

<dl><dt><b>Args:</b>
<dd>Any number of text strings to compare.
</dl>

<p>This instruction is sensitive to case.  The case-insensitive version is
cmptext().

<p>Because identical text is internally combined to conserve memory,
cmptextEx(T1,T2) is equivalent to (T1 == T2).

<h3>Example:</h3>
<xmp>
if(cmptextEx("Hi","HI"))
   world << "Equal!"
else
  world << "Not equal!"
</xmp>

<p>This outputs "Not equal!" since "Hi" and "HI" are different when taking
case into account.

<p>Note: This proc used to be named cmpText, like cmptext but with a capital T.
To avoid confusion it has been renamed, but old code will still compile.

<hr>

<a name=/proc/continue>
<h2>continue proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/break>break proc</a>
<dd><a href=#/proc/do>do proc</a>
<dd><a href=#/proc/for/loop>for loop proc</a>
<dd><a href=#/proc/while>while proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>continue Label
</dl>

<p>Begins the next iteration of the loop with the given label.  If no label
is specified, the innermost loop containing the continue statement is
assumed.

<h3>Example:</h3>
<xmp>
client/verb/who()
  var/mob/M
  usr << "Players:"
  for(M in world)
    if(M == usr) continue
    if(M.key) usr << M.key
</xmp>

<p>This displays a list of players who have a mob in the world.  The
<code>continue</code> statement is used here to avoid including the user in
the list.  The same thing could have been achieved by using only the
<code>if</code> statement.  In more complicated situations, however, very
long conditional expressions and deeply nested <code>if</code> statements
can be avoided by using <code>continue</code> and its companion
<code>break</code>.

<p>Here is an example using a label to continue an outer loop from inside an
inner one:  <xmp> client/verb/loners()
  var/mob/M
  var/mob/G

  usr << "Loners:"
  finding_loners:
    for(M in world)
      for(G in world)
        if(M in G.group) continue finding_loners

      //found a loner
      usr << M.name
</xmp>

<p>This displays a list of mobs who do not belong in anyone else's group.
Notice the syntax for labeling a list.  The name of the block is simply
placed in the code followed by a colon and its contents are indented inside
it.

<hr>

<a name=/proc/copytext>
<h2>copytext proc</h2>

<dl><dt><b>Format:</b>
<dd>copytext(T,Start=1,End=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>A text string.
</dl>

<dl><dt><b>Args:</b>
<dd>T:     A text string.
<dd>Start: The text character position in which to begin the copy.
<dd>End: The text character position immediately following the last
     character to be copied.
</dl>

<p>Copy characters in T between Start and End. The default end position of 0
stands for the lentext(T)+1, so by default the entire text string is copied.

<h3>Example:</h3>
<xmp>
pre = copytext("Hi there",1,3))// = "Hi"
post = copytext("Hi there",4)) // = "there"
</xmp>

<p>If the start or end position is negative, it counts backwards from the end
of the string.

<h3>Example:</h3>
<xmp>
post = copytext("Hi there",-5)) // = "there"
</xmp>

<hr>

<a name=/proc/cos>
<h2>cos proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/arccos>arccos proc</a>
<dd><a href=#/proc/sin>sin proc</a>
<dd><a href=#/proc/turn>turn proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>cos(X)
</dl>

<dl><dt><b>Returns:</b>
<dd>The cos of X, where X is in degrees.
</dl>

<h3>Example:</h3>
<xmp>
mob/verb/test()
   usr << cos(0)  //1
   usr << cos(45) //0.707...
   usr << cos(90) //0
</xmp>

<hr>

<a name=/proc/del>
<h2>del proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/datum/proc/Del>Del proc (datum)</a>
<dd><a href=#/DM/garbage>garbage collection</a>
</dl>

<dl><dt><b>Format:</b>
<dd>del Object
</dl>

<dl><dt><b>Args:</b>
<dd>Object: Any data object (datum, savefile, world, you name it)
</dl>

<p>Destroy an object and null out all references to it.  Procs that are
executing with <code>src</code> equal to that object are silently killed,
causing execution to return to the caller.  If that is not what you want, you
should detach the proc from the source object by setting <code>src</code> to
<code>null</code>.

<p>When an object is deleted, its Del() procedure is called.  Currently, if
the Del() procedure does not execute the default action (by calling ..()),
then the deletion of the object is aborted.  You should not depend on this, as
it may change.  In other words, be sure to always call the default handler
after doing your own stuff.

<h3>Example:</h3>
<xmp>
mob/Del()
   src << "Aaaaaaaah!"
   ..()
mob/verb/self_destruct()
   del usr
</xmp>

<p>While manual object deletion is useful in many cases, the search for live
references to an object does take some time.  The more active objects in the
world, and the more variables in those objects, the longer the search will
take.  For larger projects, this search time can become significant.  In these
cases, as a best practice, manual deletion should be avoided by ensuring that
all references to an object are taken care of when the need for object
destruction arises.  Objects that have no references are deleted automatically
without the need for a search.  See <a href=#/DM/garbage>garbage collection</a>
for more details.

<hr>

<a name=/proc/do>
<h2>do proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/break>break proc</a>
<dd><a href=#/proc/continue>continue proc</a>
<dd><a href=#/proc/for/loop>for loop proc</a>
<dd><a href=#/proc/while>while proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>do Statement while( E )
</dl>

<p>Execute Statement.  If E is true (non-zero) do it over again.  Continue
until E is false (zero).

<p>Statement may be a block of code or a single statement.

<h3>Example:</h3>
<xmp>
var/i = 3
do
  world << i--
while(i)
</xmp>

<p>This outputs:

<xmp>
3
2
1
</xmp>

<hr>

<a name=/proc/EXCEPTION>
<h2>EXCEPTION proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/try>try and catch keywords</a>
<dd><a href=#/proc/throw>throw keyword</a>
<dd><a href=#/exception>exception</a>
</dl>

<dl><dt><b>Format:</b>
<dd>EXCEPTION(value)
</dl>

<dl><dt><b>Args:</b>
<dd>value: A text string (such as an error message) or other value
identifying the exception.
</dl>

<p>This is used to create an /exception datum, and is shorthand for calling
new/exception(value, __FILE__, __LINE__). The value you provode will be in
exception.name.

<hr>

<a name=/proc/fcopy>
<h2>fcopy proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/fcopy_rsc>fcopy_rsc proc</a>
<dd><a href=#/proc/shell>shell proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>fcopy(Src,Dst)
</dl>

<dl><dt><b>Args:</b>
<dd>Src: file to copy
<dd>Dst: new copy to make
</dl>

<dl><dt><b>Returns:</b>
<dd>1 on success; 0 otherwise.
</dl>

<p>Src may be either a cache file, a savefile, or the name of an external
file.  Cache files are specified in single quotes and external files are in
double quotes.  If the path to the destination file does not already exist,
it will be created.

<p>If the source and target are paths ending in "/", the contents of the
source directory (including sub-directories) will be copied to the target
path.

<p>This instruction could be useful when players upload files (like code)
that you might want to dump to an external file.

<h3>Example:</h3>
<xmp>
mob/verb/change_world(F as file)
  fcopy(F,"world.dm")
  shell("DreamMaker world")
  world.Reboot()
</xmp>

<p>This (somewhat dangerous) example allows players to upload code, recompile,
and reboot the world.  It assumes that DreamMaker is in the path where the
shell looks for executable files and also that the name of the running world
is world.dmb.

<hr>

<a name=/proc/fcopy_rsc>
<h2>fcopy_rsc proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/cache>cache</a>
<dd><a href=#/proc/fcopy>fcopy proc</a>
<dd><a href=#/proc/file>file proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>fcopy_rsc(File)
</dl>

<dl><dt><b>Args:</b>
<dd>File: file to copy into the resource cache
</dl>

<dl><dt><b>Returns:</b>
<dd>reference to the file as a cache entry
</dl>

<p>The file to copy may either be a file name (text string) or the return
value of file() operating on the same.  If a cache entry is passed as the
argument, it will simply be returned with no action necessary.

<p>Once a file has been copied into the resource cache (i.e. the world's .rsc
file), it may be used as an icon or a sound or whatever is appropriate.  Most
internal operations involving resource files automatically perform this
operation when you try to use an external file in place of a cache entry.  For
example, when assigning a file() object to atom.icon, fcopy_rsc() is
implicitly invoked.

<p>The main reason you would ever want to call this explicitly is if you are
storing references to resource files in your own data structures and you want
to ensure that all values are converted to cache entries so they may be
directly compared to one another.

<hr>

<a name=/proc/fdel>
<h2>fdel proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/shell>shell proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>fdel(File)
</dl>

<dl><dt><b>Args:</b>
<dd>File: name of file to delete
</dl>

<dl><dt><b>Returns:</b>
<dd>1 on success; 0 otherwise.
</dl>

<p>If the specified file ends in '<code>/</code>', it is treated as a
directory.  Any contents (including sub-directories) are deleted as well.

<p>Be careful!

<hr>

<a name=/proc/fexists>
<h2>fexists proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/flist>flist proc</a>
<dd><a href=#/proc/length>length proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>fexists(File)
</dl>

<dl><dt><b>Args:</b>
<dd>File: name of file to test
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if file exists; 0 otherwise.
</dl>

<hr>

<a name=/proc/file>
<h2>file proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&lt;&lt;/output>&lt;&lt; output operator</a>
<dd><a href=#/proc/fcopy_rsc>fcopy_rsc proc</a>
<dd><a href=#/proc/ftp>ftp proc</a>
<dd><a href=#/proc/isfile>isfile proc</a>
<dd><a href=#/proc/link>link proc</a>
<dd><a href=#/proc/run>run proc</a>
<dd><a href=#/savefile>savefile</a>
<dd><a href=#/proc/sound>sound proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>file(Path)
</dl>

<p>Returns a file object corresponding to the named file.  This file object
can then be used in a variety of ways.  One would be to send it to a player to
view using the browse() instruction.  Output may also be appended to the file
using the << operator.

<p>Note that the file exists in the external filesystem (ie the hard disk)
and not the cache.  That means the path is specified in double quotes and
will be evaluated at run-time rather than compile-time.  The file need not
exist at compile time and may even be modified at a later date.  This is the
principle reason for using a file in the filesystem rather than a cached
resource file (specified in single quotes).

<h3>Example:</h3>
<xmp>
mob/verb/help()
  usr << browse(file("help.html"))
</xmp>

<p>Many DM instructions that deal with files treat file("name") and "name" the
same.  There are cases such as browse() where a simple text string is not
interpreted as a filename; it is in those situations where file() is really
necessary.

<hr>

<a name=/proc/file2text>
<h2>file2text proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/shell>shell proc</a>
<dd><a href=#/proc/text2file>text2file proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>file2text(File)
</dl>

<dl><dt><b>Args:</b>
<dd>File: file to read
</dl>

<dl><dt><b>Returns:</b>
<dd>the contents of the file.
</dl>

<p>This can be useful when interacting with external applications that
generate output in a text file.  For example, you might have an external
program that mimics conversation:

<h3>Example:</h3>
<xmp>
mob/oracle/verb/tell(T as text)
  text2file(T,"talk.in")
  shell("talk < talk.in > talk.out")
  usr << file2text("talk.out")
</xmp>

<hr>

<a name=/proc/findlasttext>
<h2>findlasttext proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/findtext>findtext proc</a>
<dd><a href=#/proc/findtextEx>findtextEx proc</a>
<dd><a href=#/proc/findlasttextEx>findlasttextEx proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>findlasttext(Haystack,Needle,Start=0,End=1)
</dl>

<dl><dt><b>Returns:</b>
<dd>The last position of Needle in Haystack; 0 if not found.
</dl>

<dl><dt><b>Args:</b>
<dd>Haystack: The text string to search.
<dd>Needle: The sub-text to search for.
<dd>Start: The text character position in Haystack in which to begin the search.
    Because this searches backwards, the default is the end of the string (0).
<dd>End: The earliest position in Haystack that can be matched as a result.
</dl>

<p>This instruction is NOT sensitive to the case of Haystack or Needle.  The
case-sensitive version is findlasttextEx().

<p>If the start or end position is negative, the position is counted backwards
from the end of the string. E.g., findlasttext("Banana", "na", -3) starts three
characters from the end and will skip over the last "na".

<p>Note: Unlike findtext(), a regular expression may NOT be used as the Needle.

<hr>

<a name=/proc/findlasttextEx>
<h2>findlasttextEx proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/findtext>findtext proc</a>
<dd><a href=#/proc/findtextEx>findtextEx proc</a>
<dd><a href=#/proc/findlasttext>findlasttext proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>findlasttextEx(Haystack,Needle,Start=0,End=1)
</dl>

<dl><dt><b>Returns:</b>
<dd>The last position of Needle in Haystack; 0 if not found.
</dl>

<dl><dt><b>Args:</b>
<dd>Haystack: The text string to search.
<dd>Needle: The sub-text to search for.
<dd>Start: The text character position in Haystack in which to begin the search.
    Because this searches backwards, the default is the end of the string (0).
<dd>End: The earliest position in Haystack that can be matched as a result.
</dl>

<p>This instruction is sensitive to the case of Haystack and Needle.  The
case-insensitive version is findlasttext().

<p>If the start or end position is negative, the position is counted backwards
from the end of the string.

<p>Note: Unlike findtextEx(), a regular expression may NOT be used as the Needle.

<hr>

<a name=/proc/findtext>
<h2>findtext proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/findlasttext>findlasttext proc</a>
<dd><a href=#/proc/findtextEx>findtextEx proc</a>
<dd><a href=#/proc/replacetext>replacetext proc</a>
<dd><a href=#/{notes}/regex>Regular expressions</a>
</dl>

<dl><dt><b>Format:</b>
<dd>findtext(Haystack,Needle,Start=1,End=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>The first position of Needle in Haystack; 0 if not found.
</dl>

<dl><dt><b>Args:</b>
<dd>Haystack: The text string to search.
<dd>Needle: The sub-text to search for. May be a regular expression (regex).
<dd>Start: The text character position in Haystack in which to begin the search.
<dd>End: The text character position in Haystack immediately following the last
     character to search.
</dl>

<p>When Needle is text, this instruction is NOT sensitive to the case of
Haystack or Needle.  The case-sensitive version is findtextEx().

<h3>Example:</h3>
<xmp>
if(findtext("Hi There","there")==0)
  world << "Not found!"
else
  world << "Found!"
</xmp>

<p>This outputs "Found!", since "there" is a part of the string "Hi There",
ignoring case.

<p>If the start or end position is negative, the position is counted backwards
from the end of the string. E.g., findtext("Banana", "na", -3) starts three
characters from the end and only searches the final "ana".

<hr>

<a name=/proc/findtextEx>
<h2>findtextEx proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/findtext>findtext proc</a>
<dd><a href=#/proc/replacetextEx>replacetextEx proc</a>
<dd><a href=#/{notes}/regex>Regular expressions</a>
</dl>

<dl><dt><b>Format:</b>
<dd>findtextEx(Haystack,Needle,Start=1,End=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>The position of Needle in Haystack; 0 if not found.
</dl>

<dl><dt><b>Args:</b>
<dd>Haystack: The text string to search.
<dd>Needle: The sub-text to search for. May be a regular expression (regex).
<dd>Start: The text character position in Haystack in which to begin the search.
<dd>End: The text character position in Haystack immediately following the last
     character to search.
</dl>

<p>When Needle is text, this instruction is sensitive to the case of Haystack
and Needle.  The case-insensitive version is findtext().

<h3>Example:</h3>
<xmp>
if(findtextEx("Hi There","there")==0)
  world << "Not found!"
else
  world << "Found!"
</xmp>

<p>This outputs "Not found!", since "there" is not a part of the string "Hi
There", taking into account case.

<p>If the start or end position is negative, the position is counted backwards
from the end of the string. E.g., findtextEx("Banana", "na", -3) starts three
characters from the end and only searches the final "ana".

<p>Note: This proc used to be named findText, like findtext but with a capital T.
To avoid confusion it has been renamed, but old code will still compile.

<hr>

<a name=/proc/flick>
<h2>flick proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/icon_state>icon_state var (atom)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>flick(Icon,Object)
</dl>

<dl><dt><b>Args:</b>
<dd>Icon:  An icon file or state name.
<dd>Object:   The target object.
</dl>

<p>Cause the icon attached to Object to be temporarily replaced with the
specified icon or icon state for the duration of the animation.  This is a
purely visual effect and does not effect the actual value of the object's
icon variable.

<h3>Example:</h3>
<xmp>
flick('blink.dmi',usr) //show another icon
flick("fight",usr)     //show usr's fight state
</xmp>

<p>The target object may be any atom or image.

<hr>

<a name=/proc/flist>
<h2>flist proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/fexists>fexists proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>flist(Path)
</dl>

<dl><dt><b>Args:</b>
<dd>Path: The path in the filesystem to get a listing of.
</dl>

<dl><dt><b>Returns:</b>
<dd>A list of files contained in the specified directory and whose names
     begin with the specified text.  The names of sub-directories are listed
     too, and are marked by a trailing "/".
</dl>

<p>The path is of the form "dir1/dir2/.../file".  Only files beginning with
the "file" part are listed, so be sure to end a directory name with "/" if
you wish to see its contents.  Otherwise you will just get that directory
name back with a "/" appended.

<p>Only files and sub-directories directly contained in the specified path
are listed (ie not the contents of the sub-directories too).  The file names
in the list do not include the path information but just the bare file name.

<hr>

<a name=/proc/for>
<h2>for proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/for/list>for list proc</a>
<dd><a href=#/proc/for/loop>for loop proc</a>
</dl>

<p>The for proc can be used to iterate values over a fixed range or list.
Consult the appropriate entry for more information.

<hr>

<a name=/proc/for/list>
<h2>for list proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/for/loop>for loop proc</a>
<dd><a href=#/list>list</a>
</dl>

<dl><dt><b>Format:</b>
<dd>for (Var [as Type] [in List]) Statement
</dl>

<dl><dt><b>Args:</b>
<dd>Var:  A variable to sequentially contain each member of the list.
<dd>List: The list to loop through.  This defaults to the whole world.
<dd>Type: One or more of area, turf, mob, or obj, ORed together.  If no
     type is specified, the declared type of Var will be used to skip over
     inappropriate elements in the list.
</dl>

<h3>Example:</h3>
<xmp>
usr << "Mobs:"
var/mob/M
for(M in view())
  usr << M.name
</xmp>

<p>This loops M through the mobs in view(), outputting the name at each
iteration.

<p>You can declare the variable right inside the for statement.  Its scope
is entirely contained within the for statement, so it will not conflict with
a similar variable declared elsewhere in the same procedure.

<h3>Example:</h3>
<xmp>
client/verb/who()
   for(var/client/Player)
      usr << Player
</xmp>

<hr>

<a name=/proc/for/loop>
<h2>for loop proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/break>break proc</a>
<dd><a href=#/proc/continue>continue proc</a>
<dd><a href=#/proc/do>do proc</a>
<dd><a href=#/proc/for/list>for list proc</a>
<dd><a href=#/proc/while>while proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>for(Init, Test, Inc) Statement
</dl>

<p>First execute Init.  Then if Test is true (non-zero), execute Statement.
After this execute Inc.  Continue checking Test, doing Statement, and
performing Inc until Test turns out to be false (zero).

<p>Statement may be a code block or a single statement.  Semicolons may be
substituted for commas inside the parentheses as a convenience to C/C++
programmers.

<p>Init and Inc may be omitted.  If Test is omitted, the loop will continue
forever (unless a break, goto, or return instruction is used to get out of
the loop).

<h3>Example:</h3>
<xmp>
var/i
for(i=0, i<3, i++)
  world << i
</xmp>

<p>This outputs:

<xmp>
0
1
2
</xmp>

<hr>

<a name=/proc/ftp>
<h2>ftp proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&lt;&lt;/output>&lt;&lt; output operator</a>
<dd><a href=#/proc/browse>browse proc</a>
<dd><a href=#/proc/file>file proc</a>
<dd><a href=#/proc/link>link proc</a>
<dd><a href=#/proc/run>run proc</a>
<dd><a href=#/proc/sound>sound proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>O &lt;&lt; ftp(File,Name)
</dl>

<p>Sends a file to O with the (optional) suggested name for saving to disk.
The file may be a cache file (loaded at compile time) or an external file
(accessed at run-time).  Cache files are specified in single quotes, and
external files are in double quotes.

<p>This function could be used to distribute source code, supplementary
documentation, or anything.

<h3>Example:</h3>
<xmp>
mob/verb/geticon(O in view())
  usr << ftp(O:icon)
</xmp>

<p>This example allows the user to download the icons from other objects in
the game.

<hr>

<a name=/proc/get_dir>
<h2>get_dir proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/dir>dir var (atom)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>get_dir(Loc1,Loc2)
</dl>

<dl><dt><b>Returns:</b>
<dd>The direction from Loc1 to Loc2.  Possible results are NORTH, SOUTH, EAST,
    WEST, NORTHEAST, NORTHWEST, SOUTHEAST, and SOUTHWEST.  An approximation
    will be made if the true direction is not exactly in line with one of
    these.
</dl>

<dl><dt><b>Args:</b>
<dd>Loc1: An object on the map.
<dd>Loc2: An object on the map.
</dl>

<p>If the direction is not directly lying along one of the four primary
cardinal directions, the result will become the nearest diagonal direction
(eg. if Loc2 is mostly north but a little to the east of Loc1, the direction
returned will be NORTHEAST).

<hr>

<a name=/proc/get_dist>
<h2>get_dist proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/bounds_dist>bounds_dist proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>get_dist(Loc1,Loc2)
</dl>

<dl><dt><b>Returns:</b>
<dd>The distance between Loc1 and Loc2, in tiles.  This is the number of
full-tile movements (disregarding any obstacles and allowing diagonal moves)
required to go from one to the other.
</dl>

<dl><dt><b>Args:</b>
<dd>Loc1: An object on the map.
<dd>Loc2: An object on the map.
</dl>

<p>At this time, <tt>get_dist()</tt> never returns a value greater than 127.

<p>For a distance in pixels, use bounds_dist().

<hr>

<a name=/proc/get_step>
<h2>get_step proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/step>step proc</a>
<dd><a href=#/proc/walk>walk proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>get_step(Ref,Dir)
</dl>

<dl><dt><b>Returns:</b>
<dd>The location of the new position.
</dl>

<dl><dt><b>Args:</b>
<dd>Ref: Starting point or object.
<dd>Dir: One of NORTH, SOUTH, EAST, WEST, NORTHEAST, NORTHWEST, SOUTHEAST,
     SOUTHWEST.
</dl>

<p>Calculate the position of a step from Ref in the direction Dir.

<hr>

<a name=/proc/get_step_away>
<h2>get_step_away proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/step_away>step_away proc</a>
<dd><a href=#/proc/walk_away>walk_away proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>get_step_away(Ref,Trg,Max=5)
</dl>

<dl><dt><b>Returns:</b>
<dd>The location of the new position, or 0 if no change.
</dl>

<dl><dt><b>Args:</b>
<dd>Ref: Starting point or object.
<dd>Trg: An object on the map.
<dd>Max: The maximum distance between Ref and Targ before movement halts.
</dl>

<p>Calculate position of a step from Ref on a path to Trg, taking obstacles
into account.  If Ref is farther than Max steps from Trg, 0 will be returned.

<hr>

<a name=/proc/get_step_rand>
<h2>get_step_rand proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/step_rand>step_rand proc</a>
<dd><a href=#/proc/walk_rand>walk_rand proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>get_step_rand(Ref)
</dl>

<dl><dt><b>Returns:</b>
<dd>The location of the new position, or 0 if no change.
</dl>

<dl><dt><b>Args:</b>
<dd>Ref: Starting point or object.
</dl>

<p>Calculate position of a step from Ref in random motion.

<hr>

<a name=/proc/get_step_to>
<h2>get_step_to proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/step_to>step_to proc</a>
<dd><a href=#/proc/walk_to>walk_to proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>get_step_to(Ref,Trg,Min=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>The location of the new position, or 0 if no change.
</dl>

<dl><dt><b>Args:</b>
<dd>Ref: Starting point or object.
<dd>Trg: An object on the map.
<dd>Min: The minimum distance between Ref and Trg before movement halts.
</dl>

<p>Calculate the position of a step from Ref on a path to Trg, taking
obstacles into account.  If Ref is within Min steps of Trg, no step is
computed.  This is also true if the target is too far away (more than twice
world.view steps).  In either case, null is returned.

<hr>

<a name=/proc/get_step_towards>
<h2>get_step_towards proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/step_towards>step_towards proc</a>
<dd><a href=#/proc/walk_towards>walk_towards proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>get_step_towards(Ref,Trg)
</dl>

<dl><dt><b>Returns:</b>
<dd>The location of the new position.
</dl>

<dl><dt><b>Args:</b>
<dd>Ref: Starting point or object.
<dd>Trg: An object on the map.
</dl>

<p>Calculate the position of a step from Ref in the direction of Trg.

<hr>

<a name=/proc/goto>
<h2>goto proc</h2>

<dl><dt><b>Format:</b>
<dd>goto node
</dl>

<p>Jump to the specified node in the current proc.

<h3>Example:</h3>
<xmp>
goto End
world << "ERR"
End
world << "The end"
</xmp>

<p>This displays "The end".

<hr>

<a name=/proc/hascall>
<h2>hascall proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/call>call proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>hascall(Object,ProcName)
</dl>

<dl><dt><b>Args:</b>
<dd>Object: source of proc or verb
<dd>ProcName: name of proc or verb ("MyProc")
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if object has such a proc or verb; 0 otherwise
</dl>

<hr>

<a name=/proc/hearers>
<h2>hearers</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/ohearers>ohearers</a>
<dd><a href=#/proc/view>view proc</a>
<dd><a href=#/proc/viewers>viewers</a>
</dl>

<dl><dt><b>Format:</b>
<dd>hearers(Depth=world.view,Center=usr)
</dl>

<p>This is just like <code>viewers()</code>, but it is a list of mobs that can
hear the center object.  Currently, this is computed on the assumption that
opaque objects block sound, just like they block light.

<hr>

<a name=/proc/html_decode>
<h2>html_decode proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/html_encode>html_encode proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>html_decode(HtmlText)
</dl>

<dl><dt><b>Args:</b>
<dd>HtmlText: text to be "unescaped"
</dl>

<dl><dt><b>Returns:</b>
<dd>unescaped text
</dl>

<p>Special characters such as &lt; and &gt; are not displayed literally in
html and may produce garbled output.  To display these characters literally,
they must be "escaped".  For example, &lt; is produced by the code
<code>&amp;lt;</code> and &gt; is produced by the code <code>&amp;gt;</code>.

<p>The <code>html_decode()</code> instruction takes a text string containing
such escaped symbols and turns them into their literal counterparts.  The
more useful function is <code>html_encode()</code> which does the reverse.

<hr>

<a name=/proc/html_encode>
<h2>html_encode proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/html_decode>html_decode proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>html_encode(PlainText)
</dl>

<dl><dt><b>Args:</b>
<dd>PlainText: text to be html "escaped"
</dl>

<dl><dt><b>Returns:</b>
<dd>escaped text
</dl>

<p>Special characters such as &lt; and &gt; are not displayed literally in
html and may produce garbled output.  If you want to ensure that an entire
text string is displayed literally, you can "escape" those characters.  For
example, &lt; is produced by the code <code>&amp;lt;</code> and &gt; is
produced by the code <code>&amp;gt;</code>.

<p>The <code>html_encode()</code> instruction does this for you
automatically.  If you wanted to disallow html input from players, you
could use this to force their text to be displayed literally:

<h3>Example:</h3>
<xmp>
mob/verb/say(T as text)
   view() << "[usr] says, '[html_encode(T)]'"
</xmp>

<p>If a URL is included in the text, special characters like &amp; that are
part of the URL will be skipped. This keeps automatically created links in
the output from being broken.

<p>Note for BYOND oldies: the old-style formatting codes such as "\red" which
are still parsed but not encouraged are completely stripped out by
html_encode().

<hr>

<a name=/proc/icon>
<h2>icon proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/file>file proc</a>
<dd><a href=#/proc/icon_states>icon_states proc</a>
<dd><a href=#/DM/icon>icons</a>
</dl>

<dl><dt><b>Format:</b>
<dd>icon(icon,state,dir,frame,moving)
<dd><small>(supports <a href=#/proc/arguments/named>named arguments</a>)</small>
</dl>

<dl><dt><b>Args:</b>
<dd>icon: an icon file or /icon object
<dd>icon_state: an optional text string, specifying a single icon state to load
<dd>dir: an optional direction to extract
<dd>frame: an optional animation frame to extract
<dd>moving: Non-zero to extract only movement states, 0 for non-movement states,
  or null (default) for both
</dl>

<p>This is equivalent to new/icon().  It creates an /icon object, which is
initialized to contain the same graphical data as the given file.  If an icon
state or direction are specified, only those parts of the original icon will
be included in the new icon object.

<hr>

<a name=/proc/icon_states>
<h2>icon_states proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/icon>icons</a>
<dd><a href=#/world/var/icon_size>icon_size var (world)</a>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
<dd><a href=#/{notes}/big-icons>Big icons</a>
<dd><a href=#/{notes}/tiled-icons>Tiled icons</a>
</dl>

<dl><dt><b>Format:</b>
<dd>icon_states(Icon, mode=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>A list of text strings.
</dl>

<dl><dt><b>Args:</b>
<dd>Icon: the icon being accessed
<dd>mode: applies to icons larger than one tile when using map_format=TILED_ICON_MAP; see below
</dl>

<p>Icons may have one or more internal states, which are identified by name.
The state "" is the default.

<p>If you are not using the TILED_ICON_MAP value for world.map_format, you
can ignore the mode argument.

<p>When graphics bigger than world.icon_size are used as an icon, and the
map_format in use is TILED_ICON_MAP, they are internally broken up into
tiles, one per icon state. The <tt>mode</tt> argument was added for big
icons that get split into several smaller tiles. Those icons have several
smaller states per true icon_state. For example if your 64&times;64 icon
has a state named "open", it will contain states "open", "open 0,0",
"open 1,0", "open 0,1", and "open 1,1" which are all used internally.
(If the state name is blank, the sub-states are just "0,0", etc.) When using
the TILED_ICON_MAP format, you need these for displaying the icon over
several different atoms.

<p>mode=0 will only show the sub-states ("open 0,0" and so on), all of which
can be safely extracted in a single-tile icon via the <tt>icon()</tt> proc.
mode=1 will show the main state names ("open"); any time you work with that
state name you're working with the full-size icon. mode=2 will show all of
the states.

<hr>

<a name=/proc/if>
<h2>if proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/goto>goto proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>if( E ) Statement1
<dd>else if( E2 ) Statement2
<dd>else Statement3
</dl>

<p>If the expression E is true (non-zero) then execute Statement1.
Otherwise, test E2, etc.  Finally, if none of the expressions are true,
execute Statement3.  The else nodes are all optional.

<p>Statement1, Statement2, and Statement3 may be a single statement or a
code block with optional braces: {}.

<h3>Example:</h3>
<xmp>
if(T==1) world << "TRUE"
else world << "FALSE"
</xmp>

<p>This will display "TRUE" if T has value 1, and "FALSE" otherwise.

<hr>

<a name=/proc/image>
<h2>image proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&lt;&lt;>&lt;&lt; operator</a>
<dd><a href=#/proc/del>del proc</a>
<dd><a href=#/icon>icon</a>
<dd><a href=#/image>image objects</a>
<dd><a href=#/client/var/images>images var (client)</a>
<dd><a href=#/atom/var/overlays>overlays var (atom)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>image(icon,loc,icon_state,layer,dir)
<dd><small>(supports <a href=#/proc/arguments/named>named arguments</a>)</small>
</dl>

<dl><dt><b>Returns:</b>
<dd>An image reference on success; 0 on failure.
</dl>

<dl><dt><b>Args:</b>
<dd>icon: An icon, object prototype, object instance, or other image.
<dd>loc:  The location at which to display the image.
<dd>icon_state: The icon state to use.
<dd>layer: The drawing layer to use.
<dd>dir: The direction to orient the image.
</dl>

<p>Images are "virtual" objects, which have a purely visual effect.  Once
created, they can be made to appear to selected players.  The image()
instruction is simply a short-hand for new/image().

<p>The image remains attached to the location specified by <var>loc</var>.
For example, if <var>loc</var> is a mob, the image will appear above the mob
until it is destroyed.

<p>The arguments <var>icon_state</var>, <var>layer</var>, and <var>dir</var>
may be used to override the settings associated with the icon or object used
to create the image.  For example, the default drawing layer for an plain icon
is FLY_LAYER (above all other objects), but you could change this to OBJ_LAYER
to make it appear under mobs on the map.

<h3>Example:</h3>
<xmp>
var/Box
Box = image ('highlight.dmi', usr)
usr << Box
...
del(Box)  //when done, remove image
</xmp>

<p>Another common use of images is in making an overlay:

<xmp>
overlays += image('pants.dmi',icon_state = "red")
</xmp>

<p>Since the <code>loc</code> argument could never be a text string, the above
statement can be further shortened:

<xmp>
overlays += image('pants.dmi',"red")
</xmp>

<p>This is much preferable to achieving the same effect with
<nobr><code>icon('pants.dmi',"red")</code></nobr>, since that involves the
overhead of creating a new icon file, which should only be done when it is
really necessary.

<hr>

<a name=/proc/initial>
<h2>initial proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/issaved>issaved proc</a>
<dd><a href=#/datum/var/vars>vars list var (datum)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>initial(Var)
</dl>

<dl><dt><b>Args:</b>
<dd>Var: A variable to find the initial value of.
</dl>

<p>This returns the original compile-time value of a variable.  It could
be used to reset a variable to its default value or to check if a variable
has changed.

<h3>Example:</h3>
<xmp>
obj/verb/set_icon(I as null|icon)
   if(!I) I = initial(icon)
   icon = I
</xmp>

This example allows an object's icon to be modified.  If the user does not
specify a new icon, it will be reset to the original one.

<hr>

<a name=/proc/input>
<h2>input proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/alert>alert proc</a>
<dd><a href=#/verb/arguments>arguments (verb)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>input(Usr=usr,Message,Title,Default) as Type in List
</dl>

<dl><dt><b>Returns:</b>
<dd>User's response.
</dl>

<p>This sleeps the current proc until the user responds to the input dialog.
The only required argument is the message.  The type may be any combination of
input types allowed for verb arguments.  The default is <code>text</code>.

<h3>Example:</h3>
<xmp>
mob/verb/create_character()
   usr.name = input("Choose a name for your character.",
                    "Your Name",
                    usr.name)

   usr.gender = input("Select a gender for your character.",
                      "Your Gender",
                      usr.gender) in list("male","female","neuter")
</xmp>

<p>If the target of the input prompt is not a player, the result will be the
default value.  If no default value is specified and null is allowed by the
input type, that will be returned.  Otherwise, an error will result,
crashing the proc that called input().

<hr>

<a name=/proc/isarea>
<h2>isarea proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/isloc>isloc proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>isarea(Loc1, Loc2 ...)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if all args are valid areas; 0 otherwise
</dl>

<dl><dt><b>Args:</b>
<dd>Any number of locations to test.
</dl>

<hr>

<a name=/proc/isfile>
<h2>isfile proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/cache>cache</a>
<dd><a href=#/proc/file>file proc</a>
<dd><a href=#/proc/isicon>isicon proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>isfile(File)
</dl>

<dl><dt><b>Args:</b>
<dd>File: the value to test
</dl>

<p>This returns a true value when given a file.  Both objects returned by
file() and files stored in the resource cache qualify.

<hr>

<a name=/proc/isicon>
<h2>isicon proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/cache>cache</a>
<dd><a href=#/icon>icon</a>
<dd><a href=#/proc/isfile>isfile proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>isicon(Icon)
</dl>

<dl><dt><b>Args:</b>
<dd>Icon: the value to test
</dl>

<p>This returns a true value when given an icon.  Both /icon memory objects
and icon files stored in the resource cache qualify.

<hr>

<a name=/proc/isloc>
<h2>isloc proc</h2>

<dl><dt><b>Format:</b>
<dd>isloc(Loc1, Loc2 ...)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if all args are valid locs; 0 otherwise.
</dl>

<dl><dt><b>Args:</b>
<dd>Any number of locations to test.
</dl>

<p>Tests validity of a location.  If the argument is a mob, obj, turf, or
area, this returns 1.

<p>This is equivalent to:  (ismob(Loc) || isobj(Loc) || \ isturf(Loc) ||
isarea(Loc))

<hr>

<a name=/proc/ismob>
<h2>ismob proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/isloc>isloc proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>ismob(Loc1, Loc2 ...)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if all args are valid mobs; 0 otherwise
</dl>

<dl><dt><b>Args:</b>
<dd>Any number of locations to test.
</dl>

<hr>

<a name=/proc/isnull>
<h2>isnull proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/null>null</a>
</dl>

<dl><dt><b>Format:</b>
<dd>isnull(Val)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if Val is null; 0 otherwise
</dl>

<hr>

<a name=/proc/isnum>
<h2>isnum proc</h2>

<dl><dt><b>Format:</b>
<dd>isnum(Val)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if Val is a number; 0 otherwise
</dl>

<hr>

<a name=/proc/isobj>
<h2>isobj proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/isloc>isloc proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>isobj(Loc1, Loc2 ...)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if all args are valid objs; 0 otherwise
</dl>

<dl><dt><b>Args:</b>
<dd>Any number of locations to test.
</dl>

<hr>

<a name=/proc/ispath>
<h2>ispath proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/typesof>typesof proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>ispath(Val)
<dd>ispath(Val,Type)
</dl>

<dl><dt><b>Returns:</b>
<dd>single-argument: 1 if Val is a type path
<dd>double-argument: 1 if Val is a type path derived from Type; 0 otherwise.
</dl>

<dl><dt><b>Args:</b>
<dd>Val:  A type path.
<dd>Type: A type path or instance.
</dl>

<h3>Example:</h3>

<xmp>
var/M
M = /mob/ugly/duckling
if(ispath(M,/mob/ugly))  //true
if(ispath(M))            //true
if(ispath(new/mob))      //false
</xmp>

<hr>

<a name=/proc/issaved>
<h2>issaved proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/initial>initial proc</a>
<dd><a href=#/savefile>savefile</a>
<dd><a href=#/var/tmp>tmp vars</a>
<dd><a href=#/datum/var/vars>vars list var (datum)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>issaved(Var)
</dl>

<dl><dt><b>Args:</b>
<dd>Var: The variable to test.
</dl>

<p>This returns 1 if the given variable should be automatically saved when
writing an object to a savefile and 0 otherwise.  Variables which are not
global, const, or tmp will return 1.

<hr>

<a name=/proc/istext>
<h2>istext proc</h2>

<dl><dt><b>Format:</b>
<dd>istext(Val)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if Val is text; 0 otherwise
</dl>

<hr>

<a name=/proc/isturf>
<h2>isturf proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/isloc>isloc proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>isturf(Loc1, Loc2 ...)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if all args are valid turfs; 0 otherwise
</dl>

<dl><dt><b>Args:</b>
<dd>Any number of locations to test.
</dl>

<hr>

<a name=/proc/istype>
<h2>istype proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/ispath>ispath proc</a>
<dd><a href=#/proc/locate>locate proc</a>
<dd><a href=#/proc/typesof>typesof proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>istype(Val,Type)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if Val is derived from Type; 0 otherwise.
</dl>

<dl><dt><b>Args:</b>
<dd>Val:  An object instance.
<dd>Type: An object prototype or instance.  If no type is specified and a
     variable was passed in as the first argument, it will default to the
     declared type of the variable.
</dl>

<p>If you don't have an object instance to test, but just want to see if one
prototype derives from another one, use <a href=#/proc/ispath>ispath()</a>
instead.

<h3>Example:</h3>

<xmp>
var/M
M = new/mob/ugly/duckling()
if(istype(M,/mob/ugly))  //this will be true
  usr << "[M] is ugly!"
</xmp>

<p>Using implicit types, that same example can be rewritten as follows:

<xmp>
var/mob/ugly/M
M = new/mob/ugly/duckling()
if(istype(M))  //this will be true
  usr << "[M] is ugly!"
</xmp>

<hr>

<a name=/proc/jointext>
<h2>jointext proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/splittext>splittext proc</a>
<dd><a href=#/list/proc/Join>Join proc (list)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>jointext(List,Glue,Start=1,End=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>A text string made up of the items in List, joined together by Glue.
</dl>

<dl><dt><b>Args:</b>
<dd>List: The list to be joined.
<dd>Glue: The text that will go between each item.
<dd>Start: The list item on which to begin.
<dd>End: The list item immediately following the last item to be joined.
<dd>include_delimiters: True if any delimiters found should be included in
     the result.
</dl>

<p>Any items in List that are not already text will be converted to text.
The Glue string only goes between two items, so a single-item list is the
same as converting that one item to text, and an empty list becomes an empty
string.

<h3>Example:</h3>
<xmp>
var/list/items = list("apples", "oranges", "bananas")
usr << jointext(items, ", ")
</xmp>

<p>If the start or end position is negative, the position is counted backwards
from the end of the list.

<p>Calling List.Join(Glue,Start,End) is the same thing, as long as List is a
valid list.

<hr>

<a name=/proc/json_decode>
<h2>json_decode proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/json_encode>json_encode proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>json_decode(JSON)
</dl>

<dl><dt><b>Returns:</b>
<dd>A value interpreted from a JSON-formatted text string.
</dl>

<dl><dt><b>Args:</b>
<dd>JSON: The JSON-formatted text to decode.
</dl>

<p>Arrays like [1,2,3] will be converted to regular lists like list(1,2,3).

<p>Object literals like {"a":1} will be converted to associative lists such
as list("a"=1).  Each item in the list is also decoded.  (Non-string values
are allowed as the "keys" in the list, even though that's not valid JSON.
BYOND doesn't care, as long as it can understand the formatted text it's
given.  The only exception is that a number isn't allowed to be an
associative list key, and will be converted to a string instead, so {1:2}
becomes list("1"=2).)

<p>Special numbers NaN and Infinity are recognized correctly.  All other
numbers are parsed and stored in the regular BYOND format (32-bit floating
point).

<p>Since BYOND doesn't have dedicated boolean values, true and false are
interpreted as 1 and 0, respectively.

<p>In text strings, Unicode escapes that map to characters 0x80 to 0x9F in
the Windows-1292 code page will be converted back into BYOND-friendly
Windows-1292.  Other Unicode escapes of \u0100 and above are ignored.

<hr>

<a name=/proc/json_encode>
<h2>json_encode proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/json_decode>json_decode proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>json_encode(Value)
</dl>

<dl><dt><b>Returns:</b>
<dd>A JSON-formatted text string representing Value.
</dl>

<dl><dt><b>Args:</b>
<dd>Value: The value to encode.
</dl>

<p>If Value is a simple list, the result will be formatted as a JSON array,
and each item in the list is encoded.

<p>If Value is an associative list, the result will be formatted as a JSON
object literal, and each item and associated value is encoded.  (The keys in
the object literal don't have to be strings; even though that isn't valid
JSON, BYOND doesn't care.)

<p>Datums are <i>not</i> serialized, but are converted to "[Value]" instead.

<h3>Example:</h3>
<xmp>
var/list/info = list("name"="fridge", "power"=12)
// send {"name":"fridge","power":12} to a JavaScript function
usr << output(json_encode(info), "mybrowser:myJSfunction")
</xmp>

<p>BYOND formatting such as \red is removed from encoded strings.  Characters
in the 0x80 to 0x9F range, which is valid in the Windows-1292 code page used
by BYOND, are mapped to the proper Unicode \uNNNN escape characters when
possible. Characters of 0xA0 and above are mapped to \xNN escapes for ease of
reading by JavaScript in a browser control or the webclient.

<hr>

<a name=/proc/length>
<h2>length proc</h2>

<dl><dt><b>Format:</b>
<dd>length(E)
</dl>

<dl><dt><b>Returns:</b>
<dd>The length of the data associated with E.
</dl>

<dl><dt><b>Args:</b>
<dd>E: a text, list, or file
</dl>

<h3>Example:</h3>
<xmp>
world << length("Hi")
</xmp>

<p>This outputs, "2", the length of the string "Hi".

<h3>Example:</h3>
<xmp>
world << length(list(1,2,3))
</xmp>

<p>This outputs, "3", the length of the list.

<h3>Example:</h3>
<xmp>
world << length(file("test.txt"))
</xmp>

<p>This outputs the length of the file.

<hr>

<a name=/proc/lentext>
<h2>lentext proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/length>length proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>lentext(T)
</dl>

<dl><dt><b>Returns:</b>
<dd>The length of text T.
</dl>

<dl><dt><b>Args:</b>
<dd>T: A text string.
</dl>

<p>Deprecated. Use <code>length()</code> instead.

<hr>

<a name=/proc/link>
<h2>link proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&lt;&lt;/output>&lt;&lt; output operator</a>
<dd><a href=#/client/proc/Topic>Topic proc (client)</a>
<dd><a href=#/proc/file>file proc</a>
<dd><a href=#/proc/run>run proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>O &lt;&lt; link(url)
</dl>

<p>This causes the recipient (O) to view the specified url.  The url could
be a web or BYOND address.  In the latter case, the player will disconnect
from the current world and connect to the specified one.

<p>The format of a BYOND url is as follows:

<xmp>
byond://address:port?TopicData
</xmp>

<p>To access a registered world, address:port may be replaced by the
registered name in the hub.  The optional topic data is processed by the
world once the player has connected.  If only a topic is specified, the
current world processes it.

<h3>Example:</h3>
<xmp>
usr << link("byond://byond.com:6000") //BYOND address
usr << link("http://www.byond.com")   //web address
usr << link("?myTopic")                //topic
</xmp>

<hr>

<a name=/proc/list>
<h2>list proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/arglist>arglist proc</a>
<dd><a href=#/list>list</a>
<dd><a href=#/list/associations>list associations</a>
</dl>

<dl><dt><b>Format:</b>
<dd>list(A,B,C,...)
<dd>or
<dd>list(A=a,B=b,C=c,...)
</dl>

<dl><dt><b>Returns:</b>
<dd>A new list with contents A, B, C, and (optional) associated values a, b, c.
</dl>

<dl><dt><b>Args:</b>
<dd>Arbitrary number of elements to be inserted into the list.
</dl>

<p>Assign elements to a list.

<h3>Example:</h3>
<xmp>
var/L[]
L = list(1,2,3)
</xmp>

<p>This creates a new list 'L' that initially contains elements 1, 2, and
3.  The length of L is 3.

<p>The <code>list()</code> instruction may also be used to create associative
lists.

<h3>Example:</h3>
<xmp>
var/list/lst = list("player" = "James Byond", "score" = 2000)
</xmp>

<p>That creates a list with contents ("player, "score") and associated values
("James Byond", 2000) respectively.

<p>The index values should be constants, and that usually means text
constants.  When these index values happen to be text strings that satisfy all
the requirements for variable names, this may also be written in a convenient
short-hand without the double quotes:

<xmp>
var/list/lst = list(player = "James Byond", score = 2000)
</xmp>

<p>In other words, this is exactly the same syntax as for
<a href=#/proc/arguments/named>named arguments</a>.

<hr>

<a name=/proc/list2params>
<h2>list2params proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Topic>Topic proc (client)</a>
<dd><a href=#/list/associations>list associations</a>
<dd><a href=#/world/var/params>params var (world)</a>
<dd><a href=#/proc/params2list>params2list proc</a>
<dd><a href=#/proc/text2num>text2num proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>list2params(List)
</dl>

<dl><dt><b>Args:</b>
<dd>List: List to encode as a text string.
</dl>

<p>This instruction converts a list of parameter names and associated values
into a single text string suitable for use in a URL or similar situation.
The format of the resulting text string is:

<xmp>
"name1=value1&name2=value2&..."
</xmp>

<p>Special characters such as '=' and '&amp;' inside the parameter names or
values are written in the form: <code>%xx</code> where <code>xx</code> are
two hexadecimal digits representing the ASCII value of the character.
In addition, spaces are converted to '+'.

<p>This parameter format is the same one used by most html forms and is
known by the MIME type 'application/x-www-form-urlencoded'.  It is often
used in DM to pack information into topic links.

<p>The original list has items "name1", "name2", and so on.  These in turn
are associated with the corresponding values value1, value2, and so on.

<h3>Example:</h3>
<xmp>
var/plist[0]

plist["offense"] = "jwalk"
plist["time"] = "10:00"

usr << list2params(plist)
</xmp>

<p>The above example creates a simple parameter list which associates the
item "offense" with the value "jwalk" and the item "time" with the value
"10:00".  This will produce the text string "offense=jwalk&time=10:00".

<p>Object values in the list (like say a mob) get turned into references in
the parameter text, just as though you had embedded them with "\ref[Object]".
When read back in with params2list(), you could convert these values back into
real references by using locate().

<hr>

<a name=/proc/locate>
<h2>locate proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/istype>istype proc</a>
<dd><a href=#/datum/var/tag>tag var (datum)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>locate(Type) in Container
<dd>locate(X,Y,Z)
<dd>locate(Tag)
<dd>locate(TextRef)
</dl>

<dl><dt><b>Returns:</b>
<dd>An object of the specified type or the turf at the given coordinates.
     If a text string is given in place of an object type, the object with
     the same tag is found.  If a container is given, only objects
     directly within that object are searched.
</dl>

<dl><dt><b>Args:</b>
<dd>Type:  An object prototype or tag.  If locate() is being used in an assignment to a variable with a declared type, this argument is optional and will default to the type of the variable being assigned.
<dd>Container: An optional container object.  (The default is <code>world</code>.)
<dd>X,Y,Z: A set of numerical coordinates.
<dd>Tag: The value of an object's tag variable (must be unique).
<dd>TextRef: An embedded object reference created by the \ref text macro.
</dl>

<p>Types are matched in the same manner as istype().  In other words,
locate(/obj) could return an instance of something derived from /obj, such as
/obj/armor.

<p>If there is more than one instance of the specified type, the first one
found will be chosen.

<h3>Example:</h3>
<xmp>
var/mob/shopkeeper/M = locate()
if(M)
  usr << "Found the shopkeeper."
else
  usr << "Could not find the shopkeeper."
</xmp>

<p>This looks for a mob of a type /mob/shopkeeper in the world
(world.contents).

<h3>Example:</h3>
<xmp>
usr.Move(locate(/turf/Home))
</xmp>

<p>This "teleports" the usr to a turf of the type /turf/Home.

<h3>Example:</h3>
<xmp>
usr.Move(locate(1,2,3))
</xmp>

<p>This moves the usr to the turf at coordinates (x,y,z) = (1,2,3).

<hr>

<a name=/proc/log>
<h2>log proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/**>** operator</a>
</dl>

<dl><dt><b>Format:</b>
<dd>log(X,Y)
<dd>log(Y)
</dl>

<dl><dt><b>Returns:</b>
<dd>The logarithm (base X) of Y.  If X is not specified, a natural logarithm
is computed (base 2.718...).
</dl>

<p>The logarithm is the power to which you have to raise X in order to get
Y.  In other words, the following is true (ignoring round-off error):

<xmp>
X ** log(X,Y) == Y
</xmp>

<p>One nice property of this function is that it gradually increases, with a
slope that continuously tapers off.  In other words, it can be useful to
represent diminishing returns from some input, such as money, experience
points, and so forth.

<hr>

<a name=/proc/lowertext>
<h2>lowertext proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/uppertext>uppertext proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>lowertext(T)
</dl>

<dl><dt><b>Returns:</b>
<dd>A lowercase text string.
</dl>

<dl><dt><b>Args:</b>
<dd>T: A text string.
</dl>

<p>Make all of the characters of T lowercase.

<h3>Example:</h3>
<xmp>
L = lowertext("HI THERE") // = "hi there"
</xmp>

<hr>

<a name=/proc/matrix>
<h2>matrix proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/matrix>matrix</a>
</dl>

<dl><dt><b>Format:</b>
<dd>matrix()
<dd>matrix(Matrix)
<dd>matrix(a, b, c, d, e, f)
</dl>

<dl><dt><b>Returns:</b>
<dd>A new matrix.
</dl>

<dl><dt><b>Args:</b>
<dd>Matrix: a matrix to copy
<dd>a - f: The individual matrix components
</dl>

<p>If no arguments are provided, a new default (identity) matrix is created.

<hr>

<a name=/proc/max>
<h2>max proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/min>min proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>max(A,B,C,...)
</dl>

<dl><dt><b>Returns:</b>
<dd>the maximum of the arguments.
</dl>

<h3>Example:</h3>
<xmp>
usr << max(1,2,3)
</xmp>

<p>This example displays 3.

<p>If a single argument is specified, this is expected to be a list and the
maximum item from the list is returned.  Items to be compared may be numbers,
text strings, or null, but numbers and text strings may not be mixed.

<hr>

<a name=/proc/md5>
<h2>md5 proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/file>file proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>md5(T)
<dd>md5(F)
</dl>

<dl><dt><b>Returns:</b>
<dd>text or null.
</dl>

<dl><dt><b>Args:</b>
<dd>T: A text string.
<dd>F: A file.
</dl>

<p>This proc implements MD5 hashing.  A hash function is a one-way process
  that compacts information to a short value: a hash.  The same value will
  always have the same hash.  Among other uses, most computers use hashing
  to store passwords.  By storing just the hash, the password file contains
  very little sensitive information, but the password can still be verified
  by confirming that <code>md5(password)==hash</code>.  MD5 is a widely-used
  hash function.

<h3>Example:</h3>
<xmp>
mob/var/hash

mob/Read(savefile/S)
  ..()
  // hash was saved in the file along with other values
  if(md5("[level]/[exp]/[exp_needed]") != hash)
    src << "Cheater!"
    del(src)
</xmp>

<p>In the example, a few vars belonging to a mob were saved along with a hash
  of those values.  When the mob is loaded again, the game compares the hash
  to the values to make sure it's still accurate.  If the values or hash had
  been changed by a sneaky player, they wouldn't match.  (But a sneaky player
  could still calculate <code>hash</code> themselves if they knew the exact
  text used to make it, so this should be kept secret.)

<p>If the argument is a file, md5() will read the file and return
  the MD5 hash of the file's entire contents.  If the file doesn't
  exist, it returns null.  The file may be a cache file or an
  external file.

<h3>Examples:</h3>
<xmp>
var/hash = "(insert hash value here)"	// Compute this ahead of time

// Check that the cached default icon is still the same
if (md5('default.dmi') != hash)
  world << "The default icon has been modified!"

// Or check that the entire game resource file is pristine
if (md5(file("mygame.rsc")) != hash)
  world << "The game resources have been modified!"
</xmp>

<p>Note that you must pass the result of <a href=#/proc/file>file()</a>
  in order to compute the hash of an external file's contents at
  runtime.  Otherwise md5() will treat the filename as text and
  return the hash of the name only.

<p>If T is anything but a text string or file, the proc returns null.

<hr>

<a name=/proc/min>
<h2>min proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/max>max proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>min(A,B,C,...)
</dl>

<dl><dt><b>Returns:</b>
<dd>the minimum of the arguments.
</dl>

<h3>Example:</h3>
<xmp>
usr << min(1,2,3)
</xmp>

<p>This example displays 1.

<p>If a single argument is specified, this is expected to be a list and the
minimum item from the list is returned.  Items to be compared may be numbers,
text strings, or null, but numbers and text strings may not be mixed.

<hr>

<a name=/proc/missile>
<h2>missile proc</h2>

<dl><dt><b>Format:</b>
<dd>missile(Type, Start, End)
</dl>

<dl><dt><b>Args:</b>
<dd>Type:  An object prototype or icon file.
<dd>Start: The starting location.
<dd>End:   The ending location.
</dl>

<p>Send a missile of the given Type between two locations.  The effect is
purely visual.  When Type is an object, its icon is used for the missile.

<h3>Example:</h3>
<xmp>
missile(/obj/fireball, usr, loc)
</xmp>

<hr>

<a name=/proc/new>
<h2>new proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/New>New proc (atom)</a>
<dd><a href=#/datum/proc/New>New proc (datum)</a>
<dd><a href=#/icon/proc/New>New proc (icon)</a>
<dd><a href=#/proc/newlist>newlist proc</a>
<dd><a href=#/operator/path>path operators</a>
</dl>

<dl><dt><b>Format:</b>
<dd>new Type(Args)
</dl>

<dl><dt><b>Returns:</b>
<dd>A reference to a new instance of Type.
</dl>

<dl><dt><b>Args:</b>
<dd>Type: The type of object to create.
<dd>Args: Arguments for the Type.New() proc.
</dl>

<p>A new instance of Type is created.  The arguments (Args) are passed to its
New() proc.  A handy short-cut: if Type is not specified and new() is being
used in an assignment, the variable type of the left-hand-side will be used as
the default type.

<p>The atom types /area, /turf, /obj, and /mob all take a location argument
specifying the initial position.  If not specified, it defaults to null.

<p>Newly created areas or turfs replace any existing area or turf at the
specified location.

<h3>Example:</h3>
<xmp>
obj/stick
mob/verb/magic_stick()
   var/obj/stick/S = new(src)  //create a stick in my inventory
   S.desc = "This is no ordinary stick!"
   view() << "[src] creates \an [S] from thin air!"
</xmp>

<hr>

<a name=/proc/newlist>
<h2>newlist proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/list>list proc</a>
<dd><a href=#/proc/new>new proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>newlist(A,B,C,...)
</dl>

<dl><dt><b>Returns:</b>
<dd>A list of new objects, just as though you had done <nobr><code>list(new
A,new B,new C,...)</nobr></code>.
</dl>

<dl><dt><b>Args:</b>
<dd>Arbitrary number of types to be created in the list.
</dl>

<h3>Example:</h3>
<xmp>
mob/contents = newlist(/obj/scroll/readme)
</xmp>

<p>This causes new mobs to be created with a readme scroll in their
inventory.

<p>It is possible to make simple initializations when you want variables to
have values other than the default for the particular type you are creating.

<h3>Example:</h3>
<xmp>
mob/contents = newlist(
   /obj/scroll/readme {
      name = "Introduction"
      desc = "The fate of Bracolia depends on you ..."
   }
)
</xmp>

<p>This is the most common use of "modified types", but it is not specific to
the newlist instruction.  Anywhere a type value may be used in DM, it may be
followed by a list of initializations.  The general syntax for a modified
types is:

<p><em>path</em> {<em>var1</em> = <em>val1</em>; <em>var2</em> = <em>val2</em>}

<p>The semicolon is necessary if you put several variable assignments on the
same line.  The braces are necessary, even though they are generally optional
in DM (since the compiler looks at your indentation).  The reason is that the
path + initializations must be parsed as a single expression, which is a
different context from the usual use of braces in DM when you are defining a
true type.  Also, indentation inside of an argument list is always ignored
anyway.

<hr>

<a name=/proc/nonspantext>
<h2>nonspantext proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/findtext>findtext proc</a>
<dd><a href=#/proc/spantext>spantext proc</a>
<dd><a href=#/proc/splittext>splittext proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>nonspantext(Haystack,Needles,Start=1)
</dl>

<dl><dt><b>Returns:</b>
<dd>The number of consecutive characters, from the start position, that do NOT match the characters in Needles.
</dl>

<dl><dt><b>Args:</b>
<dd>Haystack: The text string to search.
<dd>Needles: A text string with all the characters that should not match.
<dd>Start: The text character position in Haystack in which to begin the search.
</dl>

<p>This proc is case-sensitive.  A common use for this proc is in parsing.
For instance nonspantext("apples, oranges",", ") will return 6, because the
first 6 characters don't match a comma or a space.

<p>If the start position is negative, the position is counted backwards from
the end of the string.

<hr>

<a name=/proc/num2text>
<h2>num2text proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/isnum>isnum proc</a>
<dd><a href=#/proc/text2num>text2num proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>num2text(N,SigFig=6)
</dl>

<dl><dt><b>Returns:</b>
<dd>A text string.
</dl>

<dl><dt><b>Args:</b>
<dd>N: A number.
<dd>SigFig: Number of significant digits.
</dl>

<p>Get the text string for a number.  The number of significant digits
determines when scientific notation is used.  The default is 6, so
scientific notation will only be used when there are more than 6 digits.

<h3>Example:</h3>
<xmp>
T = num2text(12,1)  // = "1.2e1"
</xmp>

<hr>

<a name=/proc/obounds>
<h2>obounds proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/bounds>bounds proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>obounds(Ref=src, Dist=0)
<dd>obounds(Ref, x_offset, y_offset, extra_width=0, extra_height=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>A list of atoms within the given bounding box, excluding Ref.
</dl>

<dl><dt><b>Args:</b>
<dd>Ref:    A turf, obj, or mob.
<dd>Dist:   A number (distance in pixels).
<dd>x_offset, y_offset: Shift to bounding box position (from Ref's bounding box)
<dd>extra_width, extra_height: Adjustment to bounding box size (from Ref's bounding box)
</dl>

<p>The results from obounds() are identical to bounds(), but obounds() leaves
Ref out of the results.

<hr>

<a name=/proc/ohearers>
<h2>ohearers</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/hearers>hearers</a>
<dd><a href=#/proc/oview>oview proc</a>
<dd><a href=#/proc/oviewers>oviewers</a>
</dl>

<dl><dt><b>Format:</b>
<dd>ohearers(Depth=world.view,Center=usr)
</dl>

<p>This is just like <code>hearers()</code>, but it excludes the center object
and its contents from the list.  It is a list of all other mobs that can hear
the center object.

<hr>

<a name=/proc/orange>
<h2>orange proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&lt;&lt;/output>&lt;&lt; output operator</a>
<dd><a href=#/proc/block>block</a>
<dd><a href=#/proc/oview>oview proc</a>
<dd><a href=#/proc/range>range proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>orange(Dist,Center=usr)
</dl>

<dl><dt><b>Returns:</b>
<dd>A list of objects within Dist tiles of Center, excluding Center.
</dl>

<dl><dt><b>Args:</b>
<dd>Dist:   A number.
<dd>Center: An object on the map.
</dl>

<p>This instruction is identical to oview() except visibility is ignored.
All objects are included in the list whether they are visible or not.  The
center object and its contents are excluded.

<hr>

<a name=/proc/output>
<h2>output proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&lt;&lt;/output>&lt;&lt; output operator</a>
<dd><a href=#/proc/winclone>winclone proc</a>
<dd><a href=#/proc/winset>winset proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>output(msg, control)
</dl>

<dl><dt><b>Args:</b>
<dd>msg: Text, an atom, a file, or null
<dd>control: The ID of a control in the player's skin, or null for the default
</dl>

<p>This is used in conjunction with the &lt;&lt; output operator to send
output to a particular control in the player's skin. If null is sent, the
control will be cleared.

<h3>Example:</h3>
<xmp>
usr << output("Your score is [score].", "scorepane.output")
</xmp>

<p>The browser control in an interface can be used to execute javascript via
the output() command. The format is:
<tt>target &lt;&lt; output("[params]","[control]:[scriptname]")</tt>
where "[params]" is a url-encoded list of string arguments to the javascript
function, as formatted by list2params().

<h3>Example:</h3>
<xmp>
mob/Login()
    . = ..()
    usr << output(\

{"
<script type="text/javascript">
function replace(v) {
    document.getElementById('foo').innerHTML = v;
}
</script>
<div id="foo">This text can change.</div>
<p>And this can't.</p>
"},
    "browser1");

#define LP(str) list2params(list(str))
mob/verb/newtext(T as text)
    usr << output(LP(T),"browser1:replace")
</xmp>

<p>This allows for the creation of more dynamic interfaces, since javascript
provides access to many client-side operations and flicker-free updates.

<hr>

<a name=/proc/oview>
<h2>oview proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&lt;&lt;/output>&lt;&lt; output operator</a>
<dd><a href=#/proc/orange>orange proc</a>
<dd><a href=#/proc/view>view proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>oview(Dist,Center=usr)
</dl>

<dl><dt><b>Returns:</b>
<dd>A list of visible objects within Dist tiles of Center, excluding Center.
</dl>

<dl><dt><b>Args:</b>
<dd>Dist:   A number.
<dd>Center: An object on the map.
</dl>

<p>This instruction is just like view() except it doesn't include Center or
its contents in the list.

<h3>Example:</h3>
<xmp>
oview() << "to others in sight of [usr]"
</xmp>

<hr>

<a name=/proc/oviewers>
<h2>oviewers</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/hearers>hearers</a>
<dd><a href=#/proc/oview>oview proc</a>
<dd><a href=#/proc/oviewers>oviewers</a>
</dl>

<dl><dt><b>Format:</b>
<dd>oviewers(Depth=world.view,Center=usr)
</dl>

<p>This is just like <code>viewers()</code>, but it excludes the center object
and its contents from the list.  It is a list of all other mobs that can see
the center object.

<hr>

<a name=/proc/params2list>
<h2>params2list proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Topic>Topic proc (client)</a>
<dd><a href=#/list/associations>list associations</a>
<dd><a href=#/proc/list2params>list2params proc</a>
<dd><a href=#/world/var/params>params var (world)</a>
<dd><a href=#/proc/text2num>text2num proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>params2list(Params)
</dl>

<dl><dt><b>Args:</b>
<dd>Params: Text string of parameter values.
</dl>

<p>This instruction converts a parameter text string to a list of individual
parameters and associated values.  The format of the parameter text is:

<xmp>
"name1=value1&name2=value2&..."
</xmp>

<p>The field separator ';' may be used in place of '&amp;'.

<p>Special characters such as '=', ';', and '&amp;' inside the parameter
names or values should be written in the form: <code>%xx</code> where
<code>xx</code> are two hexadecimal digits representing the ASCII value of
the character.  For example, '=' would be written <code>%3d</code>, ';'
would be <code>%3b</code>, '&amp;' would be <code>%26</code>, and '%' would
be <code>%25</code>.  These 'escaped' codes are automatically translated
into the corresponding character when read by params2list().

<p>This parameter format is the same one used by most html forms and is
known by the MIME type 'application/x-www-form-urlencoded'.  It is often
used in DM to pack information into topic links.  Though DM does not require
it, the standard format is for newlines to be written as CR LF pairs
(<code>%0d%0a</code>) and spaces to be written as '+' characters.  That
means if you want to write a '+' symbol, you will have to use
<code>%2b</code>.

<p>The list produced from the parameter text has items "name1", "name2", and
so on.  To access the values associated with these, you use the parameter
name as the list index.

<h3>Example:</h3>
<xmp>
var/ptext = "offense=jwalk&time=10:00"
var/plist[] = params2list(ptext)

var/p
for(p in plist)
   usr << "[p] = [plist[p]]"
</xmp>

<p>The above example defines a simple parameter text string containing two
parameters: "offense" and "time".  These are associated with the values
"jwalk" and "10:00".  The <code>for</code> loop illustrates how one might
loop through the list and print out each setting.

<p>Note that all values are stored as text strings in the list.  If you wish
to perform a numerical operation (such as addition), you should convert the
value to a number first using text2num().  If the value is an object text
reference, you can convert that into the object itself by using locate().

<p>If you have multiple items with the same name, they will be combined into
a list of text strings. For example, "key=value1;key=value2" would set
list["key"] to a list containing "value1" and "value2", not necessarily in
that order.

<hr>

<a name=/proc/pick>
<h2>pick proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/prob>prob proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>pick(Val1,Val2,...)
</dl>

<dl><dt><b>Returns:</b>
<dd>One of the given values randomly chosen.
</dl>

<p>To make a particular value more or less likely to be chosen, a relative
probability may be specified like this:

<xmp>
prob(P); Val
  Or
P; Val
</xmp>

<p>A value for P of 200 makes it twice as likely as the norm, 50 half as
likely, and so on.

<h3>Example:</h3>
<xmp>
obj/food
  verb/eat()
    usr << pick (
        "[usr] eats \a [src].",
      prob(50)
        "[usr] devours \a [src].",
      prob(25)
       "[usr] wolfs down \a [src]."
    )
    del(src)
</xmp>

<p>Also, to pick a value randomly from a list, simply pass the list as the
sole argument into pick().  In this case, there is no provision for weighting
the probabilities.  All items in the list are equally likely.

<hr>

<a name=/proc/prob>
<h2>prob proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/pick>pick proc</a>
<dd><a href=#/proc/rand>rand proc</a>
<dd><a href=#/proc/rand_seed>rand_seed proc</a>
<dd><a href=#/proc/roll>roll proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>prob(P)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 with probability P percent; otherwise 0
</dl>

<dl><dt><b>Args:</b>
<dd>P: A number.
</dl>

<hr>

<a name=/proc/rand>
<h2>rand proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/pick>pick proc</a>
<dd><a href=#/proc/prob>prob proc</a>
<dd><a href=#/proc/rand_seed>rand_seed proc</a>
<dd><a href=#/proc/roll>roll proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>rand(L=0,H) or rand()
</dl>

<dl><dt><b>Returns:</b>
<dd>A random integer between L and H inclusive; or a random number from 0 up
to 1 if L and H are omitted.
</dl>

<dl><dt><b>Args:</b>
<dd>L: A number for the lower-bound.
<dd>H: A number for the upper-bound.
</dl>

<hr>

<a name=/proc/rand_seed>
<h2>rand_seed proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/pick>pick proc</a>
<dd><a href=#/proc/prob>prob proc</a>
<dd><a href=#/proc/rand>rand proc</a>
<dd><a href=#/proc/roll>roll proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>rand_seed(Seed)
</dl>

<dl><dt><b>Args:</b>
<dd>Seed: An integer used to initialize the random number generator.
</dl>

<p>Many DM procedures make use of a pseudo-random number generator.  You can
use rand_seed() to initialize the generator.  The sequence returned by the
generator is identical each time it is initialized with the same seed, so you
could use this to reproduce the same output from an algorithm that uses the
random number generator.  If you never call rand_seed(), the generator is
initialized with a seed from the system clock, so it is effectively random.

<p>Note that with multiple realtime algorithms making calls to the generator
at unpredictable times, you are likely not to get the same result even when
using the same seed.  The overall sequence will be the same, but individual
sub-components of your world might call it in a different order.

<p>The pseudo-random number generator is system dependent, so do not expect
the sequence generated from a particular seed to be identical on two different
machines or operating systems.

<hr>

<a name=/proc/range>
<h2>range proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&lt;&lt;/output>&lt;&lt; output operator</a>
<dd><a href=#/proc/block>block</a>
<dd><a href=#/proc/view>view proc</a>
<dd><a href=#/proc/orange>orange proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>range(Dist,Center=usr)
</dl>

<dl><dt><b>Returns:</b>
<dd>A list of objects within Dist tiles of Center.
</dl>

<dl><dt><b>Args:</b>
<dd>Dist:   A number.
<dd>Center: An object on the map.
</dl>

<p>This instruction is identical to view() except visibility is ignored.
All objects are included in the list whether they are visible or not.

<p>A Dist of 0 includes Center, the contents of Center (normally
usr.contents), its location (normally the turf a mob is standing on), and any
other contents of that location.  A value of 1 extends the region to the
neighboring squares on the map and so on.  You can also use a rectangular box
size using a text string such as "13x11".  Both arguments are optional and may
be passed in any order.

<hr>

<a name=/proc/regex>
<h2>regex proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/{notes}/regex>Regular expressions</a>
<dd><a href=#/regex>regex datum</a>
<dd><a href=#/regex/proc>regex procs</a>
<dd><a href=#/proc/findtext>findtext proc</a>
<dd><a href=#/proc/replacetext>replacetext proc</a>
<dd><a href=#/proc/splittext>splittext proc</a>
<dd><a href=#/proc/REGEX_QUOTE>REGEX_QUOTE proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>regex(pattern, flags)
<dd>regex(Regex)
</dl>

<dl><dt><b>Returns:</b>
<dd>A new /regex datum.
</dl>

<dl><dt><b>Args:</b>
<dd>pattern: The pattern string to search for
<dd>flags: (optional) A text string containing any combination of modifier flags
<dd>Regex: an existing /regex datum to copy
</dl>

<p>Creates a <a href=#/{notes}/regex>regular expression</a>, stored in a /regex
datum, that can be used for searching and/or replacing text.

<hr>

<a name=/proc/REGEX_QUOTE>
<h2>REGEX_QUOTE proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/regex>regex proc</a>
<dd><a href=#/regex>regex datum</a>
</dl>

<dl><dt><b>Format:</b>
<dd>REGEX_QUOTE(text)
<dd>REGEX_QUOTE_REPLACEMENT(text)
</dl>

<dl><dt><b>Returns:</b>
<dd>REGEX_QUOTE: A version of the text with any special regular expression characters escaped by backslashes.
<dd>REGEX_QUOTE_REPLACEMENT: A version of the text with $ characters escaped by a second $.
</dl>

<dl><dt><b>Args:</b>
<dd>text: The text to escape
</dl>

<p>Quotes a piece of text so that it can be used inside a regular expression
without fear of being treated as pattern instructions.

<h3>Example:</h3>
<xmp>
proc/FindWord(text, word)
    // The \b pattern is a word break, to search for the word
    // on its own instead of as part of another word.
    var/regex/R = regex("\\b[REGEX_QUOTE(word)]\b", "i")
    // find the pattern in the text
    return R.Find(text)
</xmp>

<hr>

<a name=/proc/replacetext>
<h2>replacetext proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/findtext>findtext proc</a>
<dd><a href=#/proc/replacetextEx>replacetextEx proc</a>
<dd><a href=#/{notes}/regex>Regular expressions</a>
<dd><a href=#/regex/proc/Replace>Replace proc (regex)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>replacetext(Haystack,Needle,Replacement,Start=1,End=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>The Haystack text with all cases of Needle replaced by Replacement
</dl>

<dl><dt><b>Args:</b>
<dd>Haystack: The text string to search.
<dd>Needle: The sub-text to search for. May be a regular expression (regex).
<dd>Replacement: The replacement text, or a proc.
<dd>Start: The text character position in Haystack in which to begin the search.
<dd>End: The text character position in Haystack immediately following the last
     character to search.
</dl>

<p>When Needle is text, this instruction is NOT sensitive to the case of
Haystack or Needle.  The case-sensitive version is replacetextEx().  If the
Needle is a lowercase word, the replacement will be changed to uppercase or
all caps if the found text is uppercase or all caps.

<h3>Example:</h3>
<xmp>
world << replacetext("One on one", "one", "two")
</xmp>

<p>This outputs "Two on two", where the first case's "One" is identified as
uppercase.

<p>You may use a proc as the Replacement value.  In that case, the proc will
be called with the found text as an argument, and its return value will be the
replacement.  There will be no automatic correction to uppercase or all caps
in this case.

<p>When the Needle value is a regular expression, this proc behaves identically
to the <a href=#/regex/proc/Replace>regex Replace()</a> proc.  Case-sensitivity,
and whether one match or all are replaced, depend on the regular expression.

<hr>

<a name=/proc/replacetextEx>
<h2>replacetextEx proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/findtextEx>findtextEx proc</a>
<dd><a href=#/proc/replacetext>replacetext proc</a>
<dd><a href=#/{notes}/regex>Regular expressions</a>
<dd><a href=#/regex/proc/Replace>Replace proc (regex)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>replacetextEx(Haystack,Needle,Replacement,Start=1,End=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>The Haystack text with all cases of Needle replaced by Replacement
</dl>

<dl><dt><b>Args:</b>
<dd>Haystack: The text string to search.
<dd>Needle: The sub-text to search for. May be a regular expression (regex).
<dd>Replacement: The replacement text, or a proc.
<dd>Start: The text character position in Haystack in which to begin the search.
<dd>End: The text character position in Haystack immediately following the last
     character to search.
</dl>

<p>When Needle is text, this instruction is sensitive to the case of Haystack
and Needle.  The case-insensitive version is replacetext().

<h3>Example:</h3>
<xmp>
world << replacetext("One on one", "one", "two")
</xmp>

<p>This outputs "Two on two", where the first case's "One" is identified as
uppercase.

<p>You may use a proc as the Replacement value.  In that case, the proc will
be called with the found text as an argument, and its return value will be the
replacement.  There will be no automatic correction to uppercase or all caps
in this case.

<p>When the Needle value is a regular expression, this proc behaves identically
to the <a href=#/regex/proc/Replace>regex Replace()</a> proc.  Case-sensitivity,
and whether one match or all are replaced, depend on the regular expression.

<hr>

<a name=/proc/return>
<h2>return proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/var/@dt;>. var (proc)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>return E
</dl>

<p>Stop execution of the current proc and return the value of E to the
caller.  If no value is specified, the value of '.' will be returned, which
defaults to null.

<hr>

<a name=/proc/rgb>
<h2>rgb proc</h2>

<dl><dt><b>Format:</b>
<dd>rgb(R,G,B)
<br/><i>or</i><br/>
rgb(R,G,B,A)
</dl>

<dl><dt><b>Args:</b>
<dd>R,G,B: Numbers from 0-255 corresponding to the red, green, and blue
components of a color.
<dd>A: Optional alpha component; 0 is transparent, 255 is opaque.
</dl>

<p>A way of representing a color to be used in conjunction with icon
arithmetic.  The colors rgb(0,0,0) and rgb(255,255,255) represent black and
white, two corners of the "color cube".

<h3>Example:</h3>
<xmp>
mob/proc/hurtme() // make a mob look damaged by adding red to his icon
  src.icon += rgb(20,0,0)
</xmp>

<p>This proc returns a text string in the form used by HTML (#RRGGBB).
rgb(255,0,128) for example becomes "#ff0080". If you use an alpha component,
the format is #RRGGBBAA. You can use strings like this in most procs that use
colors such as icon blending operations, and you can also use the short form
#RGB or #RGBA. So if you know in advance that you want to use the color
white, you can simply use"#fff" instead of rgb(255,255,255).

<hr>

<a name=/proc/roll>
<h2>roll proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/rand>rand proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>roll(ndice=1,sides)
<dd>roll(dice)
</dl>

<dl><dt><b>Returns:</b>
<dd>The sum of the rolled dice.
</dl>

<dl><dt><b>Args:</b>
<dd>ndice: number of dice to role.
<dd>sides: number of sides to the dice.
<dd>dice: a text string encoding both ndice and sides (see below).
</dl>

<p>The sides of the dice are numbered 1 through the total number of sides
and each is equally likely.

<p>An alternate form takes the dice parameters in a single text value such
as "3d4".  This may be useful when you want to store the dice information in
a single variable.  You can even specify an offset, such as "3d4+5".  That
adds 5 to the sum of 3 dice having 4 sides each.

<h3>Example:</h3>
<xmp>
obj/potion/healing
  var/dice = "3d6"
  verb/drink()
    var/h = roll(dice)
    if(h>15) usr << "Very refreshing!"
    else usr << "You feel better."
</xmp>

<hr>

<a name=/proc/round>
<h2>round proc</h2>

<dl><dt><b>Format:</b>
<dd>round(A)
<dd>round(A,B)
</dl>

<dl><dt><b>Returns:</b>
<dd>rounded A
</dl>

<dl><dt><b>Args:</b>
<dd>A: A number.
<dd>B: The nearest multiple to round A.
</dl>

<p>The first format returns the floor of A (the largest integer
less than or equal to A).  The second format rounds A to the nearest
multiple of B.

<h3>Example:</h3>
<xmp>
usr << round(1.45) // outputs 1

usr << round(-1.45) // outputs -2

usr << round(1.45,1.5) // outputs 1.5
</xmp>

<hr>

<a name=/proc/run>
<h2>run proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&lt;&lt;/output>&lt;&lt; output operator</a>
<dd><a href=#/proc/file>file proc</a>
<dd><a href=#/proc/link>link proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>O &lt;&lt; run(File)
</dl>

<p>This is similar to link() but instead of a URL, you can pass a file to be
viewed directly.  The file may be a cache file or an external file.

<h3>Example:</h3>
<xmp>
mob/var/picture = 'mob.jpg'
mob/verb/view_pic(mob/M as mob in view())
  usr << run(M.picture)

mob/verb/set_pic(F as file)
  usr.picture = F
</xmp>

<p>This example defines a picture to be associated with each mob and a verb
for viewing another mob's picture.  Players can also configure their own
pictures.

<hr>

<a name=/proc/set>
<h2>settings (proc)</h2>

<p>proc settings:

<code><pre>
verb/set
  <a href=#/verb/set/name>name</a>
  <a href=#/verb/set/desc>desc</a>
  <a href=#/verb/set/category>category</a>
  <a href=#/verb/set/hidden>hidden</a>
  <a href=#/verb/set/popup_menu>popup_menu</a>
  <a href=#/verb/set/instant>instant</a>
  <a href=#/verb/set/invisibility>invisibility</a>
  <a href=#/verb/set/src>src</a>
  <a href=#/proc/set/background>background</a>
</pre></code>

<p>Procs and verbs are the same "type" so these attributes may be set for both
procs and verbs; most of them only apply to verbs, so they only take effect if
the proc is invoked as a verb (by adding it to a verb list).

<hr>

<a name=/proc/set/background>
<h2>background setting (proc)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/sleep>sleep proc</a>
<dd><a href=#/proc/spawn>spawn proc</a>
</dl>

<p>To avoid lag from procedures that hog the CPU for too long, you can turn on
background processing.  This will cause it to periodically sleep for long
enough to allow other events to be processed.

<p>The following example is a typical "ticker" procedure.  It spawns off an
infinite loop which does some work and then sleeps before iterating again.  By
running this in the background, you ensure that the work being done does not
create large delays.  You could achieve a similar thing by sprinkling calls to
sleep(0) or sleep(-1) in the "working" part of the loop.

<h3>Example</h3>
<xmp>
proc/Ticker()
   set background = 1
   spawn while(1)
      for(var/mob/M in world)
         M.Tick()
      sleep(10)
</xmp>

<p>Since the background procedure sleeps at unpredictable times, you must be
aware that race conditions are possible if the background procedure interacts
with variables modified by other procedures.  It's still much safer than
multi-threaded programs because the background procedure never interrupts
other code; but other code may interrupt the background procedure.

<p>Note that procedures that are called by the background procedure do not
automatically run in the background unless they too have the background
setting turned on.  For instance, the code in the above example does not imply
that the mob Tick() procs would run in the background.  This is convenient,
because you should only ever apply background processing to code after
checking that there are no potential race conditions involved.

<p>If you have an eye for race conditions, you might think that the above code
has one in which a mob gets deleted after it is assigned to M but before the
call to M.Tick() is executed.  However, <em>background processing is only
interrupted at loop points in the code</em>, so the above code is safe.  It
would only ever be interrupted at the end of the <code>for</code> or
<code>while</code> loops.

<hr>

<a name=/proc/shell>
<h2>shell proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/fcopy>fcopy proc</a>
<dd><a href=#/proc/fdel>fdel proc</a>
<dd><a href=#/proc/file2text>file2text proc</a>
<dd><a href=#/world/var/system_type>system_type var (world)</a>
<dd><a href=#/proc/text2file>text2file proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>shell(Command)
</dl>

<dl><dt><b>Args:</b>
<dd>Command: system command to run
</dl>

<dl><dt><b>Returns:</b>
<dd>null on failure to execute command
<dd>exit code of command otherwise
</dl>

<p>This function is used to run an external program.  The syntax of Command
depends on the server machine's operating system.  Be sure to redirect input
and output to files if there is any.  Also realize that the command will
fail if the program you try to run is not in the path where the shell
expects to find executable files (unless you specify a full path).

<p>Since shell() allows arbitrary access to the system, each call requires
authorization from the person hosting the world, unless running in trusted
mode.  Authorization is only sought when running in Dream Seeker, since Dream
Daemon is intended to be non-interactive.  Calling shell() with no arguments
is a way of checking if it is allowed by the current safety settings.  It will
return true if running in Dream Seeker (regardless of safety mode) or if
running in Dream Daemon in trusted mode.

<p>The calling proc will sleep until the command is finished executing.

<h3>Example:</h3>
<xmp>
mob/verb/dir(Path as text)
  shell("dir [Path] > dir.out")
  usr << file2text("dir.out")
</xmp>

<p>This example displays the output of the "dir" command to the user.

<hr>

<a name=/proc/shutdown>
<h2>shutdown proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/proc/Export>Export proc (world)</a>
<dd><a href=#/proc/startup>startup proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>shutdown(Addr,Natural=0)
</dl>

<dl><dt><b>Args:</b>
<dd>Addr: This is the address of the child world returned by startup().
<dd>Natural: Specifies whether to wait for the child world to die
     naturally, or whether it should be killed with the "Del" world topic.
     The default value of 0 kills the child, and a value of 1 waits for the
     child to exit of its own accord.
</dl>

<p>If no address is specified, the current world is shut down.

<hr>

<a name=/proc/sin>
<h2>sin proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/arcsin>arcsin proc</a>
<dd><a href=#/proc/cos>cos proc</a>
<dd><a href=#/proc/turn>turn proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>sin(X)
</dl>

<dl><dt><b>Returns:</b>
<dd>The sin of X, where X is in degrees.
</dl>

<h3>Example:</h3>
<xmp>
mob/verb/test()
   usr << sin(0)  //0
   usr << sin(45) //0.707...
   usr << sin(90) //1
</xmp>

<hr>

<a name=/proc/sleep>
<h2>sleep proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/set/background>background setting (proc)</a>
<dd><a href=#/proc/spawn>spawn proc</a>
<dd><a href=#/world/var/tick_lag>tick_lag var (world)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>sleep(Delay)
</dl>
<dl><dt><b>Args:</b>
<dd>Delay: The amount of time to sleep, in 1/10 seconds.
</dl>

<p>Pause the current proc (and its callers) for a specified amount of time.
If no delay is specified, it will be scheduled to resume as soon as other
immediately pending events are processed.

<p>Note that sleeping in some procedures results in the return value being
lost.  For example, if you sleep inside <code>Enter()</code> or
<code>Exit()</code>, it will be as if you returned immediately where you
started sleeping.

<p>Also be aware, that a sleeping procedure whose <var>src</var> object gets
deleted will automatically terminate when execution returns to it.  This is
to protect you against trying to access properties or procedures of a
deleted (and therefore <code>null</code>) object.  If you do not want the
procedure to be terminated, you should set <var>src</var> to
<code>null</code>.

<p>One common use of <code>sleep</code> is to create what is known as a
<em>ticker</em>.  That is an infinite loop that performs some periodic
operation.

<h3>Example:</h3>
<xmp>
proc/Weather()
   spawn while(1) //infinite ticker loop
      world << "The sun rises in the east."
      sleep(500)
      world << "The noon day sun rises high in the sky."
      sleep(500)
      world << "The sun sinks low in the west."
      sleep(1000)
</xmp>

<p>Notice how such infinite loops are usually created using
<code>spawn</code> to prevent the caller from getting locked up.  You could
call this procedure from <code>world.New()</code> to start it rolling.

<p>Please note: sleep time is in 1/10s units, not server ticks.  If your
<code>world.tick_lag</code> or <code>world.fps</code> value is different from
the default, sleep(1) still means "sleep for 1/10s".  To sleep for exactly N
ticks, call <code>sleep(N * world.tick_lag)</code>.

<p>If the ticker does intensive processing during each iteration, you probably
want to run it in the background like this:

<xmp>
proc/Ticker()
   set background = 1
</xmp>

<p>Calling sleep() with a negative argument (such as sleep(-1)) causes it to
do a backlog check.  Only if other pending events have become backlogged will
it sleep.  This is similar to running in the background, but you manually
control where the backlog checks are made.  The difference between this and
sleep(0) is that sleep(0) <em>always</em> sleeps the current procedure for as
short a time as possible, whereas sleep(-1) only sleeps the current procedure
if other scheduled events have become backlogged.  Therefore, sleep(-1) will
tend to run the current procedure at a higher priority with fewer
interruptions.  It is appropriate when there is a single task that needs to be
done before anything else can happen, and you just want to make sure that
network and user I/O are not terribly lagged in the process.

<hr>

<a name=/proc/sorttext>
<h2>sorttext proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&gt;>&gt; operator</a>
<dd><a href=#/operator/&lt;>&lt; operator</a>
<dd><a href=#/proc/sorttextEx>sorttextEx proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>sorttext(T1,T2,...)
</dl>

<dl><dt><b>Args:</b>
<dd>Any number of text strings to sort.
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if text is ascending
<dd>-1 if text is descending
<dd>0 otherwise
</dl>

<p>This instruction is NOT sensitive to case.  The case sensitive version is
sorttextEx().

<h3>Example:</h3>
<xmp>
switch(sorttext("A","B"))
  if(1) world << "ascending"
  if(-1)world << "descending"
  if(0) world << "neither"
</xmp>

<p>This outputs "ascending", since "A" comes before "B" in the alphabet.

<hr>

<a name=/proc/sorttextEx>
<h2>sorttextEx proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&gt;>&gt; operator</a>
<dd><a href=#/operator/&lt;>&lt; operator</a>
<dd><a href=#/proc/sorttext>sorttext proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>sorttextEx(T1,T2,...)
</dl>

<dl><dt><b>Args:</b>
<dd>Any number of text strings to sort.
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if text is ascending
<dd>-1 if text is descending
<dd>0 otherwise.
</dl>

<p>This instruction is sensitive to case.  The case-insensitive version is
sorttext().

<p>NOTE: Uppercase letters are lower in the alphabetical order than
lowercase letters.

<h3>Example:</h3>
<xmp>
switch(sorttextEx("a","B"))
  if(1) world << "ascending"
  if(-1)world << "descending"
  if(0) world << "neither"
</xmp>

<p>This outputs, "descending", since "B" comes before "a" in the alphabet.

<p>Note: This proc used to be named sortText, like sorttext but with a capital T.
To avoid confusion it has been renamed, but old code will still compile.

<hr>

<a name=/proc/sound>
<h2>sound proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&lt;&lt;/output>&lt;&lt; output operator</a>
</dl>
<dl><dt><b>Format:</b>
<dd>sound(file,repeat=0,wait,channel,volume)
<dd><small>(supports named arguments)</small>
</dl>

<dl><dt><b>Args:</b>
<dd>file: A sound file to play
<dd>repeat: 1 to play sound repeatedly
<dd>wait: 0 to interrupt current sound on channel; 1 to wait in queue
<dd>channel: 0 for any available channel, 1-8 for specific channel (wavs only)
<dd>volume: 100 for full volume (default), 0 for none, or any value in between
</dl>

<p>This is used to play a sound file.

<p>The sound file must be a music or sample file. Music files include MIDI
(.mid or .midi), and module formats .mod, .it, .s3m, .xm, and .oxm. A sample
file used for sound effects can be .wav, .ogg, .raw, .wma, or .aiff.*

<p>The following example plays some sound files.  Note that
<code>sound()</code> is not even necessary when you don't need to set any
additional parameters.

<h3>Example:</h3>
<xmp>
usr << 'giggle.wav' // play a giggle once
usr << sound('gigue.midi',1) // repeat gigue
usr << sound('boom.wav', volume=50) // play an explosion at half volume
</xmp>

<p><small>*See <b>Notes</b> under <a href="#/DM/sound">sound support</a> for
more information.</small>

<hr>

<a name=/proc/spantext>
<h2>spantext proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/findtext>findtext proc</a>
<dd><a href=#/proc/nonspantext>nonspantext proc</a>
<dd><a href=#/proc/splittext>splittext proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>spantext(Haystack,Needles,Start=1)
</dl>

<dl><dt><b>Returns:</b>
<dd>The number of consecutive characters, from the start position, that match the characters in Needles.
</dl>

<dl><dt><b>Args:</b>
<dd>Haystack: The text string to search.
<dd>Needles: A text string with all the characters that match.
<dd>Start: The text character position in Haystack in which to begin the search.
</dl>

<p>This proc is case-sensitive.  A common use for this proc is in parsing.
spantext("apples, oranges",", ",7) will tell you that, starting at position 7,
you need to skip 2 characters to get past any commas or spaces.

<p>If the start position is negative, the position is counted backwards from
the end of the string.

<hr>

<a name=/proc/spawn>
<h2>spawn proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/set/background>background setting (proc)</a>
<dd><a href=#/proc/sleep>sleep proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>spawn(Delay=0) Statement
</dl>

<dl><dt><b>Args:</b>
<dd>Delay: The amount of time (in 1/10 seconds) before Statement is executed.
</dl>

<p>Run Statement after a delay.  Statement may be a single statement or a code
block enclosed in (optional) braces and indented.  If delay is negative, the
spawned code is executed before continuing in the main code.  If it is zero,
the spawned code is scheduled to happen right after other existing events that
are immediately pending.

<h3>Example:</h3>
<xmp>
spawn(30) storm()
usr << "Storm clouds are brewing!"
</xmp>

<p>This will display <code>"Storm clouds are brewing!"</code> and then call the
storm() proc after 3 seconds.

<p>The important feature of spawn() is that the caller does not have to wait
around for the spawned code to finish.

<p>Any vars you have defined in the proc itself, including arguments, will be
copied between the spawned code and the code that runs right away. This means
that if one part modifies one of those vars, the other part will not see that
change. Changes made to objects, lists, datums, etc. however will be visible
to both code blocks.

<hr>

<a name=/proc/splittext>
<h2>splittext proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/findtext>findtext proc</a>
<dd><a href=#/proc/jointext>jointext proc</a>
<dd><a href=#/proc/nonspantext>nonspantext proc</a>
<dd><a href=#/proc/spantext>spantext proc</a>
<dd><a href=#/{notes}/regex>Regular expressions</a>
</dl>

<dl><dt><b>Format:</b>
<dd>splittext(Text,Delimiter,Start=1,End=0,include_delimiters=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>A list of text strings split by the delimiter given.
</dl>

<dl><dt><b>Args:</b>
<dd>Text: The text string to search.
<dd>Delimiter: A text string that will be used as the separator between items,
     OR a regular expression (regex) used to find splits
<dd>Start: The text character position in Text in which to begin.
<dd>End: The text character position in Text immediately following the last
     character to include in the splitting process.
<dd>include_delimiters: True if any delimiters found should be included in
     the result.
</dl>

<p>Splits up a text string and returns a list.  The delimiter is
case-sensitive (unless you use a case-insensitive regular expression), and
can be more than one character long.

<h3>Example:</h3>
<xmp>
var/list/items = splittext("apples,oranges,bananas", ",")
// prints "apples", "oranges", and "bananas" separately
for(var/item in items)
    usr << item
</xmp>

<p>Where multiple delimiters are next to each other, they're considered to be
separating an empty string.  Therefore splittext("a,,b,c", ",") would return a
list with four elements instead of three.  Splitting empty text returns an
empty list.

<p>If a regular expression is used as the delimiter, any capturing groups in
the expression will be included in the list, in order. (The whole match itself
will come first, if include_delimiters is true.) So for instance splitting by
regex(",") will not include the comma, but splitting by regex("(,)") will.
Groups that were not part of the match will be null.

<p>If the start or end position is negative, the position is counted backwards
from the end of the string.

<hr>

<a name=/proc/sqrt>
<h2>sqrt proc</h2>

<dl><dt><b>Format:</b>
<dd>sqrt(A)
</dl>

<dl><dt><b>Returns:</b>
<dd>The square root of A
</dl>

<dl><dt><b>Args:</b>
<dd>A: A number.
</dl>

<h3>Example:</h3>
<xmp>
usr << sqrt(2) // outputs 1.41421
</xmp>

<hr>

<a name=/proc/startup>
<h2>startup proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/params>params var (world)</a>
<dd><a href=#/proc/shutdown>shutdown proc</a>
</dl>


<dl><dt><b>Format:</b>
<dd>startup(File,Port=0,Options,...)
</dl>

<dl><dt><b>Args:</b>
<dd>File: The dmb file to run in a new server or null to load the current world.
<dd>Port: The network port to start the new server on.  A value of 0
          indicates that any available port should be used.
<dd>Options: Any number of the options listed below.  Each option should be
             in an argument by itself.  If the option takes a parameter, this
             can be in the same argument or in the following one.
</dl>

<h3>The valid options are:</h3>
<dl>

<dt>-once
<dd> automatically shuts down the server when all players have logged off.

<dt>-close
<dd>Closes the child copy of DreamDaemon after the world it is running shuts
down.

<dt>-log &lt;logfile&gt;
<dd>sends all server output to the specified file.  The path to the file is
relative to the world directory (the path containing the world
<code>.dmb</code> file).

<dt>-logself
<dd>is identical to "-log [YourWorldFile].log".

<dt>-safe
<dd>runs the server in a special protective mode.  The server may only
access files in the same directory (or below) as the dmb file and access to
the shell() command is disabled.  This is the default mode if no security
setting is specified and the world is run from a directory by the same name
as the dmb file.

<dt>-home &lt;path&gt;
<dd>runs with the specified "safe home" directory.  Normally, in safe mode
the directory containing the world dmb file is the safe home.

<dt>-ultrasafe
<dd>like -safe, this prohibits all file access.  This is the default if no
security mode is specified and the world is not run from a directory with
the same name.

<dt>-trusted
<dd>allows full access to files on the computer and to the shell() command.
Note that this does not bypass the normal security of the operating system.
For example, in the UNIX operating system, all of the usual access
restrictions apply.  This mode merely removes BYOND's built-in safety checks.

<dt>-params &lt;paramtext&gt;
<dd>this is for passing user-defined parameters to the world.  Multiple
parameters may be packed into a single argument or -params may be used
several times.  In either case, the parameters are all loaded into
world.params when the world starts up.  The parameter format is
"name1=value1&name2=value2&...".

<dt>-quiet
<dd>disables the server's normal output indicating the BYOND version number
and network port.

<dt>-nologdates
<dd>disables automatic date/time output in the log.

<dt>-CGI
<dd>runs the world as a CGI program (to be executed by a web server).  A
/client object is automatically created for the user and any output sent to
the associated mob gets returned to the user's web browser.  This option is
normally specified in the compile-time setting:
<a href=#/world/var/executor>world.executor</a>, which is automatically
initialized for you if you include <code>html/CGI.dm</code> from the html
library.

<dt>-suid &lt;path&gt;
<dd>runs the world as the owner of the specified directory or path.  This only
works if DreamDaemon is running as root on operating systems where there even
is such a thing.

<dt>-suidself
<dd>runs the world as the owner of the world dmb file.  This only works if
DreamDaemon is running as root on operating systems where there even is such a
thing.

<dt>-cd &lt;path&gt;
<dd>runs with the specified working directory.  Normally, the directory
containing the world dmb file is used.

<dt>-port P
<dd>sets the network port to P.  The port may also be specified as a
positional argument (following the .dmb name).

<dt>-ports &lt;list&gt;
<dd>restricts the range of ports that DreamDaemon and any child worlds may
use.  The syntax of <i>list</i> is a comma separated list of ports or ranges
of ports.  Example: <code>-ports 1234,1236,1240-1250</code>.

<dt>-ip &lt;address&gt;
<dd>sets the IP address of the server. This will only work for an IP address
the system recognizes as one it can use for hosting. Accepts numerical
addresses only.

<dt>-webclient
<dd>Enables the webclient, overriding default behavior.

<dt>-nowebclient
<dd>Disables the webclient, overriding default behavior.

<dt>-verbose
<dd>Runtime errors will continue outputting details after a certain number of
errors has been reached. Without this option, the number of errors that
provide detailed info (such as call stack) is limited. Use this option with
caution as it could fill up a log file quickly if a problem occurs.

</dl>


<dl><dt><b>Returns:</b>
<dd>The address of the new server in the form ip:port.
</dl>

<hr>

<a name=/proc/stat>
<h2>stat proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/Stat>Stat proc (atom)</a>
<dd><a href=#/client/proc/Stat>Stat proc (client)</a>
<dd><a href=#/proc/statpanel>statpanel proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>stat(Name,Value)
</dl>

<dl><dt><b>Args:</b>
<dd>Name: the name of the stat line
<dd>Value: the data to be displayed
</dl>

<p>This is used in a Stat() proc to send a stat line to usr, the person
looking at an object.  A stat line has an optional name part which must be
unique for each stat line (or successive calls will replace previous ones).

<p>The stat line gets appended to the current stat panel.  The current panel
may be changed by using statpanel().

<p>If no name is specified and the value is a list, this is the same as
calling stat on each item in the list.  This can be used (in conjunction
with statpanel) to create an inventory panel or something similar.

<h3>Example:</h3>
<xmp>
mob/Stat()
   stat("description",src.desc)
   if(src == usr) stat(src.contents)
</xmp>

<p>This example displays the mob's description and inventory all in one panel.
The code ensures that only the mob may see his own inventory, but you don't
have to worry about that unless you change client.statobj to something other
than one's own mob.

<hr>

<a name=/proc/statpanel>
<h2>statpanel proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/proc/Stat>Stat proc (atom)</a>
<dd><a href=#/client/proc/Stat>Stat proc (client)</a>
<dd><a href=#/proc/stat>stat proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>statpanel(Panel,Name,Value)
</dl>

<dl><dt><b>Args:</b>
<dd>Panel: the name of the stat panel
<dd>Name: the name of the stat line
<dd>Value: the data to be displayed
</dl>

<dl><dt><b>Returns:</b>
<dd>If called with just a Panel argument, 1 is returned if the player is
    looking at the panel and 0 is returned if not.  This may be useful to
    avoid the needless overhead of generating output to a panel that is not
    visible.
</dl>

<p>This is used in a Stat() proc to change the default panel (for subsequent
stat lines) or to send one line to the specified panel.  Name and Value are
both optional.  If neither is specified, this simply changes the default
panel.  Otherwise, the default panel is unchanged and a stat line is
appended to Panel.

<h3>Example:</h3>
<xmp>
mob/Stat()
   stat("description",src.desc)
   if(src == usr) statpanel("inventory",src.contents)
</xmp>

<p>This example displays the mob's description in one panel and inventory in
another.  Only the mob may see his own inventory, but you don't have to worry
about that unless you change client.statobj to something other than one's own
mob.

<hr>

<a name=/proc/step>
<h2>step proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/get_step>get_step proc</a>
<dd><a href=#/proc/walk>walk proc</a>
<dd><a href=#/atom/movable/var/step_size>step_size var (movable atom)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>step(Ref,Dir,Speed=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 on success; 0 otherwise
</dl>

<dl><dt><b>Args:</b>
<dd>Ref: A mob or obj.
<dd>Dir: One of NORTH, SOUTH, EAST, WEST, NORTHEAST, NORTHWEST, SOUTHEAST,
     SOUTHWEST.
<dd>Speed: Speed to move, in pixels. 0 uses Ref.step_size.
</dl>

<p>Move Ref in the direction Dir.

<hr>

<a name=/proc/step_away>
<h2>step_away proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/get_step_away>get_step_away proc</a>
<dd><a href=#/proc/walk_away>walk_away proc</a>
<dd><a href=#/atom/movable/var/step_size>step_size var (movable atom)</a>
</dl>
<dl><dt><b>Format:</b>
<dd>step_away(Ref,Trg,Max=5,Speed=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 on success; 0 otherwise.
</dl>

<dl><dt><b>Args:</b>
<dd>Ref: A mob or obj.
<dd>Trg: An object on the map.
<dd>Max: The maximum distance between Ref and Targ before movement halts.
<dd>Speed: Speed to move, in pixels. 0 uses Ref.step_size.
</dl>

<p>Move Ref on a path away from location Trg, taking obstacles into
account.  If Ref is farther than Max steps from Trg, no action will be taken.

<hr>

<a name=/proc/step_rand>
<h2>step_rand proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/get_step_rand>get_step_rand proc</a>
<dd><a href=#/proc/walk_rand>walk_rand proc</a>
<dd><a href=#/atom/movable/var/step_size>step_size var (movable atom)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>step_rand(Ref,Speed=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 on success; 0 otherwise.
</dl>

<dl><dt><b>Args:</b>
<dd>Ref: A mob or obj.
<dd>Speed: Speed to move, in pixels. 0 uses Ref.step_size.
</dl>

<p>Move Ref randomly.

<hr>

<a name=/proc/step_to>
<h2>step_to proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/get_step_to>get_step_to proc</a>
<dd><a href=#/proc/walk_to>walk_to proc</a>
<dd><a href=#/atom/movable/var/step_size>step_size var (movable atom)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>step_to(Ref,Trg,Min=0,Speed=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 on success; 0 otherwise.
</dl>

<dl><dt><b>Args:</b>
<dd>Ref: A mob or obj.
<dd>Trg: An object on the map.
<dd>Min: The minimum distance between Ref and Trg before movement halts.
<dd>Speed: Speed to move, in pixels. 0 uses Ref.step_size.
</dl>

<p>Move Ref on a path to the location Trg, taking obstacles into account.  If
Ref is within Min steps of Trg, no action will be taken.  This is also the
case if the target is too far away (more than twice world.view steps).

<hr>

<a name=/proc/step_towards>
<h2>step_towards proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/get_step_towards>get_step_towards proc</a>
<dd><a href=#/proc/walk_towards>walk_towards proc</a>
<dd><a href=#/atom/movable/var/step_size>step_size var (movable atom)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>step_towards(Ref,Trg,Speed)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 on success; 0 otherwise.
</dl>

<dl><dt><b>Args:</b>
<dd>Ref: A mob or obj.
<dd>Trg: An object on the map.
<dd>Speed: Speed to move, in pixels. 0 uses Ref.step_size.
</dl>

<p>Move Ref in the direction of the location Trg.

<hr>

<a name=/proc/switch>
<h2>switch proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/if>if proc</a>
</dl>

<dl><dt><b>Format:</b>
  <dl><dt>switch(E)
      <dd>if(A1,A2,...) Statement1
      <dd>if(B1,B2,...) Statement1
      <dd>else Statement3
  </dl>
</dl>

<p>The "switch" instruction is a compact notation for a lengthy "else-if"
chain.  The expression E is compared to the values A1, A2, B1, B2, etc.
When a match is found, the following statement (or code block) is executed.
An optional "else" statement is run if no match is found.  Once a matching
switch condition is found, no further conditions will be tested.

<p>The values A1, A2, etc. must be constants.  As a convenience, a range of
values may be specified in the form: A1 to An.

<p>The switch instruction is MUCH more efficient than a lengthy "else-if"
chain, because the expression E is evaluated only once.  The conditional
values may be any constant expression, such as a number or text string.


<h3>Example:</h3>
<xmp>
switch (2)
  if(1)       world << "ONE"
  if(4)       world << "FOUR"
  if(2,3)     world << "TWO or THREE"
  if(5 to 10) world << "FIVE to TEN"
  else        world << "not ONE to TEN"
</xmp>

<p>This outputs:

<xmp>
TWO or THREE
</xmp>

<hr>

<a name=/proc/text>
<h2>text proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&lt;&lt;>&lt;&lt; operator</a>
<dd><a href=#/DM/text/macros>macros (text)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>text(FormatText,Args)
</dl>

<dl><dt><b>Returns:</b>
<dd>The text with macros arguments substituted.
</dl>

<dl><dt><b>Args:</b>
<dd>FormatText: a text string possibly containing text macros.
<dd>Args: a set of arguments that corresponds to the number of empty
     embedded expressions in FormatText.
</dl>

<p>Complicated or lengthy embedded expressions in a text string can
sometimes make the string difficult to read.  In this case, one can use
trailing arguments.  The position in which the expression should be
substituted should be marked with [] and the expression should then be
passed as an argument after the text string.

<h3>Example:</h3>
<xmp>
usr << text("You are [] leagues from home.",sqrt(usr.x**2 + usr.y**2))
</xmp>

<hr>

<a name=/proc/text2ascii>
<h2>text2ascii proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/ascii2text>ascii2text proc</a>
<dd><a href=#/DM/text/entities>entities (text)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>text2ascii(T,pos=1)
</dl>

<dl><dt><b>Returns:</b>
<dd>A number.
</dl>

<dl><dt><b>Args:</b>
<dd>T: A text string.
<dd>pos: The character position in T to use.
</dl>

<p>ASCII codes are numerical values corresponding to keyboard and special characters.
Among other things, they are used to represent many symbols in HTML. This proc converts
a text string to its corresponding ascii representation.

<h3>Example:</h3>
<xmp>
num = text2ascii("A")  // = 65
num = text2ascii("HAPPY",2)  // = 65
</xmp>

<hr>

<a name=/proc/text2file>
<h2>text2file proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/file2text>file2text proc</a>
<dd><a href=#/proc/shell>shell proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>text2file(Text,File)
</dl>

<dl><dt><b>Args:</b>
<dd>Text: text to be added to file
<dd>File: file to be appended to
</dl>

<dl><dt><b>Returns:</b>
<dd>1 on success; 0 otherwise.
</dl>

<p>Appends text to a file.  If the file does not exist, one will be created.

<p>This can be useful when interacting with external applications that read
output from a text file.  For example, you might have an external program
that mimics conversation:

<h3>Example:</h3>
<xmp>
mob/oracle/verb/tell(T as text)
  text2file(T,"oracle.in")
  shell("oracle < oracle.in > oracle.out")
  usr << file2text("oracle.out")
</xmp>

<hr>

<a name=/proc/text2num>
<h2>text2num proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/istext>istext proc</a>
<dd><a href=#/proc/num2text>num2text proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>text2num(T)
</dl>

<dl><dt><b>Returns:</b>
<dd>A number.
</dl>

<dl><dt><b>Args:</b>
<dd>T: A text string.
</dl>

<p>If T is a text string for a number, return the number.  Any non-numeric
text following the initial portion will be ignored.  If there is no initial
numeric portion, the result is null.

<h3>Example:</h3>
<xmp>
num = text2num("123")  // = 123
</xmp>

<hr>

<a name=/proc/text2path>
<h2>text2path proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/ispath>ispath proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>text2path(T)
</dl>

<dl><dt><b>Returns:</b>
<dd>a type path or null.
</dl>

<dl><dt><b>Args:</b>
<dd>T: A text string.
</dl>

<h3>Example:</h3>
<xmp>
var/myturf = text2path("/turf/[src.color]")
if(myturf)
  src.loc = locate(myturf)
</xmp>

<p>T is changed from a text string to the equivalent type path, or null if
  there is no such type.

<hr>

<a name=/proc/throw>
<h2>throw keyword</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/try>try keyword</a>
<dd><a href=#/world/proc/Error>Error proc (world)</a>
<dd><a href=#/proc/EXCEPTION>EXCEPTION macro</a>
<dd><a href=#/exception>exception</a>
</dl>

<dl><dt><b>Format:</b>
<dd>throw Value
</dl>

<dl><dt><b>Args:</b>
<dd>Value: Any value, which will be sent to catch() if present.
</dl>

<p>This keyword throws an exception, which will stop exceuting the current
proc and go to the most recent catch block if one is present. The catch block
will receive the thrown value. If there is no try/catch in use, the exception
will be passed to world.Error() (if present), then the current proc will end
and control will return to the caller.

<h3>Example:</h3>
<xmp>
try
  if(!src.ready) throw EXCEPTION("Not ready")
  DoSomething()
catch(var/e)
  world.log << "Exception: [e]"
</xmp>

<p>You can use the EXCEPTION macro to create a new /exception datum, which
contains a value or message as well as the file and line number where the
exception was created. The thrown value does not have to be an /exception
datum; you can throw anything, even null.

<hr>

<a name=/proc/time2text>
<h2>time2text proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/realtime>realtime var (world)</a>
<dd><a href=#/world/var/timeofday>timeofday var (world)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>time2text(timestamp,format)
</dl>

<dl><dt><b>Args:</b>
<dd>timestamp: a time value as obtained from world.realtime or world.timeofday
<dd>format: a text string describing the output format.
</dl>

<dl><dt><b>Returns:</b>
<dd>a text string containing the date and time in the specified format.
</dl>

<p>A time value (GMT) is converted to text representing the time in the game's
time zone.

<p>The default format is "DDD MMM DD hh:mm:ss YYYY", which produces results
such as "Wed, May 23 15:41:13 2001".  As you can see, the fields in the format
text are replaced by components of the date and time.  The following list
contains all of the recognized fields.  Anything else in the format string is
inserted directly into the output.

<dl compact>
<dt>YYYY <dd>year (2001, 2002, ...)
<dt>YY <dd>year (01, 02, ...)
<dt>Month <dd>January, February, ...
<dt>MMM <dd>Jan, Feb, ...
<dt>MM  <dd>number of the month (01, 02, ...)
<dt>Day <dd>Monday, Tuesday, ...
<dt>DDD <dd>Mon, Tue, ...
<dt>DD  <dd>day of the month
<dt>hh <dd>hour (00, 01, ... 23)
<dt>mm <dd>minute
<dt>ss <dd>second
</dl>

<p>Because world.timeofday is in a range of 0 to 864000, values in this range
are treated as a time for the current date. This way time2text() can return
accurate results for world.timeofday. Any other values are interpreted as
coming from world.realtime and will have the right time and date.

<hr>

<a name=/proc/try>
<h2>try and catch keywords</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/proc/Error>Error proc (world)</a>
<dd><a href=#/proc/throw>throw keyword</a>
<dd><a href=#/proc/EXCEPTION>EXCEPTION macro</a>
<dd><a href=#/exception>exception</a>
</dl>

<p>The try and catch keywords are used for error handling. Any code that runs
inside of a try block will, if an error happens or the throw keyword is used,
stop executing and jump to the matching catch block. (This is also true of
indirect proc calls. If you call a proc from inside a try block, any errors
in that proc will be sent to the catch.)

<p>For every try there must be a catch, even if it does nothing. The catch
block takes an optional value that can receive the error.

<h3>Example:</h3>
<xmp>
var/a = 2
try
  a += "Hello"  // will throw a type mismatch error
catch(var/exception/e)
  // file and line info is available if you enable debugging
  world.log << "[e] on [e.file]:[e.line]"
world << "a is [a]"
</xmp>

<p>Because the value in the catch keyword is optional, you can simply use the
catch keyword alone. It is also not necessary to include any code under the
catch keyword, if the error is meant to be ignored. (However, it is not
usually a good idea to ignore errors.)

<p>The throw keyword is used if you want to throw an error deliberately. When
you use throw, the error thrown does not have to be an /exception datum, but
can be anything you like.

<hr>

<a name=/proc/turn>
<h2>turn proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/icon/proc/Turn>Turn proc (icon)</a>
<dd><a href=#/atom/var/dir>dir var (atom)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>turn(Dir, Angle)
</dl>

<dl><dt><b>Returns:</b>
<dd>The rotated direction.
</dl>

<dl><dt><b>Args:</b>
<dd>Dir: One of NORTH, SOUTH, EAST, WEST, NORTHEAST, NORTHWEST, SOUTHEAST, SOUTHWEST.
<dd>Angle:  An angle in degrees.
</dl>

<h3>Example:</h3>
<xmp>
var/dir
dir = turn(NORTH, 90)  // dir = west
dir = turn(dir, -90)   // dir = north
dir = turn(dir, 45)    // dir = northwest
</xmp>

<hr>

<a name=/proc/turn/icon>
<h2>turn proc (applied to an icon)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/turn>turn proc</a>
<dd><a href=#/icon>icon</a>
</dl>

<dl><dt><b>Format:</b>
<dd>turn(Icon, Angle)
</dl>

<dl><dt><b>Returns:</b>
<dd>The rotated icon.
</dl>

<dl><dt><b>Args:</b>
<dd>Icon: an icon to rotate
<dd>Angle: An angle in degrees (clockwise rotation).
</dl>

<h3>Example:</h3>
<xmp>
mob/verb/drink()
   //this effect is very confusing!
   usr.icon = turn(usr.icon,90)
   usr << "Woah!  That stuff is powerful!"
   sleep(200)
   usr.icon = turn(usr.icon,-90)
</xmp>

<p>An icon that is not square will not be turned.

<p>If the icon is an /icon datum, a new datum will be created as the result.

<hr>

<a name=/proc/turn/matrix>
<h2>turn proc (applied to a matrix)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/turn>turn proc</a>
<dd><a href=#/matrix>matrix</a>
</dl>

<dl><dt><b>Format:</b>
<dd>turn(Matrix, Angle)
</dl>

<dl><dt><b>Returns:</b>
<dd>A new matrix which has been rotated.
</dl>

<dl><dt><b>Args:</b>
<dd>Matrix: a matrix to rotate
<dd>Angle: An angle in degrees (clockwise rotation).
</dl>

<h3>Example:</h3>
<xmp>
mob/verb/drink()
   //this effect is very confusing!
   usr.transform = turn(usr.transform, 90)
   usr << "Woah!  That stuff is powerful!"
   sleep(200)
   usr.transform = null
</xmp>

<hr>

<a name=/proc/typesof>
<h2>typesof proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/istype>istype proc</a>
<dd><a href=#/proc/locate>locate proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>typesof(Type1,Type2,...)
</dl>

<dl><dt><b>Returns:</b>
<dd>A list of all types that are derived from the specified "base" types.
</dl>

<dl><dt><b>Args:</b>
<dd>The "base" types.
</dl>

<h3>Example:</h3>
<xmp>
obj/fruit
  apple
  peach
  mango
var/list/fruit_types = typesof(/obj/fruit)
</xmp>

<p>In this example, fruit_types is initialized to contain /obj/fruit,
/obj/fruit/apple, /obj/fruit/peach, and /obj/fruit/mango.

<p>This procedure can also be used to list procs and verbs.

<h3>Example:</h3>
<xmp>
mob/admin_commands/verb
   shutdown_world()
      world.Del()
   reboot_world()
      world.Reboot()

//for testing
mob/verb/add_admin()
   verbs += typesof(/mob/admin_commands/verb)
mob/verb/remove_admin()
   verbs -= typesof(/mob/admin_commands/verb)
</xmp>

<hr>

<a name=/proc/uppertext>
<h2>uppertext proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/lowertext>lowertext proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>uppertext(T)
</dl>

<dl><dt><b>Returns:</b>
<dd>A capitalized text string.
</dl>

<dl><dt><b>Args:</b>
<dd>T: A text string.
</dl>

<p>Capitalize all of the characters of T.

<h3>Example:</h3>
<xmp>
U = uppertext("hi there") // = "HI THERE"
</xmp>

<hr>

<a name=/proc/url_decode>
<h2>url_decode proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Topic>Topic proc (client)</a>
<dd><a href=#/proc/url_encode>url_encode proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>url_decode(UrlText)
</dl>

<dl><dt><b>Args:</b>
<dd>UrlText: text to be "unescaped"
</dl>

<dl><dt><b>Returns:</b>
<dd>unescaped text
</dl>

<p>Most non-alphanumeric characters are converted to another format in a URL.
To send these characters literally, they must be "escaped".

<p>The <code>url_decode()</code> instruction takes a text string containing
such escaped symbols and turns them into their literal counterparts.  Usually
this is done for you automatically in <code>Topic()</code>. The more useful
function is <code>url_encode()</code> which does the reverse.

<hr>

<a name=/proc/url_encode>
<h2>url_encode proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/url_decode>url_decode proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>url_encode(PlainText, format=0)
</dl>

<dl><dt><b>Args:</b>
<dd>PlainText: text to be URL "escaped"
<dd>format: 0 to treat PlainText as a query string, 1 to treat it as a full URL
</dl>

<dl><dt><b>Returns:</b>
<dd>escaped text
</dl>

<p>Special characters such as spaces are not used literally in URLs.
If you want to ensure that an entire text string is sent literally, you can
"escape" those characters.  For example, a double quote (ASCII 34) is produced
by the code <code>%22</code>, where 22 is hexadecimal for 34.

<p>The <code>url_encode()</code> instruction does this for you
automatically. Using <code>format=1</code> will treat the URL as already
encoded and only re-encode characters that don't belong in the result.
Otherwise PlainText is treated as part of a query string; in this case spaces
are converted to <code>+</code> instead of <code>%20</code>, and most
characters are escaped.

<h3>Example:</h3>
<xmp>
mob/verb/Private(M as mob in players, T as text)
   if(!client || !M || !M.client || !T) return
   usr << "\[To <a href='?msg=[url_encode(M.key)]'>[M.name]</a>\] [T]"
   M << "\[From <a href='?msg=[url_encode(key)]'>[name]</a>\] [T]"
</xmp>

<hr>

<a name=/proc/var>
<h2>vars (procs)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc>procs</a>
</dl>

<p>Built-in proc vars:

<dl><dt>proc/var
<dd><a href=#/proc/var/@dt;>.</a>
<dd><a href=#/proc/var/args>args</a>
<dd><a href=#/proc/var/src>src</a>
<dd><a href=#/proc/var/usr>usr</a>
</dl>

<hr>

<a name=/proc/var/@dt; toc=".">
<h2>. var (proc)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/return>return proc</a>
<dd><a href=#/proc/var>vars (procs)</a>
</dl>

<p>This is the default return value.  If a proc exits without calling return
or if no arguments are specified the value of '.' will be returned.  The
default value of '.' is null.

<h3>Example:</h3>
<xmp>
mob/Login()
  . = ..()
  view() << "[src] logs in."
</xmp>

<hr>

<a name=/proc/var/args>
<h2>args list var (proc)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/list>list</a>
</dl>

<p>This is a list of the arguments passed to the proc or verb.

<h3>Example:</h3>
<xmp>
proc/add()
  var {cur; tot}
  for(cur in args)
    tot += cur
  return tot
</xmp>

<p>Here, add() may be called with any number of arguments, each accessed
through the args list.

<hr>

<a name=/proc/var/global>
<h2>global var (proc)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/var/src>src var (proc)</a>
</dl>

<p>This is not really a variable but is used to force treatment of the
following variable or proc as global.  This may be necessary if a local or
src-level variable has the same name.

<h3>Example:</h3>
<xmp>
var/myvar = "global"
mob
  verb/test()
    var/myvar = "local"
    usr << myvar
    usr << global.myvar
</xmp>

<p>This example outputs "local" and then "global".

<hr>

<a name=/proc/var/src>
<h2>src var (proc)</h2>

<p>This is a variable equal to the object containing the proc or verb.  It
is defined to have the same type as that object.

<h3>Example:</h3>
<xmp>
obj/bread
  verb/eat()
    world << "[usr] eats [src]"
</xmp>

<p>If a player named "Bob" calls "eat bread", the output will be "Bob eats
the bread."

<p>Note that src has no meaning for global procs, derived from /proc, unless
they are invoked as verbs (by being attached to a verb list).

<hr>

<a name=/proc/var/usr>
<h2>usr var (proc)</h2>

<p>This is a mob variable (var/mob/usr) containing the mob of the player who
executed the current verb, or whose action ultimately called the current
proc.

<h3>Example:</h3>
<xmp>
obj/bread
  verb/eat()
    world << "[usr] eats [src]"
</xmp>

<p>If a player named "Bob" calls "eat bread", the output will be "Bob eats
the bread."

<p>Essentially, usr is an implicit parameter that is passed to every proc or
verb.  Each procedure inherits the value from its caller.  While it can
simplify your code in some situations, it can also lead to subtle problems if
you are assuming that usr is automatically assigned to src when you call a
verb programmatically.  It is not.

<p>The only time usr is assigned for you is when a player (in Dream Seeker)
executes a verb, clicks something with the mouse, or any other such action.

<p><b>A good rule of thumb is to never put usr in a proc.</b> Typically this
is an unsafe programming practice, even when you know that a certain proc is
only ever called by a verb, because it is common during development to change
the way or time at which a proc is called. If src would not be the correct
choice, it is better to send another argument to your proc with the
information it needs.

<p>Certain built-in procs such as <a href=#/atom/proc/Click>mob/Click()</a>
are called automatically by a client counterpart like
<a href=#/client/proc/Click>client/Click()</a>; usually
<a href=#/atom/proc/Click>atom/Stat()</a> is called by
<a href=#/client/proc/Click>client/Stat()</a>; and so on. It is mostly safe
to apply usr as directed in those situations. It is mostly <em>not</em> safe
to apply usr in a movement proc such as
<a href=#/atom/movable/proc/Move>Move()</a> or
<a href=#/atom/proc/Enter>Enter()</a>, because objs and non-player mobs may
move as well, without setting usr.

<p>Although usr is often set in <a href=#/mob/proc/Login>mob/Login()</a> when
a client first connects, you should not assume it is valid if Login() is
called any other way. Common cases occur when creating a new character,
loading a player's mob from a savefile; or explicitly when setting a mob's
key or changing the value of <a href=#/client/var/mob>client.mob</a>. It is
safest to use src in mob/Login(), which is always correct, rather than usr.

<p>usr is the default point of reference for several procs like
<a href=#/proc/view>view()</a> and <a href=#/proc/range>range()</a>, because
of their common use in verbs. It is also the default recipient for
<a href=#/proc/input>input()</a> and <a href=#/proc/alert>alert()</a>
messages. When using these in procs, be aware of that so you can change the
default value to something more appropriate.



<hr>

<a name=/proc/view>
<h2>view proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&lt;&lt;/output>&lt;&lt; output operator</a>
<dd><a href=#/proc/hearers>hearers</a>
<dd><a href=#/proc/oview>oview proc</a>
<dd><a href=#/proc/range>range proc</a>
<dd><a href=#/mob/var/see_in_dark>see_in_dark var (mob)</a>
<dd><a href=#/mob/var/see_infrared>see_infrared var (mob)</a>
<dd><a href=#/mob/var/see_invisible>see_invisible var (mob)</a>
<dd><a href=#/mob/var/sight>sight var (mob)</a>
<dd><a href=#/client/var/view>view var (client)</a>
<dd><a href=#/world/var/view>view var (world)</a>
<dd><a href=#/proc/viewers>viewers</a>
</dl>

<dl><dt><b>Format:</b>
<dd>view(Dist=5,Center=usr)
</dl>

<dl><dt><b>Returns:</b>
<dd>A list of visible objects within Dist tiles of Center.
</dl>

<dl><dt><b>Args:</b>
<dd>Dist:   A number.
<dd>Center: An object on the map.
</dl>

<p>A Dist of 0 includes Center, the contents of Center (normally
usr.contents), its location (normally the turf a mob is standing on), and
any other contents of that location.  A value of 1 extends the region to the
neighboring squares on the map and so on.  Both arguments are optional and
may be passed in any order.

<p>The default range is actually controlled by the size of the map viewport
size, which is configured with <code>world.view</code>.  Since the default
value of that variable is 5, the default range is also 5.  You may use any
valid view size, so an explicit view size such as "11x17" is also valid.

<h3>Example:</h3>
<xmp>
view() << "to all in sight of [usr]"
view(src) << "to all in sight of [src]"
view(1,src.loc) << "to all within reach of [src]"
</xmp>

<p>Be aware of the following distinctions:

<xmp>
view(usr)         //objects that usr can see
view(usr.loc)     //objects visible from usr's position
view(usr.client)  //objects visible to player
</xmp>

<p>In many cases, the three different statements could produce the same
result, but they are not identical in general.  For example, the first
statement takes into account the visual capabilities of usr, which might
include such things as the ability to see in the dark or to see invisible
objects.

<p>The second statement, since it is from a non-mob would just do a plain
visibility calculation with no special visual capabilities.  In many cases,
you would want to use viewers() or hearers() instead.

<p>The third statement produces a list of visible objects as the player sees
things, which might be different than how the mob sees things if
<code>client.eye</code> and <code>client.mob</code> are different.

<hr>

<a name=/proc/viewers>
<h2>viewers</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/hearers>hearers</a>
<dd><a href=#/proc/oviewers>oviewers</a>
<dd><a href=#/proc/view>view proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>viewers(Depth=world.view,Center=usr)
</dl>

<p>This is just like <code>view()</code>, but it is a list of mobs that can
see the center object, rather than a list of objects visible to the center
object.

<hr>

<a name=/proc/walk>
<h2>walk proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/get_step>get_step proc</a>
<dd><a href=#/proc/step>step proc</a>
<dd><a href=#/atom/movable/var/step_size>step_size var (movable atom)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>walk(Ref,Dir,Lag=0,Speed=0)
</dl>

<dl><dt><b>Args:</b>
<dd>Ref: A mob or obj.
<dd>Dir: One of NORTH, SOUTH, EAST, WEST, NORTHEAST, NORTHWEST, SOUTHEAST,
     SOUTHWEST, or 0 to halt.
<dd>Lag: Delay in world ticks between movement.
<dd>Speed: Speed to move, in pixels. 0 uses Ref.step_size.
</dl>

<p>Move Ref in the direction Dir continuously.  Each step will be preceded
by Lag time of inactivity.

<p>A call to a walking function aborts any previous walking function called
on Ref.  To halt walking, call walk(Ref,0).

<p>This function returns immediately, but continues to process in the
background.

<hr>

<a name=/proc/walk_away>
<h2>walk_away proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/get_step_away>get_step_away proc</a>
<dd><a href=#/proc/step_away>step_away proc</a>
<dd><a href=#/atom/movable/var/step_size>step_size var (movable atom)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>walk_away(Ref,Trg,Max=5,Lag=0,Speed=0)
</dl>

<dl><dt><b>Args:</b>
<dd>Ref: A mob or obj.
<dd>Trg: An object on the map.
<dd>Max: The maximum distance between Ref and Targ before movement halts.
<dd>Lag: Delay in world ticks between movement.
<dd>Speed: Speed to move, in pixels. 0 uses Ref.step_size.
</dl>

<p>Moves Ref on a path away from Trg continuously, taking obstacles into
account.  Each step will be preceded by Lag time of inactivity.  If Ref is
farther than Max steps from Trg, no action will be taken.

<p>A call to a walking function aborts any previous walking function called
on Ref.  To halt walking, call walk(Ref,0).

<p>This function returns immediately, but continues to process in the
background.

<hr>

<a name=/proc/walk_rand>
<h2>walk_rand proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/get_step_rand>get_step_rand proc</a>
<dd><a href=#/proc/step_rand>step_rand proc</a>
<dd><a href=#/atom/movable/var/step_size>step_size var (movable atom)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>walk_rand(Ref,Lag=0,Speed=0)
</dl>

<dl><dt><b>Args:</b>
<dd>Ref: A mob or obj.
<dd>Lag: Delay in world ticks between movement.
<dd>Speed: Speed to move, in pixels. 0 uses Ref.step_size.
</dl>

<p>Moves Ref randomly.  Each step will be preceded by Lag time of inactivity.

<p>A call to a walking function aborts any previous walking function called
on Ref.  To halt walking, call walk(Ref,0).

<p>This function returns immediately, but continues to process in the
background.

<hr>

<a name=/proc/walk_to>
<h2>walk_to proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/get_step_to>get_step_to proc</a>
<dd><a href=#/proc/step_to>step_to proc</a>
<dd><a href=#/atom/movable/var/step_size>step_size var (movable atom)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>walk_to(Ref,Trg,Min=0,Lag=0,Speed=0)
</dl>

<dl><dt><b>Args:</b>
<dd>Ref: A mob or obj.
<dd>Trg: An object on the map.
<dd>Min: The minimum distance between Ref and Trg before movement halts.
<dd>Lag: Delay in world ticks between movement.
<dd>Speed: Speed to move, in pixels. 0 uses Ref.step_size.
</dl>

<p>Move Ref on a path to Trg continuously, taking obstacles into account.
Each step will be preceded by Lag time of inactivity.  If Ref is within Min
steps of Trg, no action will be taken.  This is also true if the target is
too far away (more than twice world.view steps).

<p>A call to a walking function aborts any previous walking function called
on Ref.  To halt walking, call walk(Ref,0).

<p>This function returns immediately, but continues to process in the
background.

<hr>

<a name=/proc/walk_towards>
<h2>walk_towards proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/get_step_towards>get_step_towards proc</a>
<dd><a href=#/proc/step_towards>step_towards proc</a>
<dd><a href=#/atom/movable/var/step_size>step_size var (movable atom)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>walk_towards(Ref,Trg,Lag=0,Speed=0)
</dl>

<dl><dt><b>Args:</b>
<dd>Ref: A mob or obj.
<dd>Trg: An object on the map.
<dd>Lag: Delay in world ticks between movement.
<dd>Speed: Speed to move, in pixels. 0 uses Ref.step_size.
</dl>

<p>Move Ref in the direction of Trg continuously.  Each step will be preceded
by Lag time of inactivity.

<p>A call to a walking function aborts any previous walking function called
on Ref.  To halt walking, call walk(Ref,0).

<p>This function returns immediately, but continues to process in the
background.

<hr>

<a name=/proc/while>
<h2>while proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/break>break proc</a>
<dd><a href=#/proc/continue>continue proc</a>
<dd><a href=#/proc/do>do proc</a>
<dd><a href=#/proc/for/loop>for loop proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>while( E ) Statement
</dl>

<p>If E is true (non-zero) execute Statement.  Continue testing E and doing
the while block until E becomes false (zero).

<p>Statement may be a block of code or a single statement.

<h3>Example:</h3>
<xmp>
var/i = 3
while(i)
  world << i--
</xmp>

<p>This outputs:

<xmp>
3
2
1
</xmp>

<hr>

<a name=/proc/winclone>
<h2>winclone proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/winexists>winexists proc</a>
<dd><a href=#/proc/winget>winget proc</a>
<dd><a href=#/proc/winset>winset proc</a>
<dd><a href=#/proc/winshow>winshow proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>winclone(player, window_name, clone_name)
</dl>

<dl><dt><b>Args:</b>
<dd>player: A mob or client.
<dd>window_name: The name of a window, pane, menu, or macro set in the world's skin file.
<dd>clone_name: The name of the new window, pane, menu, or macro set to create.
</dl>

<p>Creates a clone of a window, pane, menu, or macro set that exists in the
world's skin file. The original object as it exists in the skin file (not its
current state) is used as a template to build the clone. The clone will exist
only for the player you choose.

<h3>Example:</h3>
<xmp>
winset(usr, "templatewindow", "clonedwindow")
</xmp>

<p>If a window is not visible by default, it will have to be shown with
<tt>winset()</tt> or <tt>winshow()</tt>. A pane may be shown by using it in a
Child or Tab control. Menus or macros must be assigned to a window with
<tt>winset()</tt> before they will work.

<p>If window_name is "window", "pane", "menu", or "macro", and the skin file
does not have a control of that name already, the proc will create a new
control of that type from scratch. A new window is invisible by default. For
windows and panes, you should give them a size with <tt>winset()</tt> before
adding any controls so you can set their anchors properly.</p>

<p>Once a clone is created, it can be deleted via a <tt>winset()</tt>
call:</p>

<h3>Example:</h3>
<xmp>
winset(usr, "clonedwindow", "parent=none")
</xmp>

<hr>

<a name=/proc/winexists>
<h2>winexists proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/winclone>winclone proc</a>
<dd><a href=#/proc/winget>winget proc</a>
<dd><a href=#/proc/winset>winset proc</a>
<dd><a href=#/proc/winshow>winshow proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>winexists(player, control_id)
</dl>

<dl><dt><b>Args:</b>
<dd>player: A mob or client.
<dd>control_id: The unique ID of a control in the player's skin.
</dl>

<p>Tells if a control exists and if so, what type it is. The return value is
an empty string if the control does not exist, but otherwise it is the type
of control. See the <a href=skinparams.html target=_blank>Skin reference</a>
for information about the types of controls this proc can return.

<p>This proc will not tell you if a control has been defined in the skin file
but is not in use yet.

<p>Because the client must be contacted to get this information, winexists()
will sleep the current proc.

<hr>

<a name=/proc/winget>
<h2>winget proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/winexists>winexists proc</a>
<dd><a href=#/proc/winset>winset proc</a>
<dd><a href=skinparams.html target=_blank>Skin reference</a>
</dl>

<dl><dt><b>Format:</b>
<dd>winget(player, control_id, params)
</dl>

<dl><dt><b>Args:</b>
<dd>player: A mob or client.
<dd>control_id: The unique ID of a control in the player's skin.
<dd>params: The name of a parameter to read, or a semicolon-separated list of parameters
</dl>

<p>Retrieves info from a player about the current state of their skin. If
control_id and params are each just a single value, then the return value
will be a simple string with the value of that parameter. If control_id or
params is a semicolon-separated list like the kind used in
<tt>list2params()</tt>, then the result will be in a similar format, and
can be converted to a list form using <tt>params2list()</tt>. 

<p>The control_id can be a window name, or in a <tt>"[window].[control]"</tt>
format, or just the control ID as long as it is unique. You can retrieve info
on more than one control at once by separating them with semicolons, like
<tt>"button1;button2"</tt>.

<h3>Example:</h3>
<xmp>
usr << "mainwindow.is-visible = [winget(usr, "mainwindow", "is-visible")]"
usr << "\nOther params:"
usr << winget(usr, "mainwindow", "pos;is-maximized")
usr << "\nButtons:"
usr << winget(usr, "button1;button2", "is-checked")
</xmp>

<p>This outputs:

<xmp>
mainwindow.is-visible = true

Other params:
pos=0x0;is-maximized=true

Buttons:
button1.is-checked=true;button2.is-checked=false
</xmp>

<p>If the returned result is actual text for any parameters, the single quote
or double quote characters may be escaped with a backslash. An actual backslash
will also be escaped with a backslash.

<p>You can also use a special wildcard format to retrieve info about all the
controls in a window, menu, or macro set. If control_id is <tt>"mainwindow.*"</tt>
for instance, then any control that is part of mainwindow--and mainwindow
itself--is included in the result if it has the parameter(s) you're looking
for. Use <tt>params2list()</tt> to interpret the result. See the
<a href=skinparams.html target=_blank>skin reference</a> for more details.

<p>Because the client must be contacted to get this information, winget()
will sleep the current proc.

<hr>

<a name=/proc/winset>
<h2>winset proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/winclone>winclone proc</a>
<dd><a href=#/proc/winexists>winexists proc</a>
<dd><a href=#/proc/winget>winget proc</a>
<dd><a href=#/proc/winshow>winshow proc</a>
<dd><a href=skinparams.html target=_blank>Skin reference</a>
</dl>

<dl><dt><b>Format:</b>
<dd>winset(player, control_id, params)
</dl>

<dl><dt><b>Args:</b>
<dd>player: A mob or client.
<dd>control_id: The unique ID of a control in the player's skin.
<dd>params: A list of parameters to set, in the format returned by
  <tt>list2params()</tt>.
</dl>

<p>Sets parameters for a player's skin. The parameter list can be created by
making a list and using <tt>list2params()</tt>, or it can be done manually by
just using a string like <tt>"is-visible=true;text-color=#f00"</tt>.

<p>The control_id can be a window name, or in a <tt>"[window].[control]"</tt>
format, or just the control ID as long as it is unique.

<p>If you want to use a text string that may include spaces, surround the
string with double quotes and escape them using a backslash, e.g.
<tt>"text=\"This is some text.\""</tt>. Backslashes can also be used by
preceding them with another backslash. For filenames, use single quotes around
the file. Sometimes escapement may need to go several levels deep; for example
to set up an input control with a default say command, you will need to escape
it twice:

<blockquote>
Desired command: <tt>say "</tt><br>   
Escaped form with quotes: <tt>"<b>say \"</b>"</tt><br>   
Final form: <tt>\"say \\\"\"</tt>

<p><tt>winset(usr, "mainwindow.input", "command=<b>\"say \\\"\"</b>")</tt>   
</blockquote>

<p>You can set more than one control's parameters at once by leaving the
control_id argument null, and including the control as part of the parameter
list:

<xmp>winset(usr, null,\
  "mainwindow.output.background-color=#ffffff;mainwindow.input.background-color=#ffffff")</xmp>

<p>Another use for winset() is to send commands to the client that normally
can only run from there, like .profile or .quit. To do this leave the
control_id argument null, and just use a parameter called "command":

<xmp>obj/quitbutton
  name = "Quit"
  icon = 'buttons.dmi'
  icon_state = "quit"

  Click()
    winset(usr, null, "command=.quit")</xmp>


<hr>

<a name=/proc/winshow>
<h2>winshow proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/winclone>winclone proc</a>
<dd><a href=#/proc/winget>winget proc</a>
<dd><a href=#/proc/winset>winset proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>winshow(player, window, show=1)
</dl>

<dl><dt><b>Args:</b>
<dd>player: A mob or client.
<dd>window: The name of a window in the player's skin.
<dd>show: Use a nonzero value to show the window, zero to hide it.
</dl>

<p>Shows or hides a window in the player's skin.

<hr>

<a name=/regex>
<h2>regex datum</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/{notes}/regex>Regular expressions</a>
<dd><a href=#/regex/proc>regex procs</a>
<dd><a href=#/regex/var>regex vars</a>
<dd><a href=#/proc/regex>regex proc</a>
<dd><a href=#/proc/REGEX_QUOTE>REGEX_QUOTE proc</a>
<dd><a href=#/proc/findtext>findtext proc</a>
<dd><a href=#/proc/splittext>splittext proc</a>
</dl>

<p>The /regex datum holds a regular expression that can be used for
searching and/or replacing text. Rather than searching for a specific piece
of text, a regular expression is a <i>pattern</i> to search for. This can
include things like wildcards. See <a href=#/{notes}/regex>Regular expressions</a>
for more information.

<p>A new regular expression can be created with regex() or new/regex().

<hr>

<a name=/regex/proc>
<h2>regex procs</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/regex>regex datum</a>
<dd><a href=#/regex/var>regex vars</a>
<dd><a href=#/proc/regex>regex proc</a>
</dl>

<dl><dt>regex/proc
<dd><a href=#/proc/regex>New</a>
<dd><a href=#/regex/proc/Find>Find</a>
<dd><a href=#/regex/proc/Replace>Replace</a>
</dl>

<hr>

<a name=/regex/proc/Find>
<h2>Find proc (regex)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/{notes}/regex>Regular expressions</a>
<dd><a href=#/regex>regex datum</a>
<dd><a href=#/regex/proc/Replace>Replace proc (regex)</a>
<dd><a href=#/regex/var>regex vars</a>
<dd><a href=#/proc/regex>regex proc</a>
<dd><a href=#/proc/findtext>findtext proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Find(haystack, Start=1, End=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>The position of the matched text, or 0 if no match was found.
</dl>

<dl><dt><b>Args:</b>
<dd>haystack: The text to be searched
<dd>Start: The start position to search; defaults to 1, or to src.next if this is a global pattern
<dd>End: The position of the character after the end of the search; 0 is the end. The actual match is allowed to extend past End.
</dl>

<p>Finds the regular expression pattern within the "haystack" text.  The
following vars are set by the match:

<ul>
<li>text: The text that was searched.</li>
<li>index: The index where the match was found (same as the return value)</li>
<li>match: The actual matched text</li>
<li>group: If the expression contains capturing groups with the ( ) parentheses operator, this is a list that holds the text found in those groups. group[1] is the first group, and so on.</li>
<li>next: If the "g" flag was used to create thie expression, this is the next index to begin searching.
</ul>

<p>In a global expression (using the "g" flag), Find() can be called
repeatedly on the same piece of text and the Start position will be advanced
automatically unless you specify it.

<hr>

<a name=/regex/proc/New>
<h2>New proc (regex)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/{notes}/regex>Regular expressions</a>
<dd><a href=#/regex>regex datum</a>
<dd><a href=#/proc/regex>regex proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>regex(pattern, flags)
<dd>regex(Regex)
</dl>

<dl><dt><b>Args:</b>
<dd>pattern: The pattern string to search for
<dd>flags: (optional) A text string containing any combination of modifier flags
<dd>Regex: an existing /regex datum to copy
</dl>

<p>Calling new/regex() is the same as calling regex().  It will create a new
/regex datum.

<hr>

<a name=/regex/proc/Replace>
<h2>Replace proc (regex)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/{notes}/regex>Regular expressions</a>
<dd><a href=#/regex>regex datum</a>
<dd><a href=#/regex/proc/Find>Find proc (regex)</a>
<dd><a href=#/regex/var>regex vars</a>
<dd><a href=#/proc/regex>regex proc</a>
<dd><a href=#/proc/replacetext>replacetext proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Replace(haystack, replacement, Start=1, End=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>The original haystack string with the first match replaced.  If using the "g" flag, all matches are replaced.
</dl>

<dl><dt><b>Args:</b>
<dd>haystack: The text to be searched
<dd>replacement: A piece of text, OR a proc, that will be used to replace the match
<dd>Start: The start position to search; defaults to 1, or to src.next if this is a global pattern
<dd>End: The position of the character after the end of the search; 0 is the end. The actual match is allowed to extend past End.
</dl>

<p>Finds the regular expression pattern within the "haystack" text, and
replaces the match with the given replacement value.

<p>In a non-global expression (not using the "g" flag), the values of
src.index and src.next are set as they would be in a global Find(). See the
Find() proc for more info.

<h3>Replacing with text</h3>

<p>If the replacement value is text, the $ character is treated as special.
If you want to use the actual dollar sign, it must be escaped with a second
dollar sign. Otherwise, the $ character is one of these special values:

<table class="regex">
<tr><th>Replacement</th><th>Value</th></tr>
<tr><td>$1 <i>through</i> $9</td><td>$1 is whatever was in the first parentheses group, $2 is the second, and so on.</td></tr>
<tr><td>$`</td><td>The text that came before the match</td></tr>
<tr><td>$'</td><td>The text that came after the match</td></tr>
<tr><td>$0 <i>or</i> $&</td><td>The whole match itself</td></tr>
</table>

<h3>Replacing with a proc</h3>

<p>If replacing matches with a proc, then the proc will be called with the
match as its first argument, and any groups as the following arguments.
Whatever the proc returns will be used as the replacement text in place of the
match.

<h3>Example</h3>
<xmp>
var/regex/vowels = new("[aeiou]", "i")
// match any word of 2 letters or more
var/regex/piglatin = new("\\b(\\l)(\\l+)\\b", "ig")

// group1 is the first letter, and group2 is everything else
proc/word2piglatin(match, group1, group2)
	// If the word starts with a vowel, just add "ay"
    if(vowels.Find(group1)) return "[match]ay"
    // If the word was capitalized, capitalize the replacement    
    if(group1 == uppertext(group1))
        group1 = lowertext(group1)
        group2 = uppertext(copytext(group2,1,2)) + lowertext(copytext(group2,2))
    return "[group2][group1]ay"

mob/verb/PigSay(msg as text)
    msg = html_encode(msg)
    world << piglatin.Replace(msg, /proc/word2piglatin)
</xmp>

<hr>

<a name=/regex/var>
<h2>regex vars</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/regex>regex datum</a>
<dd><a href=#/regex/proc>regex procs</a>
<dd><a href=#/proc/regex>regex proc</a>
</dl>

<dl><dt>regex/var
<dd><a href=#/regex/var/flags>flags</a>
<dd><a href=#/regex/var/group>group</a>
<dd><a href=#/regex/var/index>index</a>
<dd><a href=#/regex/var/match>match</a>
<dd><a href=#/regex/var/name>name</a>
<dd><a href=#/regex/var/next>next</a>
<dd><a href=#/regex/var/text>text</a>
</dl>

<hr>

<a name=/regex/var/flags>
<h2>flags var (regex)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/{notes}/regex>Regular expressions</a>
<dd><a href=#/regex>regex datum</a>
<dd><a href=#/regex/var/name>name var (regex)</a>
</dl>

<p>The flags that were used to create this regular expression.  Changing this
value after the datum is created will not change how the expression behaves.

<hr>

<a name=/regex/var/group>
<h2>group var (regex)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/regex>regex datum</a>
<dd><a href=#/regex/proc/Find>Find proc (regex)</a>
<dd><a href=#/regex/var/index>index var (regex)</a>
<dd><a href=#/regex/var/match>match var (regex)</a>
</dl>

<p>After a call to Find(), if this regular expression had any parentheses
groups, whatever text was matched in those groups is stored here in a list.

<h3>Example</h3>
<xmp>
var/regex/R = new("B(.)(.)(.)D")
R.Find("BYOND")     // find this pattern in "BYOND"
</xmp>

The result of the example is that R.group is list("Y","O","N").

<hr>

<a name=/regex/var/index>
<h2>index var (regex)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/regex>regex datum</a>
<dd><a href=#/regex/proc/Find>Find proc (regex)</a>
<dd><a href=#/regex/proc/Replace>Replace proc (regex)</a>
<dd><a href=#/regex/var/match>match var (regex)</a>
<dd><a href=#/regex/var/next>next var (regex)</a>
</dl>

<p>After a call to Find(), this var contains the index where the match was
found.

<p>Replace() on a non-global pattern will also store the index of the match
here.

<hr>

<a name=/regex/var/match>
<h2>match var (regex)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/regex>regex datum</a>
<dd><a href=#/regex/proc/Find>Find proc (regex)</a>
<dd><a href=#/regex/var/group>group var (regex)</a>
<dd><a href=#/regex/var/index>index var (regex)</a>
</dl>

<p>After a call to Find(), this var contains the text that was matched.

<hr>

<a name=/regex/var/name>
<h2>name var (regex)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/regex>regex datum</a>
<dd><a href=#/regex/var/flags>flags var (regex)</a>
</dl>

<p>The pattern that was used to create this regular expression.  Changing this
value after the datum is created will not change how the expression behaves.

<hr>

<a name=/regex/var/next>
<h2>next var (regex)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/regex>regex datum</a>
<dd><a href=#/regex/proc/Find>Find proc (regex)</a>
<dd><a href=#/regex/proc/Replace>Replace proc (regex)</a>
<dd><a href=#/regex/var/index>index var (regex)</a>
<dd><a href=#/regex/var/match>match var (regex)</a>
</dl>

<p>If this is a global pattern (using the "g" flag), then after a call to
Find() this var contains the index where next Find() should begin.

<p>Replace() on a non-global pattern will also store the index of the next
place to begin a search here.  The position to search will be based on the
replaced text, which is stored in the text var.

<hr>

<a name=/regex/var/text>
<h2>text var (regex)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/regex>regex datum</a>
<dd><a href=#/regex/proc/Find>Find proc (regex)</a>
<dd><a href=#/regex/var/index>index var (regex)</a>
<dd><a href=#/regex/var/match>match var (regex)</a>
<dd><a href=#/regex/var/next>next var (regex)</a>
</dl>

<p>If this is a global pattern (using the "g" flag), then after a call to
Find() this var contains the text that was searched.  If that same text is
searched again, the next var is the default starting position.

<p>Replace() on a non-global pattern will store the text <i>after</i>
replacement here.

<hr>

<a name=/savefile>
<h2>savefile</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/savefile/operator/&gt;&gt;>&gt;&gt; operator (savefile)</a>
<dd><a href=#/savefile/operator/&lt;&lt;>&lt;&lt; operator (savefile)</a>
<dd><a href=#/client/proc/Export>Export proc (client)</a>
<dd><a href=#/client/proc/New>New proc (client)</a>
<dd><a href=#/savefile/proc>savefile procs</a>
<dd><a href=#/savefile/var>vars (savefile)</a>
</dl>

<p>A database file in DM is called a "savefile".  All of the contents of a
savefile reside in a single file.  The contents of the file are stored in
database directories.  These should not be confused with real directories in
the external file system.  The database directories are all contained inside
the one file.

<p>Each database directory contains a list of sub-directories and a buffer in
which data may be written.  The absolute path to a directory has the following
format:  "/Dir1/Dir2/...".  The current directory may be set by assigning its
absolute path name to <code>savefile.cd</code>.  A relative path (one that
doesn't begin with "/") may also be used, in which case the new path starts at
the current directory.  The path "."  stands for the current directory, ".."
for its parent, "../.." for its parent's parent, etc.

<p>A savefile may be created with <code>new/savefile(name)</code>.  The
optional name argument may be an external file name (existing or to be
created) in double quotes or a file from the resource cache in single quotes.
Of course, a variable containing either of these types of values may also be
used.  If no name is specified, a temporary file will be created, which will
be destroyed when the savefile is no longer in use.  If a resource cache is
specified, a temporary file will be created and the contents of the cached
file will be copied into it.  Changes will therefore only be temporary.

<hr>

<a name=/savefile/operator>
<h2>operators (savefile)</h2>

<p>Built-in savefile operators:

<dl><dt>savefile/operator
<dd><a href=#/savefile/operator/&lt;&lt;>&lt;&lt</a>
<dd><a href=#/savefile/operator/&gt;&gt;>&gt;&gt</a>
</dl>

<hr>

<a name=/savefile/operator/&gt;&gt;>
<h2>&gt;&gt; operator (savefile)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/&gt;&gt;/input>&gt;&gt; input operator</a>
<dd><a href=#/savefile/operator/&lt;&lt;>&lt;&lt; operator (savefile)</a>
<dd><a href=#/datum/proc/Read>Read proc (datum)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>F &gt;&gt; Var
<dd>F["Path"] &gt;&gt; Var
</dl>

<p>Reads a value from a buffer into a variable.  If Path is not specified, the
current buffer will be used.  Otherwise, the buffer at the specified path will
be accessed.  Whenever the current directory is set, reading starts at the
beginning of that buffer (replacing any previous contents).  For this reason,
when the Path parameter is given, the first value in the specified buffer is
always read.  If there is no data in the buffer or the end of the buffer has
been reached, null is returned.

<p>If the value read is a previously written object, its own directory will be
opened and the object's Read proc will be called to load any data that was
written in the object's Write proc.

<p>If the value read is a savefile (ie a savefile inside of a savefile), it is
treated a little differently.  Instead of returning a savefile object, it
returns data cached in the world's rsc file.  This is to give you control over
what file this data is copied into before it is opened as a savefile.  If you
want to just open it up in a temporary file, do something like this:

<xmp>
obj
   var
      savefile/myfile
   Read()
      . = ..()   //do the normal stuff
      if(myfile) //load data into a temporary file and create savefile object
         myfile = new/savefile(myfile)
</xmp>

<hr>

<a name=/savefile/operator/&lt;&lt;>
<h2>&lt;&lt; operator (savefile)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/savefile/operator/&gt;&gt;>&gt;&gt; operator (savefile)</a>
<dd><a href=#/operator/&lt;&lt;/output>&lt;&lt; output operator</a>
<dd><a href=#/datum/proc/Write>Write proc (datum)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>F &lt;&lt; Val
<dd>F["Path"] &lt;&lt; Val
</dl>

<p>Writes Val to a buffer.  If Path is not specified, the current buffer
will be used.  Otherwise, the buffer at the specified path will be written
to.  Whenever the current directory is set, writing starts at the beginning
of that buffer (replacing any previous contents).  For this reason, when the
Path parameter is given, the specified buffer is always overwritten.

<p>If Val is an object, a separate directory will be created for the object
and the object's Write proc will be called.  In addition to data that may be
written by the Write() proc, the type of the object is stored in a buffer
called "type".  In the case of turfs, the location of the turf is also
recorded so that it can be recreated at the same position.  All other objects
must be repositioned after the object is recreated (like in the object's
Read() proc).

<p>Single operations that write multiple values (such as saving an object) are
handled somewhat specially to avoid two references to the same object creating
duplicate entries in the savefile.  After the object being referenced is
written once, successive references to the same object will be saved simply as
references rather than as full objects.  If this was not done, two references
to the same object would be read back in as two separate objects.  This also
avoids infinite loops that would result when objects contain references back
to themselves.

<hr>

<a name=/savefile/proc>
<h2>savefile procs</h2>

<dl><dt>savefile/proc
<dd><a href=#/savefile/proc/ExportText>ExportText</a>
<dd><a href=#/savefile/proc/Flush>Flush</a>
<dd><a href=#/savefile/proc/ImportText>ImportText</a>
<dd><a href=#/savefile/proc/Lock>Lock</a>
<dd><a href=#/savefile/proc/Unlock>Unlock</a>
<dd><a href=#/savefile/proc/New>New</a>
</dl>

<hr>

<a name=/savefile/proc/ExportText>
<h2>ExportText proc (savefile)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/savefile/proc/ImportText>ImportText proc (savefile)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>savefile.ExportText(path=cd,file)
</dl>

<dl><dt><b>Args:</b>
<dd>path: the path to export
<dd>file: optional file to write to
</dl>

<p>Converts all or part of a savefile to a human readable text format, similar
in syntax to DM.  If no file is specified, the savefile text is returned as a
text string instead of being written to a file.

<p>The following example shows how to export and later import a savefile.  The
user's mob is written into a directory with the same name as their
<a href=#/mob/var/ckey>ckey</a> and the result is written to a text file.

<h3>Example:</h3>
<xmp>
mob/verb/write()
   var/savefile/F = new()
   var/txtfile = file("players/[ckey].txt")

   F[ckey] << usr

   fdel(txtfile)
   F.ExportText("/",txtfile)

   usr << "Your savefile looks like this:"
   usr << "&lt;pre&gt;[html_encode(file2text(txtfile))]&lt;/pre&gt;"

mob/verb/read()
   var/savefile/F = new()
   var/txtfile = file("players/[ckey].txt")

   F.ImportText("/",txtfile)
   F[ckey] >> usr
</xmp>

<hr>

<a name=/savefile/proc/Flush>
<h2>Flush proc (savefile)</h2>

<dl><dt><b>Format:</b>
<dd>savefile.Flush()
</dl>

<p>Flushes any pending write operations for this savefile.</p>

<hr>

<a name=/savefile/proc/ImportText>
<h2>ImportText proc (savefile)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/savefile/proc/ExportText>ExportText proc (savefile)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>savefile.ImportText(path=cd,source)
</dl>

<dl><dt><b>Args:</b>
<dd>path: the path at which to write the imported data
<dd>source: a file or text string to import
</dl>

<p>Reads a text file or string and writes it into a savefile.  See
<a href=#/savefile/proc/ExportText>ExportText</a> for an example.

<hr>

<a name=/savefile/proc/Lock>
<h2>Lock proc (savefile)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/savefile/proc/New>New proc (savefile)</a>
<dd><a href=#/savefile/proc/Unlock>Unlock proc (savefile)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Lock(timeout)
</dl>

<dl><dt><b>Args:</b>
<dd>timeout: seconds to wait; -1 for no timeout
</dl>

<dl><dt><b>Returns:</b>
<dd>1 on success; 0 on failure
</dl>

<p>In order to modify a savefile, exclusive access to the file must be
guaranteed, so that other processes reading or writing to the file do not
experience data corruption.  This is known as "locking" the file.  While the
file is locked, only the world that obtained the lock may access it.

<p>Normally, you do not need to worry about this, because a lock is
automatically obtained upon the first attempt to write to the file.  In a CGI
application, where many instances of the program might be running
simultaneously, the normal locking, which just tries once and crashes the proc
on failure, would not be ideal.

<p>Explicitly calling Lock() allows you to specify a timeout and it also
allows you to handle the case in which no lock could be obtained.  If you want
it to wait indefinitely, use -1.  Just be careful if there are several files
read by multiple processes that it is not possible for deadlock to occur.

<p>Obtaining a lock will fail if the file is locked by another world or if
it is even open by any other world.

<p>If you are using Lock(), then you probably also want to specify a timeout
when you open the savefile, since that too can fail due to the file being
locked by another process.

<hr>

<a name=/savefile/proc/New>
<h2>New proc (savefile)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/savefile/proc/Lock>Lock proc (savefile)</a>
<dd><a href=#/savefile/proc/Unlock>Unlock proc (savefile)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>New(filename,timeout)
</dl>

<dl><dt><b>Args:</b>
<dd>filename: name of file or empty for temporary file
<dd>timeout: seconds to wait; -1 for no timeout
</dl>

<p>You call this via new/savefile(filename,timeout).  The timeout is used to
determine how long to wait if the file is locked.  Normally (timeout=0), if
the file is locked, the proc crashes with a runtime error.  If you specify a
timeout, then it will keep trying to open the file and if this fails, it will
simply return with savefile.name being empty (ie a false value).

<p>If the first argument is an entry in the world's rsc cache, the data will
be copied into a temporary file and accessed from there.  Changes to this, and
any other temporary file, are not saved.  When you close the file, it simply
gets deleted.

<hr>

<a name=/savefile/proc/Unlock>
<h2>Unlock proc (savefile)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/savefile/proc/Lock>Lock proc (savefile)</a>
<dd><a href=#/savefile/proc/New>New proc (savefile)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Unlock()
</dl>

<p>Exclusive locks are automatically released when the savefile is closed, but
if you want to keep reading the file and allow other processes to do the same,
then you can explicitly unlock it.

<p>Note that this does not allow other processes to lock the file.  It only
allows them to read from it.  As long as the file is open by more than one
process, no lock may be obtained.

<hr>

<a name=/savefile/var>
<h2>vars (savefile)</h2>

<p>savefile vars:

<dl><dt>savefile/var
<dd><a href=#/savefile/var/cd>cd</a>
<dd><a href=#/savefile/var/dir>dir</a>
<dd><a href=#/savefile/var/eof>eof</a>
<dd><a href=#/savefile/var/name>name</a>
</dl>

<hr>

<a name=/savefile/var/cd>
<h2>cd var (savefile)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/savefile>savefile</a>
</dl>

<p>This is the path name of the current directory.  Setting it causes the
current directory to change.  (We are talking about the current
<em>database</em> directory inside the savefile.  It is not a
real directory on the filesystem.)  It is perfectly legal to change to a
non-existent directory.  This new directory will not be saved to disk unless
its buffer (or one of its children) is modified, however.

<h3>Example:</h3>
<xmp>
var/savefile/F = new()  // temporary file

F.cd = "/MyDir/Icon"
F.cd = ".."    // change to /MyDir
F.cd = "Icon"  // change to /MyDir/Icon
</xmp>

<hr>

<a name=/savefile/var/dir>
<h2>dir list var (savefile)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/list>list</a>
<dd><a href=#/savefile>savefile</a>
</dl>

<p>The name of each child directory of the current data directory is stored
in the list savefile.dir.  New directories may be created with
savefile.dir.Add() and removed with savefile.dir.Remove().  To test for the
existence of a directory, use savefile.dir.Find().  (Note that these are
<em>database</em> directories inside the savefile--not real directories
on the filesystem.)

<p>The order of directories is not necessarily preserved, so do not assume,
for example, that newer directories will be at the end of the list.

<hr>

<a name=/savefile/var/eof>
<h2>eof var (savefile)</h2>

<p>If there is more data to read in the current buffer, eof is 0; otherwise
it is 1.  Setting eof to 1 moves to the end of the buffer and 0 moves to the
beginning.  Setting it to -1 deletes the current buffer.

<hr>

<a name=/savefile/var/name>
<h2>name var (savefile)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/savefile>savefile</a>
</dl>

<p>The external "real" filename is stored in file.name.  It is initialized
when creating a new file.  If none is specified, a temporary file with a
random name will be created.

<h3>Example:</h3>
<xmp>
var/savefile/F1
var/savefile/F2

F1 = new()         // create a temp file
F2 = new("myfile") // open "myfile"

world << "F1.name = [F1]"
world << "F2.name = [F2]"
</xmp>

<hr>

<a name=/sound>
<h2>sound datum</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/sound/var>vars (sound)</a>
<dd><a href=#/proc/sound>sound proc</a>
</dl>

<p>A <tt>/sound</tt> datum is created by the <tt>sound()</tt> proc or by
<tt>new/sound()</tt>. It can be used to change the way a sound file will
play. When you're ready to play the sound, just send it to a player like
so:

<xmp>
var/sound/S = sound('bubbles.wav')
usr << S
</xmp>

<p>The sound file can be supplied as a list of choices, in which case the
client will play the first compatible sound in the list.

<hr>

<a name=/sound/var>
<h2>vars (sound)</h2>

<p>Built-in sound vars:

<dl><dt>sound/var
<dd><a href=#/sound/var/file>file</a>
<dd><a href=#/sound/var/repeat>repeat</a>
<dd><a href=#/sound/var/wait>wait</a>
<dd><a href=#/sound/var/channel>channel</a>
<dd><a href=#/sound/var/volume>volume</a>
<dd><a href=#/sound/var/frequency>frequency</a>
<dd><a href=#/sound/var/pan>pan</a>
<dd><a href=#/sound/var/priority>priority</a>
<dd><a href=#/sound/var/status>status</a>
<dd><a href=#/sound/var/xyz>x, y, z</a>
<dd><a href=#/sound/var/falloff>falloff</a>
<dd><a href=#/sound/var/environment>environment</a>
<dd><a href=#/sound/var/echo>echo</a>
</dl>

<hr>

<a name=/sound/var/file>
<h2>file var (sound)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/sound>sound proc</a>
<dd><a href=#/sound/var>vars (sound)</a>
</dl>

<p>This is the file that will be played when the sound is sent to a player.

<p>If this value is a list of files rather than a single file, the client
will play the first compatible sound in the list.  This can be useful for
developing webclient games, where .ogg is preferred by most browsers for
audio, but .mp3 is needed for others.

<hr>

<a name=/sound/var/repeat>
<h2>repeat var (sound)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/sound>sound proc</a>
<dd><a href=#/sound/var>vars (sound)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0 (do not repeat)
</dl>

<p>Set to 1 to repeat the sound indefinitely once it begins playing, 2 to
repeat it forwards and backwards.

<hr>

<a name=/sound/var/wait>
<h2>wait var (sound)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/sound>sound proc</a>
<dd><a href=#/sound/var>vars (sound)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0 (do not wait)
</dl>

<p>Set to 1 to wait for other sounds in this channel to finish before playing
this one.

<hr>

<a name=/sound/var/channel>
<h2>channel var (sound)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/sound>sound proc</a>
<dd><a href=#/sound/var>vars (sound)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0 (any channel)
</dl>

<p>For sound effects, set to 1 through 1024 to choose a specific sound channel.
For values of 0 or less, any available channel will be chosen. If you play a
null sound (no file) on channel 0, the settings for the datum will affect all
channels.

<hr>

<a name=/sound/var/volume>
<h2>volume var (sound)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/sound>sound proc</a>
<dd><a href=#/sound/var>vars (sound)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>100 (full volume)
</dl>

<p>Set to a percentage from 0 to 100 of the sound's full volume. It will play
at that volume when it is sent to a player.

<hr>

<a name=/sound/var/frequency>
<h2>frequency var (sound)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/sound/var>vars (sound)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>Any value from -100 to 100 will play this sound at a multiple of its normal
frequency. Set to 2 to play at double speed, for example, or -1 to play
backwards. A value of 0 or 1 will play the sound at its normal frequency.

<p>Set to a specific frequency (in Hz) outside of the -100 to 100 range to change
the playback rate of the sound. A negative value is also allowed. The value 0
means that the sound should be played as-is. This value will take effect when the
sound is sent to a player.

<p>CD-quality sound is sampled at 44.1 KHz, which is a value of 44100. Other
common sample rates for .wav files are 8000, 11025, and 22050. (11025 is
usually a good quality for most sound effects without making file size too
large.) If you know the file's sample rate, doubling the value will play it at
a higher pitch and twice as fast; halving it will play it at a lower pitch and
twice as slow.

<hr>

<a name=/sound/var/pan>
<h2>pan var (sound)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/sound/var>vars (sound)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>Alter the panning of a sound. -100 is full left, 100 is full right, and 0 is
at the center. This value will take effect when the sound is sent to a player.

<p>For music, <tt>pan</tt> can range from -100 (no pan separation) to 0 (full
separation).

<hr>

<a name=/sound/var/priority>
<h2>priority var (sound)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/sound/var>vars (sound)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>Sounds with higher priority may steal channels from sounds of lower
priority. The maximum value is 255. 0 is the lowest.

<hr>

<a name=/sound/var/status>
<h2>status var (sound)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/sound/var>vars (sound)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>Alter the way the sound is heard by affecting several different on/off
values which combine as bit flags.

<xmp>
SOUND_MUTE      // do not play the sound
SOUND_PAUSED    // pause sound
SOUND_STREAM    // create as a stream
SOUND_UPDATE    // update a playing sound
</xmp>

<p>Use the <tt>|</tt> operator to combine these values. The setting you choose
will take effect when the sound is sent to a player.

<p><tt>SOUND_MUTE | SOUND_UPDATE</tt> will mute a sound, but it will continue
to play. It can be unmuted while still playing by resending it with
<tt>status=SOUND_UPDATE</tt>.

<p><tt>SOUND_PAUSED | SOUND_UPDATE</tt> will pause a sound. It can be
restarted from its current position by resending it with
<tt>status=SOUND_UPDATE</tt>.

<p><tt>SOUND_STREAM</tt> will create this sound as a stream. Streams take less
memory, but can not play multiple times at once, nor can they play in reverse.
This flag is only valid the first time that a sound is played in a particular
mode (normal vs. 3D). Changing the flag later will not change the stream
status of the sound in that mode.

<p><tt>SOUND_UPDATE</tt> updates the settings for the sound currently playing
on the specified channel. If this flag is not set or no channel is specified,
the sound will start again from the beginning.

<hr>

<a name=/sound/var/xyz>
<h2>x, y, and z vars (sound)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/sound/var>vars (sound)</a>
<dd><a href=#/sound/var/falloff>falloff var (sound)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>all 0
</dl>

<p>Set to different values to give your sound a 3D effect which will be applied
when it is played. Positive values for <tt>x</tt> will sound as if they come
from the right, positive <tt>y</tt> sounds like it is above the player's head,
and positive <tt>z</tt> sounds like it is directly ahead. The effect of 3D sound
depends on the player's computer's sound card, and is greatly enhanced when
wearing headphones.

<p>Depending on the value of <tt>falloff</tt>, the settings for the location of
the sound can also affect its volume. Once the distance passes the value of
<tt>falloff</tt>, the volume will diminish.

<p>If these values are all set to 0, you should set <tt>environment</tt> if you
want to treat it as a 3D sound. Otherwise BYOND will assume this is meant to be
a non-3D sound such as music or the interface.

<hr>

<a name=/sound/var/falloff>
<h2>falloff var (sound)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/sound/var>vars (sound)</a>
<dd><a href=#/sound/var/xyz>x, y, z vars (sound)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>1
</dl>

<p>Within the falloff distance a 3D sound stays at the constant loudest
volume possible. Outside of this distance it attenuates at a rate
determined by the falloff.

<p>Higher values will make sounds fade out more slowly as they get farther away.
The distance of a sound is set by <tt>x</tt>, <tt>y</tt>, and <tt>z</tt>.

<hr>

<a name=/sound/var/environment>
<h2>environment var (sound)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/sound/var>vars (sound)</a>
<dd><a href=#/sound/var/xyz>x, y, z vars (sound)</a>
<dd><a href=#/sound/var/echo>echo var (sound)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>-1
</dl>

<p>Changes the environmental reverb for all 3D sounds until another environment is specified. Only 3D sounds react to the environment. Please see the EAX2 documentation at http://developer.creative.com/ for detailed information about these settings.
<p>This value may be a number which selects a preset, or a list to choose settings manually. The default value (-1) specifies no change in environment. A numeric value from 0 to 25 specifies a set of reverb presets for the environment. The environment presets are:

<ol type=1 start=0>
<li>generic</li>
<li>padded cell</li>
<li>room</li>
<li>bathroom</li>
<li>livingroom</li>
<li>stoneroom</li>
<li>auditorium</li>
<li>concert hall</li>
<li>cave</li>

<li>arena</li>
<li>hangar</li>
<li>carpetted hallway</li>
<li>hallway</li>
<li>stone corridor</li>
<li>alley</li>
<li>forest</li>
<li>city</li>
<li>mountains</li>

<li>quarry</li>
<li>plain</li>
<li>parking lot</li>
<li>sewer pipe</li>
<li>underwater</li>
<li>drugged</li>
<li>dizzy</li>
<li>psychotic</li>
</ol>

<p>A 23-element list represents a custom environment with the following
reverbration settings. A null or non-numeric value for any setting will
select its default.
<dl>
	<dt>1 EnvSize (1.0 to 100.0) default = 7.5</dt>
	<dd>environment size in meters</dd>
	<dt>2 EnvDiffusion (0.0 to 1.0) default = 1.0</dt>
	<dd>environment diffusion</dd>
	<dt>3 Room (-10000 to 0) default = -1000</dt>

	<dd>room effect level (at mid frequencies)</dd>
	<dt>4 RoomHF (-10000 to 0) default = -100</dt>
	<dd>relative room effect level at high frequencies</dd>
	<dt>5 RoomLF (-10000 to 0) default = 0</dt>
	<dd>relative room effect level at low frequencies</dd>
	<dt>6 DecayTime (0.1 to 20.0) default = 1.49</dt>

	<dd>reverberation decay time at mid frequencies</dd>
	<dt>7 DecayHFRatio (0.1 to 2.0) default = 0.83</dt>
	<dd>high-frequency to mid-frequency decay time ratio</dd>
	<dt>8 DecayLFRatio (0.1 to 2.0) default = 1.0</dt>
	<dd>low-frequency to mid-frequency decay time ratio</dd>
	<dt>9 Reflections (-10000 to 1000) default = -2602</dt>

	<dd>early reflections level relative to room effect</dd>
	<dt>10 ReflectionsDelay (0.0 to 0.3) default = 0.007</dt>
	<dd>initial reflection delay time</dd>
	<dt>11 Reverb (-10000 to 2000) default = 200</dt>
	<dd>late reverberation level relative to room effect</dd>
	<dt>12 ReverbDelay (0.0 to 0.1) default = 0.011</dt>

	<dd>late reverberation delay time relative to initial reflection</dd>
	<dt>13 EchoTime (0.075 to 0.250) default = 0.25</dt>
	<dd>echo time</dd>
	<dt>14 EchoDepth (0.0 to 1.0) default = 0.0</dt>
	<dd>echo depth</dd>
	<dt>15 ModulationTime (0.04 to 4.0) default = 0.25</dt>

	<dd>modulation time</dd>
	<dt>16 ModulationDepth (0.0 to 1.0) default = 0.0</dt>
	<dd>modulation depth</dd>
	<dt>17 AirAbsorptionHF (-100 to 0.0) default = -5.0</dt>
	<dd>change in level per meter at high frequencies</dd>
	<dt>18 HFReference (1000.0 to 20000) default = 5000.0</dt>

	<dd>reference high frequency (hz)</dd>
	<dt>19 LFReference (20.0 to 1000.0) default = 250.0</dt>
	<dd>reference low frequency (hz)</dd>
	<dt>20 RoomRolloffFactor (0.0 to 10.0) default = 0.0</dt>
	<dd>like rolloffscale in System::set3DSettings but for reverb room size effect</dd>
	<dt>21 Diffusion (0.0 to 100.0) default = 100.0</dt>

	<dd>Value that controls the echo density in the late reverberation decay.</dd>
	<dt>22 Density (0.0 to 100.0) default = 100.0</dt>
	<dd>Value that controls the modal density in the late reverberation decay</dd>
	<dt>23 Flags default = 63</dt>
	<dd>Bit flags that modify the behavior of above properties<ul>
		<li>1 - 'EnvSize' affects reverberation decay time</li>

		<li>2 - 'EnvSize' affects reflection level</li>
		<li>4 - 'EnvSize' affects initial reflection delay time</li>
		<li>8 - 'EnvSize' affects reflections level</li>
		<li>16 - 'EnvSize' affects late reverberation delay time</li>
		<li>32 - AirAbsorptionHF affects DecayHFRatio</li>
		<li>64 - 'EnvSize' affects echo time</li>

		<li>128 - 'EnvSize' affects modulation time</li>
	</ul></dd>
</dl>

<hr>

<a name=/sound/var/echo>
<h2>echo var (sound)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/sound/var>vars (sound)</a>
<dd><a href=#/sound/var/xyz>x, y, z vars (sound)</a>
<dd><a href=#/sound/var/environment>environment var (sound)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>null
</dl>

<p>If set to an 18-element list, this value customizes reverbration settings
for this sound only. A null or non-numeric value for any setting will select
its default. Please see the EAX2 documentation at http://developer.creative.com/
for indepth information about these settings.

<p>Here's a rundown of some of the terms: <b>Direct</b> refers to the amount
of effect when the sound is on a direct path to the listener.
<b>Obstruction</b> is when an object is blocking the direct path but there
are other ways for the sound to reach the listener. <b>Occlusion</b> means
the sound is on the other side of a wall, and mostly blocked.
<b>Exclusion</b> means the sound is on the other side of a wall, but a
doorway or window is be allowing it to pass through to the listener. You can
use a little of each of these effects to increase realism.

<dl>
	<dt>1 Direct  (-10,000 to 1,000) default = 0</dt>
	<dd>direct path level (at low and mid frequencies)</dd>
	<dt>2 DirectHF  (-10,000 to 0) default = 0</dt>

	<dd>relative direct path level at high frequencies </dd>
	<dt>3 Room  (-10,000 to 1,000) default = 0</dt>
	<dd>room effect level (at low and mid frequencies)</dd>
	<dt>4 Room HF  (-10,000 to 0) default = 0</dt>
	<dd>relative room effect level at high frequencies</dd>
	<dt>5 Obstruction  (-10,000 to 0) default = 0</dt>

	<dd>main obstruction control (attenuation at high frequencies)</dd>
	<dt>6 ObstructionLFRatio (0.0 to 1.0) default = 0.0</dt>
	<dd>obstruction low-frequency level re. main control</dd>
	<dt>7 Occlusion  (-10,000 to 0) default = 0</dt>
	<dd>main occlusion control (attenuation at high frequencies)</dd>
	<dt>8 OcclusionLFRatio  (0.0 to 1.0) default = 0.25</dt>

	<dd>occlusion low-frequency level re. main control</dd>
	<dt>9 OcclusionRoomRatio  (0.0 to 10.0) default = 1.5</dt>
	<dd>relative occlusion control for room effect</dd>
	<dt>10 OcclusionDirectRatio  (0.0 to 10.0) default = 1.0</dt>
	<dd>relative occlusion control for direct path</dd>
	<dt>11 Exclusion  (-10,000 to 0) default = 0</dt>

	<dd>main exlusion control (attenuation at high frequencies)</dd>
	<dt>12 ExclusionLFRatio  (0.0 to 1.0) default = 1.0</dt>
	<dd>exclusion low-frequency level re. main control</dd>
	<dt>13 OutsideVolumeHF  (-10,000 to 0) default = 0</dt>
	<dd>outside sound cone level at high frequencies</dd>
	<dt>14 DopplerFactor  (0.0 to 10.0) default = 0.0</dt>

	<dd>like DS3D flDopplerFactor but per source</dd>
	<dt>15 RolloffFactor  (0.0 to 10.0) default = 0.0</dt>
	<dd>like DS3D flRolloffFactor but per source</dd>
	<dt>16 RoomRolloffFactor  (0.0 to 10.0) default = 0.0</dt>
	<dd>like DS3D flRolloffFactor but for room effect</dd>
	<dt>17 AirAbsorptionFactor  (0.0 to 10.0) default = 1.0</dt>

	<dd>multiplies AirAbsorptionHF member of environment reverb properties.</dd>
	<dt>18 Flags default = 7</dt>
	<dd>Bit flags that modify the behavior of properties<ul>
		<li>1 - Automatic setting of 'Direct' due to distance from listener</li>
		<li>2 - Automatic setting of 'Room' due to distance from listener</li>
		<li>4 - Automatic setting of 'RoomHF' due to distance from listener</li>
	</ul></dd>
</dl>

<hr>

<a name=/turf>
<h2>turf</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom>atom</a>
<dd><a href=#/turf/proc>procs (turf)</a>
<dd><a href=#/turf/var>vars (turf)</a>
<dd><a href=#/map>Map</a>
</dl>

<p>Turfs cover the surface of the map.  They are derived from /turf.

<h3>Example:</h3>
<xmp>
turf
  floor
    desc = "A wood plank floor."
  wall
    desc = "A stone wall."
    density = 1
</xmp>

<p>This example defines the turf prototype turf/floor and /turf/wall.

<p>Turfs cannot be moved. They can only be created or destroyed by changing
world.maxx, world.maxy, or world.maxz. When you create a new turf with new(),
it always replaces the old one.

<h3>Example:</h3>
<xmp>
// replace old_turf with a wall
var/turf/wall/T = new(old_turf)
</xmp>

<hr>

<a name=/turf/proc>
<h2>procs (turf)</h2>

<p>Built-in turf procs:

<dl><dt>turf/proc
<dd><a href=#/atom/proc/Click>Click</a>
<dd><a href=#/atom/proc/DblClick>DblClick</a>
<dd><a href=#/datum/proc/Del>Del</a>
<dd><a href=#/atom/proc/Enter>Enter</a>
<dd><a href=#/atom/proc/Entered>Entered</a>
<dd><a href=#/atom/proc/Exit>Exit</a>
<dd><a href=#/atom/proc/Exited>Exited</a>
<dd><a href=#/atom/proc/MouseDown>MouseDown</a>
<dd><a href=#/atom/proc/MouseDrag>MouseDrag</a>
<dd><a href=#/atom/proc/MouseDrop>MouseDrop</a>
<dd><a href=#/atom/proc/MouseEntered>MouseEntered</a>
<dd><a href=#/atom/proc/MouseExited>MouseExited</a>
<dd><a href=#/atom/proc/MouseMove>MouseMove</a>
<dd><a href=#/atom/proc/MouseUp>MouseUp</a>
<dd><a href=#/atom/proc/MouseWheel>MouseWheel</a>
<dd><a href=#/atom/proc/New>New</a>
<dd><a href=#/datum/proc/Read>Read</a>
<dd><a href=#/atom/proc/Stat>Stat</a>
<dd><a href=#/datum/proc/Topic>Topic</a>
<dd><a href=#/datum/proc/Write>Write</a>
</dl>

<hr>

<a name=/turf/var>
<h2>vars (turf)</h2>

<p>Built-in turf vars:

<dl><dt>turf/var
<dd><a href=#/atom/var/alpha>alpha</a>
<dd><a href=#/atom/var/appearance>appearance</a>
<dd><a href=#/atom/var/appearance_flags>appearance_flags</a>
<dd><a href=#/atom/var/blend_mode>blend_mode</a>
<dd><a href=#/atom/var/color>color</a>
<dd><a href=#/atom/var/contents>contents</a>
<dd><a href=#/atom/var/density>density</a>
<dd><a href=#/atom/var/desc>desc</a>
<dd><a href=#/atom/var/dir>dir</a>
<dd><a href=#/atom/var/gender>gender</a>
<dd><a href=#/atom/var/icon>icon</a>
<dd><a href=#/atom/var/icon_state>icon_state</a>
<dd><a href=#/atom/var/invisibility>invisibility</a>
<dd><a href=#/atom/var/underlays>underlays</a>
<dd><a href=#/atom/var/overlays>overlays</a>
<dd><a href=#/atom/var/loc>loc</a>
<dd><a href=#/atom/var/layer>layer</a>
<dd><a href=#/atom/var/luminosity>luminosity</a>
<dd><a href=#/atom/var/mouse_over_pointer>mouse_over_pointer</a>
<dd><a href=#/atom/var/mouse_drag_pointer>mouse_drag_pointer</a>
<dd><a href=#/atom/var/mouse_drop_pointer>mouse_drop_pointer</a>
<dd><a href=#/atom/var/mouse_drop_zone>mouse_drop_zone var</a>
<dd><a href=#/atom/var/mouse_opacity>mouse_opacity var</a>
<dd><a href=#/atom/var/name>name</a>
<dd><a href=#/atom/var/opacity>opacity</a>
<dd><a href=#/turf/var/parent_type>parent_type</a>
<dd><a href=#/atom/var/pixel_x>pixel_x</a>
<dd><a href=#/atom/var/pixel_y>pixel_y</a>
<dd><a href=#/atom/var/pixel_w>pixel_w</a>
<dd><a href=#/atom/var/pixel_z>pixel_z</a>
<dd><a href=#/atom/var/plane>plane</a>
<dd><a href=#/atom/var/suffix>suffix</a>
<dd><a href=#/datum/var/tag>tag</a>
<dd><a href=#/atom/var/text>text</a>
<dd><a href=#/atom/var/transform>transform</a>
<dd><a href=#/datum/var/type>type</a>
<dd><a href=#/datum/var/vars>vars</a>
<dd><a href=#/atom/var/verbs>verbs</a>
<dd><a href=#/atom/var/x>x</a>
<dd><a href=#/atom/var/y>y</a>
<dd><a href=#/atom/var/z>z</a>
</dl>

<hr>

<a name=/turf/var/parent_type>
<h2>parent_type var (turf)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/datum/var/parent_type>parent_type var</a>
</dl>

<p>The default parent_type of <a href=#/turf>/turf</a> is <a href=#/atom>/atom</a>.

<hr>

<a name=/var>
<h2>vars</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/operator/path>path operators</a>
<dd><a href=#/atom/var>vars (atom)</a>
<dd><a href=#/client/var>vars (client)</a>
<dd><a href=#/datum/var>vars (datum)</a>
<dd><a href=#/mob/var>vars (mob)</a>
</dl>

<p>Variables are derived from var.

<dl><dt><b>Variable Declaration Format:</b>
<dd>var/Type/Name = Value
<dd>var Type/Name = Value
</dl>

<p>Value defaults to null.

<dl><dt>The hard-coded types are:
<dd><a href=#/datum>datum</a> (ancestor of all objects)
<dd><a href=#/atom>atom</a>   (all mappable objects)
<dd><a href=#/atom/movable>atom/movable</a> (objs and mobs)
<dd><a href=#/obj>obj</a>
<dd><a href=#/mob>mob</a>
<dd><a href=#/turf>turf</a>
<dd><a href=#/area>area</a>
<dd><a href=#/savefile>savefile</a>
<dd><a href=#/client>client</a>
<dd><a href=#/list>list</a>
<dd><a href=#/world>world</a>
</dl>

<dl><dt>Type modifiers:
<dd><a href=#/var/global>global</a>
<dd><a href=#/var/const>const</a>
<dd><a href=#/var/tmp>tmp</a>
</dl>

<p>User types may be derived from anything except for /world, /list, /client,
and /savefile.

<hr>

<a name=/var/const>
<h2>const vars</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/var>vars</a>
</dl>

<p>The const type modifier defines a constant value.  This may be useful for
centralizing the location of a value that is used repeatedly so that it can be
easily configured.  It has the advantage over #define macros of obeying the
normal scope rules for variables.  This means, for example, that a const
variable declared inside a proc will not conflict with other variables
declared elsewhere.

<h3>Example:</h3>
<xmp>
mob
  var/const/max_items = 100

  Enter(O)
    if(src.contents.len >= src.max_items)
      return 0
    return ..()
</xmp>

<p>This example defines an upper limit on the number of items a mob may
carry.

<hr>

<a name=/var/global>
<h2>global vars</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/var>vars</a>
</dl>

<p>The global type modifier makes a var permanent and shared.  This means
only one copy of the var is maintained.  Otherwise, separate copies of the
var are maintained for each instance containing the var (be it a proc, mob,
obj, etc.)

<h3>Example:</h3>
<xmp>
mob/proc/Counter()
  var/global/count
  src << "Count = [++count]"
</xmp>

<p>This example increases the count each time the proc is called.  If count
were not declared global, the displayed count would be 1 every time.

<hr>

<a name=/var/tmp>
<h2>tmp vars</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/savefile>savefile</a>
<dd><a href=#/var>vars</a>
</dl>

<p>The tmp type modifier indicates that an object variable should not be
automatically written to the save file.  This could mean that the variable
is transient--that is, it is calculated at run-time and need not be saved.
It could also indicated that the designer will handle saving of that
variable specially and wishes to bypass the automated routine.

<p>It is especially important to use tmp when you have references to
external objects that should not be saved along with the object.  For
example, suppose players have a <var>leader</var> variable which indicates
who or what they are following.  You would not necessarily want the leader
to be saved in the player's savefile.  Therefore, you would need to use
<code>tmp</code> when defining the variable.

<h3>Example:</h3>
<xmp>
mob
   var/tmp
      leader
   verb
      follow(mob/M)
         leader = M
</xmp>

<dl><dt>The following built-in variables are defined as tmp vars:
<dd><a href=#/datum/var/type>type</a>
<dd><a href=#/datum/var/parent_type>parent_type</a>
<dd><a href=#/datum/var/vars>vars</a>
<dd><a href=#/atom/var/verbs>verbs</a>
<dd><a href=#/mob/var/group>group</a>
<dd><a href=#/atom/var/loc>loc</a>
<dd><a href=#/atom/var/x>x</a>
<dd><a href=#/atom/var/y>y</a>
<dd><a href=#/atom/var/z>z</a>
<dd><a href=#/mob/var/ckey>ckey</a>
</dl>

<hr>

<a name=/verb>
<h2>verbs</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/verb/arguments>arguments (verb)</a>
<dd><a href=#/verb/set>settings (verb)</a>
<dd><a href=#/verb/var>vars (verbs)</a>
</dl>

<p>Verbs may be attached to mobs, objs, turfs, and areas.  Players can then
use them as commands if they have access to the source.

<p>Verbs are fundamentally the same "type" as procs, so their vars are the
same.

<h3>Example:</h3>
<xmp>
mob/verb/poof()
  world << "POOF!"
</xmp>

<p>Whenever a player in the world types the command "poof", this verb will
be invoked.

<p>In addition to the normal access control (see the verb src setting) verbs
can be dynamically added and removed from objects.  One way to do this is to
use new() with the following syntax:

<xmp>
new verb_path(Destination,Name,Desc)
</xmp>

<p>The Destination specifies the object to receive the verb.  Name and Desc
optionally specify a new name and description for the verb.

<h3>Example:</h3>
<xmp>
mob/DM/verb/kill(mob/M)
  del(M)

mob/DM/verb/give_kill_verb(mob/M)
  new/mob/DM/verb/kill(M)
</xmp>

<p>This example defines two verbs (accessible to mobs of type /mob/DM).  One
verb kills other mobs.  The other adds the kill verb to another mob (giving
the second mob the ability to kill).

<p>In some situations, the ability to dynamically change an object's verb
list is quite useful, but most of the time it is far more convenient to do
the same thing by manipulating objects rather than verbs directly.  For
example, the previous example can be handled by having an object with the
kill verb attached it it.  Then players have greater versatility in
manipulating the verb by simply moving the object around.

<h3>Example:</h3>
<xmp>
obj/scroll/kill/verb/kill(mob/M)
  set src = usr.contents //implicit src
  del(M)
</xmp>

<p>The use of an implicit verb source in this example gives the user access
to the kill verb without having to specify the source scroll as long as the
scroll exists in the user's inventory.  In other words, the player types
"kill rat" rather than "kill kill rat".

<hr>

<a name=/verb/arguments>
<h2>arguments (verb)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/verb/arguments/expanding>argument expanding</a>
<dd><a href=#/client/var/command_text>command_text (client)</a>
</dl>

<p>The parameters to a verb are referred to as arguments.  For verbs, the
input type and possible value list may also be specified.

<p>The possible input types are:

<pre>
text          // a quoted text string
password      // un-echoed text (for use with input() only)
message       // multi-line text
command_text  // raw command text from the rest of the input line
num           // a number
icon          // an icon file from the user's computer
sound         // a sound file from the user's computer
file          // any type of file from the user's computer
key           // a key from the user's BYOND key file
color         // a color (see <a href="#/proc/rgb">rgb proc</a>)
null          // indicates that the argument is optional

mob
obj
turf
area
anything
</pre>

<p>These can be combined with the '|' operator.  The first group are called
<EM>constant</EM> input types because they turn on various types of literal
values that the user can type in (like a number or a text string).  The
second group work in conjunction with a list of objects or values.  They are
called input type <EM>filters</EM> because they may be used to filter out
certain types of values from the list.  For example a mob or an obj within
sight would be specified as follows:

<xmp>
myverb(M as mob|obj in view()) {...}
</xmp>

<p>A default value may be specified which takes effect in the case of null
arguments.  For example:

<xmp>
myverb(M=usr as null|mob|obj in view()) {...}
</xmp>

<p>In this example, the input type <code>null</code> did not have to be used
explicitly, because assigning a default value (in this case
<code>usr</code>) turns it on by default.

<p>The <code>anything</code> input type can be used to combine values in a
list with other constant input types.  Here, this is done with the
<code>null</code> input type:

<xmp>
set_aggression(a="on" as null|anything in list("on","off"))
</xmp>

<p>For input types containing mob, obj, turf, or area, the possible value
list defaults to view().

<p>If no input type is specified, the variable type will be used to
determine whether it is a mob, obj, turf, or area.

<h3>Example:</h3>
<xmp>
mob/verb/tell(mob/M,msg as text)
  M << "[usr] tells you, /"[msg]/""
</xmp>

<p>This example defines a verb with two arguments: a target mob, and some
text.

<hr>

<a name=/verb/arguments/expanding>
<h2>argument expanding</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/verb/arguments>arguments (verb)</a>
</dl>

<p>The expression used to to provide a list of possible values for a verb
argument may reference the value of arguments prior to the one being
expanded.  It may even reference the value of the argument being expanded,
but this will always be a text string equal to what the user has typed so
far.

<p>In addition, there is a special variable called "expanding" which is only
accessible in this context.  It is 1 if the user's input is being expanded
and 0 if the user's final input is being validated.  In certain rare cases,
you may wish to tell the difference between these two cases.  For example,
you could use this to have possible values which do not show up in the
expansion lists, but which are accepted when typed in full.

<h3>Example:</h3>

<xmp>
mob/verb/test(A in MyProc(A,expanding))
   usr << "You typed: [A]"

proc/MyProc(A,expanding)
   var/values[] = list("one","two","three")
   if(!expanding) values += "secret"
   return values
</xmp>

<hr>

<a name=/verb/set>
<h2>settings (verb)</h2>

<p>verb settings:

<code><pre>
verb/set
  <a href=#/verb/set/name>name</a>
  <a href=#/verb/set/desc>desc</a>
  <a href=#/verb/set/category>category</a>
  <a href=#/verb/set/hidden>hidden</a>
  <a href=#/verb/set/popup_menu>popup_menu</a>
  <a href=#/verb/set/instant>instant</a>
  <a href=#/verb/set/invisibility>invisibility</a>
  <a href=#/verb/set/src>src</a>
  <a href=#/proc/set/background>background</a>
</pre></code>

<p>Procs and verbs are the same "type" so these attributes may be set for
procs as well; most of them do not have any meaning, however, unless the proc
is invoked as a verb (by adding it to a verb list).

<hr>

<a name=/verb/set/category>
<h2>category setting (verb)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/var/default_verb_category>default_verb_category var (client)</a>
<dd><a href=#/client/var/show_verb_panel>show_verb_panel var (client)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>set category = "Category"
</dl>

<dl><dt><b>Args:</b>
<dd>Category: A text string for the category.
</dl>

<p>Verbs in the same category are visually grouped together in the verb
panels.  The default is "", which is displayed in the default panel titled
"Commands".  You can change that default by setting
<code>client/default_verb_category</code>.

<p>To hide a verb from all panels, set the category to null.  The verb may
still show up in right-click popup menus, so you may want to use the
<a href=#/verb/set/hidden>hidden</a> or <a href=#/verb/set/popup_menu>popup_menu</a>
verb properties instead.

<hr>

<a name=/verb/set/desc>
<h2>desc setting (verb)</h2>

<dl><dt><b>Format:</b>
<dd>set desc = "Description"
</dl>

<dl><dt><b>Args:</b>
<dd>Description: A text string containing the help text.
</dl>

<p>The desc attribute sets the descriptive help string for the verb.  The
player may access this by hitting the 'F1' key after entering the command.
This will normally produce a list of each argument by type followed by the
desc text.  If you wish to override the syntax description, put your
modified version inside parentheses at the beginning of the desc text.

<h3>Example:</h3>
<xmp>
mob/verb/tell(mob/M,T as text)
   set desc = "(target,message) Talk privately to someone."
   M << "[usr] tells you, '[T]"
</xmp>

<p>This will produce the help text:

<xmp>
usage: tell target message (Talk privately to someone.)
</xmp>

<p>If the syntax description had not been supplied, it would have produced:

<xmp>
usage: tell mob "text" (Talk privately to someone.)
</xmp>

<hr>

<a name=/verb/set/hidden>
<h2>hidden setting (verb)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/verb/set/category>category setting (verb)</a>
<dd><a href=#/verb/set/invisibility>invisibility setting (verb)</a>
<dd><a href=#/verb/set/name>name setting (verb)</a>
<dd><a href=#/verb/set/popup_menu>popup_menu setting (verb)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>set hidden = Setting
</dl>

<dl><dt><b>Args:</b>
<dd>Setting: 1 for hidden verbs; 0 otherwise.
</dl>

<p>A hidden verb is not visible to players (in menus or in expansion lists)
but if typed in full can still be accessed.

<p>An alternate way to hide a verb from the command-line and verb panels is to
make "." the first character in the name.  The verb will not show up in
command-expansion (ie when hitting spacebar) until the "." has been typed.
This could be useful for hiding verbs that would otherwise clutter up the verb
list, while still making them relatively easy to use.  If you think this is a
random quirky feature, you are right.  To put "." in front of the name, use the
<a href=#/verb/set/name>name setting</a>.

<hr>

<a name=/verb/set/instant>
<h2>instant setting (verb)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/verb/set>settings (verb)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>set instant = Setting
</dl>

<dl><dt><b>Args:</b>
<dd>Setting: 1 for "instant" verbs; 0 otherwise.
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>Normally a player can only call one verb per tick, but they can call any
number of "instant" verbs in the same tick. This setting is useful for commands
called by the game's interface, or for more responsive controls like for
instance the use of "combos" in fighting games.

<p>Verbs with the instant setting can be used on the same tick as a regular
verb, but only one regular verb can be used each tick. Commands are still
processed in the order they are received, so verbs that use this setting
may have to wait if several regular verbs are queued up ahead of them.

<p>Any verbs that are already built-in, such as movement commands and mouse
commands, cannot be modified to use this setting. You can, however, create
replacement verbs of your own for most of them.

<h3>Example:</h3>
<xmp>
mob/verb/FastNorth()
  set instant = 1
  usr.Move(get_step(usr,NORTH), NORTH)
</xmp>

<p>To avoid abuse by players, you should use this setting for commands that
are unlikely to cause "spam" or give players any kind of unfair advantage.

<hr>

<a name=/verb/set/invisibility>
<h2>invisibility setting (verb)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/verb/set/hidden>hidden setting (verb)</a>
<dd><a href=#/atom/var/invisibility>invisibility var (atom)</a>
<dd><a href=#/mob/var/sight>sight var (mob)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>set invisibility = Setting
</dl>

<dl><dt><b>Args:</b>
<dd>Setting: 0 to 100
</dl>

<dl><dt><b>Default value:</b>
<dd>same as invisibility of the source object.
</dl>

<p>An invisible verb is only accessible to players who can see invisible
objects.  This is different from a hidden verb which does not clutter up the
verb list but which is still accessible when typed in full.

<hr>

<a name=/verb/set/name>
<h2>name setting (verb)</h2>

<dl><dt><b>Format:</b>
<dd>set name = "Name"
</dl>

<dl><dt><b>Args:</b>
<dd>Name: A text string for the name.
</dl>

<p>The name attribute of a verb defaults to the node name.  Setting the name
attribute explicitly may be necessary if the name includes characters not
allowed in node names.

<hr>

<a name=/verb/set/popup_menu>
<h2>popup_menu setting (verb)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/verb/set/category>category setting (verb)</a>
<dd><a href=#/verb/set/hidden>hidden setting (verb)</a>
<dd><a href=#/verb/set/invisibility>invisibility setting (verb)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>set popup_menu = Setting
</dl>

<dl><dt><b>Args:</b>
<dd>Setting: 1 (default) for showing this verb in the popup menus; 0 otherwise.
</dl>

<p>Use this to prevent a verb from showing up in the popup "context" menu when
users right-click on objects.

<hr>

<a name=/verb/set/src>
<h2>src setting (verb)</h2>

<dl><dt><b>Format:</b>
<dd>set src in List
<dd>set src = List
</dl>

<dl><dt><b>Args:</b>
<dd>List: One of view(), oview(), world, world.contents, usr, usr.contents,
     usr.loc, or usr.group
</dl>

<p>With the first format, if src is in List for a particular player, then
that player will have access to the proc.  The player must explicitly
specify the name of the source on the command line.

<p>The second format behaves the same, except the source is not read from
the command line.  If more than one possible source exists, one will be
chosen at random.

<p>When usr or world is specified for the first format, it will be expanded
to usr.contents and world.contents respectively.

<p>The default setting depends on the type of src:

<xmp>
mob: src = usr
obj: src in usr // short for usr.contents
turf: src = view(0)
area: src = view(0)
</xmp>

<h3>Example:</h3>
<xmp>
obj/verb/examine()
  set src in view()
  usr << "You examine [src]."
</xmp>

<h3>Example:</h3>
<xmp>
obj/MagicCloak/verb/disappear()
  set src = usr.contents

  usr.invisibility = 1
  view() << "[usr] disappears!"
</xmp>

<hr>

<a name=/verb/set/visibility>
<h2>visibility setting (verb)</h2>

<dl><dt><b>See:</b>
<dd><a href=#/verb/set/invisibility>invisibility setting (verb)</a>
</dl>

<p>The function of this variable has been replaced by
<code>invisibility</code>, which provides a full range of settings.

<hr>

<a name=/verb/var>
<h2>vars (verbs)</h2>
<dl><dt><b>See:</b>
<dd><a href=#/proc/var>vars (procs)</a>
</dl>

<hr>

<a name=/verb/var/@dt; toc=".">
<h2>. var (verb)</h2>

<dl><dt><b>See:</b>
<dd><a href=#/proc/var/@dt;>. var (proc)</a>
</dl>

<hr>

<a name=/verb/var/args>
<h2>args list var (verb)</h2>
<dl><dt><b>See:</b>
<dd><a href=#/proc/var/args>args list var (proc)</a>
</dl>

<hr>

<a name=/verb/var/src>
<h2>src var (verb)</h2>
<dl><dt><b>See:</b>
<dd><a href=#/proc/var/src>src var (proc)</a>
</dl>

<hr>

<a name=/verb/var/usr>
<h2>usr var (verb)</h2>
<dl><dt><b>See:</b>
<dd><a href=#/proc/var/usr>usr var (proc)</a>
</dl>

<hr>

<a name=/world>
<h2>world</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/proc>procs (world)</a>
<dd><a href=#/world/var>vars (world)</a>
</dl>

<p>The world node is used to define some global properties for the world.
Like the other types, the world has overridable vars and procs.  New vars
and procs cannot be defined under world though; to make global vars and
procs, use /var and /proc instead.

<hr>

<a name=/world/proc>
<h2>procs (world)</h2>

<p>Built-in world procs:

<dl><dt>world/proc
<dd><a href=#/world/proc/AddCredits>AddCredits</a>
<dd><a href=#/world/proc/ClearMedal>ClearMedal</a>
<dd><a href=#/world/proc/Del>Del</a>
<dd><a href=#/world/proc/Export>Export</a>
<dd><a href=#/world/proc/GetConfig>GetConfig</a>
<dd><a href=#/world/proc/GetCredits>GetCredits</a>
<dd><a href=#/world/proc/GetMedal>GetMedal</a>
<dd><a href=#/world/proc/GetScores>GetScores</a>
<dd><a href=#/world/proc/Import>Import</a>
<dd><a href=#/world/proc/IsBanned>IsBanned</a>
<dd><a href=#/world/proc/IsSubscribed>IsSubscribed</a>
<dd><a href=#/world/proc/New>New</a>
<dd><a href=#/world/proc/OpenPort>OpenPort</a>
<dd><a href=#/world/proc/PayCredits>PayCredits</a>
<dd><a href=#/world/proc/Reboot>Reboot</a>
<dd><a href=#/world/proc/Repop>Repop</a>
<dd><a href=#/world/proc/SetConfig>SetConfig</a>
<dd><a href=#/world/proc/SetMedal>SetMedal</a>
<dd><a href=#/world/proc/SetScores>SetScores</a>
<dd><a href=#/world/proc/Topic>Topic</a>
</dl>

<hr>

<a name=/world/proc/AddCredits>
<h2>AddCredits proc (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/proc/GetCredits>GetCredits proc (world)</a>
<dd><a href=#/world/proc/PayCredits>PayCredits proc (world)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>AddCredits(player, credits, note)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if the credits were added successfully, 0 or null otherwise.
</dl>

<dl><dt><b>Args:</b>
<dd>player: a mob, client, key, or ckey
<dd>credits: A number of credits to add to the player's account
<dd>note: An optional note (for author purposes) for the credit change
</dl>

<p>Adds credits to a player's account. The proc will return 1 if it is
successful, or 0 if the attempt failed and should not be tried again. This
feature is intended for games that make use of the credit system, and for
security all such games must use a hub password.

<p>This proc will return null if there was no way to reach the hub. Use
isnull() to check for a null value. Contacting the hub may take a few
moments, so it is a good idea to use spawn() to avoid holding up the rest of
the game.

<h3>Example:</h3>
<xmp>
mob/proc/QuestCompleted(name, credits)
    src << "Congratulations! You completed the [name] quest and earned [credits] credit\s!"
    world.AddCredits(name, credits, "Quest: [name]")
</xmp>

<p><b>Security note:</b> You can specify a different hub path and hub_password
by adding these as extra arguments, but this is not recommended for security
reasons. If you use this feature, it should only be on games that cannot be
downloaded by the public.

<hr>

<a name=/world/proc/ClearMedal>
<h2>ClearMedal proc (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/proc/GetMedal>GetMedal proc (world)</a>
<dd><a href=#/world/proc/SetMedal>SetMedal proc (world)</a>
<dd><a href=#/world/proc/GetScores>GetScores proc (world)</a>
<dd><a href=#/world/proc/SetScores>SetScores proc (world)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>ClearMedal(medal, player)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if the medal was rescinded successfully, 0 or null otherwise.
</dl>

<dl><dt><b>Args:</b>
<dd>medal: name of the medal being rescinded
<dd>player: a mob, client, key, or ckey
</dl>

<p>Removes a medal from a player. The proc will return 1 if it is successful, or
0 if the medal was not already awarded. If the world already knows this medal was
not earned, the hub will not be contacted.

<p>This proc will return null if there was no way to reach the hub. Use
isnull() to check for a null value. Contacting the hub may take a few
moments, so it is a good idea to use spawn() to avoid holding up the rest of
the game.

<h3>Example:</h3>
<xmp>
mob/NPC
   Die(mob/killer)  // assume Die() is a proc all mobs have
      spawn()
         if(ismob(killer) && killer.key)
            world.ClearMedal("Pacifist", killer)
</xmp>

<p><b>Security note:</b> You can specify a different hub path and hub_password
by adding these as extra arguments, but this is not recommended for security
reasons. If you use this feature, it should only be on games that cannot be
downloaded by the public.

<hr>

<a name=/world/proc/Del>
<h2>Del proc (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/datum/proc/Del>Del proc (datum)</a>
<dd><a href=#/proc/shutdown>shutdown proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Del()
</dl>

<dl><dt><b>When:</b>
<dd>Called when the world is shutdown.
</dl>

<dl><dt><b>Default action:</b>
<dd>Shutdown the world.
</dl>

<p>When the world is destroyed, only the Del() proc of the <code>world</code>
object is called automatically.  If you want to delete any other objects, you
must do so from within <code>world/Del()</code>.  Once this procedure returns,
any other procedures which may still be executing are immediately aborted and
all objects are silently destroyed.

<p>To prevent accidental hangs during <code>world/Del()</code> from preventing
shutdown, a timeout is applied to any sleeping operations such as
<code>sleep</code>, <code>world.Export()</code>, and so on.  If the total time
slept exceeds the timeout, <code>world/Del()</code> is aborted.  Currently,
this timeout is set at 30 seconds.

<hr>

<a name=/world/proc/Error>
<h2>Error proc (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/try>try and catch keywords</a>
<dd><a href=#/proc/throw>throw keyword</a>
<dd><a href=#/exception>exception</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Error(exception)
</dl>

<dl><dt><b>Args:</b>
<dd>exception: The error that was thrown. If this was a runtime error, the value will be an /exception datum.
</dl>

<p>Called when a runtime error happens, or the throw keyword is used, without
a try/catch to handle it. The return value is ignored.

<hr>

<a name=/world/proc/Export>
<h2>Export proc (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/Export>Export proc (client)</a>
<dd><a href=#/world/proc/Import>Import proc (world)</a>
<dd><a href=#/world/proc/Topic>Topic proc (world)</a>
<dd><a href=#/proc/link>link proc</a>
<dd><a href=#/proc/shutdown>shutdown proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Export(Addr,File,Persist,Clients)
</dl>

<dl><dt><b>When:</b>
<dd>Call this to send a message to another server.  The message may be
     composed of an optional topic text string (in the address) and an
     optional file.  This will call world.Topic() on the remote server,
     which may in turn call world.Import() to access the file.
</dl>

<dl><dt><b>Args:</b>
<dd>Addr: The address of the recipient server.  It should be in the form
     byond://server?topic.  The topic portion is optional.
<dd>File: The (optional) file to send.  This could be a cache file (in
     single quotes) an external file (in double quotes) or a savefile.
<dd>Persist: Set to 1 to indicate that the server should keep this connection
open, to expedite subsequent calls to the same address.  An open connection can
be closed at a later time by passing 0 in the Persist field.
<dd>Clients: An optional client, or list of clients, to tell the receiver
about.
</dl>

<dl><dt><b>Default action:</b>
<dd>Send the topic text string and file to the remote server and return the
     result of calling world.Topic() there.  Note that this will cause the
     caller to sleep while waiting for the necessary data to be transfered.
</dl>

<h3>Example:</h3>
<xmp>
mob/verb/shout(Msg as text)
  world << Msg
  world.Export("[ShadowWorld]?shout:[Msg]")
</xmp>

<p>This example defines a verb that will broadcast a message to everyone in
this world as well as sending it in the form of topic text to another world
whose address is stored in the variable ShadowWorld.  This address could be
manually set or could be the result of calling startup().

<p>It is also possible to access an HTTP server via world.Export().  Simply
use an http address such as: <tt>http://www.byond.com</tt>.  This returns a
list of HTTP header parameters as well as the extra values "STATUS" and
"CONTENT". The value associated with the "STATUS" entry is the HTTP status
code returned by the web server (as text). The value associated with the
"CONTENT" entry is the requested resource.

<h3>Example:</h3>
<xmp>
mob/verb/test()
  var/http[] = world.Export("http://www.byond.com")

  if(!http)
    usr << "Failed to connect."
    return

  usr << "HTTP Header:"
  for(var/V in http)
    usr << "[V] = [http[V]]"

  usr << "\n"

  var/F = http["CONTENT"]
  if(F)
    usr << html_encode(file2text(F))
</xmp>

<p>Note that the HTTP request is submitted using the GET method as opposed to
the POST method.  Support for POST may be added in the future.

<p>If the Clients argument is used, it accepts a client that is currently
loggedin, a mob belonging to such a client, or a list of any of these. The
remote server will receive a list of their keys in world.Topic().

<hr>

<a name=/world/proc/GetConfig>
<h2>GetConfig proc (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/proc/IsBanned>IsBanned proc (world)</a>
<dd><a href=#/world/proc/SetConfig>SetConfig proc (world)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>GetConfig(config_set,param)
</dl>

<dl><dt><b>Returns:</b>
<dd>Value of requested parameter.
</dl>

<dl><dt><b>Args:</b>
<dd>config_set: name of the configuration set (see below)
<dd>param: name of the configuration parameter
</dl>

<p>This command is for retrieving configuration information that is shared
by applications installed on the same system.  The configuration data is
accessed by specifying the configuration "set" and the parameter within that
set.  The "sets" defined so far are:

<xmp>
env       system environment variables (changes are not persistent)
admin     list of site administrators
ban       list of banned users or IP addresses
keyban    list of banned users (deprecated)
ipban     list of banned addresses (deprecated)
</xmp>

<p>If no parameter is specified, a list of the names of all available
parameters is returned.

<p>The format of the configuration data itself is currently being defined.
It will generally be a sequence of parameters (such as produced by
list2params()).  For example, each ban entry would have the user's ckey or
ckeyEx as the parameter, and might have data such as
"reason=jerkish;message=You+jerk!".

<h3>Example:</h3>

<xmp>
mob/verb
   ban(key as text)
      world.SetConfig("ban",ckey(key),"reason=fiendish;admin=[ckey]")
   lookban(key as null|text)
      if(key)
         usr << "[key]: [world.GetConfig("ban",key)]"
      else
         var/lst[] = world.GetConfig("ban")
         for(key in lst)
            usr << "[key]: [world.GetConfig("ban",key)]"
</xmp>

<p>Ban files store information on a game-specific basis. You will only be
able to read and write values that are set for the game you are running 
(defined by the value of world.hub).  It is possible for a host to specify
universal bans as well, but these will not be accessible via GetConfig or
SetConfig.  If you are using "ban" as the config_set, IP addresses are
recognized automatically.  (See the ban format info below.)

<p>It is possible, but rarely useful, to specify a configuration "space" of
SYSTEM, USER, HOME, or APP.  Settings made in the SYSTEM space are shared by
all BYOND software on the computer.  The USER space is shared by all software
owned by the same user.  The HOME space is shared by all worlds running with
the same safe home directory.  The APP space is shared by all software running
from the same filesystem directory.  By default, the USER space is used, and
if that cannot be modified (in safe mode), then HOME is used instead.  These
distinctions are sometimes important on a UNIX machine, where there are many
BYOND sites belonging to different users, but even then, the default behavior
is almost always what you want.

<p>The configuration space is specified inside the configuration set
parameter like this:

<xmp>
world.SetConfig("APP/keyban",...)
</xmp>

<p>When reading configuration settings, the spaces are always lumped
together.  In cases of settings with the same name but different values, APP
overrides HOME, which overrides USER, which overrides SYSTEM.

<h3>Ban Format</h3>

<p>If you want to create or read bans at runtime by using the "ban" config
set, these are the main parameters currently used:

<dl>
<dt>type</dt>
<dd>The ban's type, if any. It can be "sticky", "session", or "time", or a
combination separated by commas.  Session bans expire when the current
session is over (world.Reboot() does not affect this).

<dt>reason</dt>
<dd>The reason the ban was implemented; this is for the host's or admin's
purposes only and is not displayed to the user.

<dt>message</dt>
<dd>A message to display to the user.

<dt>keys</dt>
<dd>Other keys caught in a sticky ban.

<dt>IP</dt>
<dd>Other IP addresses caught in a sticky ban.

<dt>computer_id</dt>
<dd>Other computer_id values caught in a sticky ban.

<dt>time</dt>
<dd>The number of seconds remaining in the ban. The type parameter must include
"time" for this to mean anything. If this parameter is not present when a timed
ban is read, it means the ban has expired.
</dl>

<p>The old "keyban" and "ipban" config files are now just aliases for "ban".

<hr>

<a name=/world/proc/GetCredits>
<h2>GetCredits proc (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/proc/AddCredits>AddCredits proc (world)</a>
<dd><a href=#/world/proc/PayCredits>PayCredits proc (world)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>GetCredits(player)
</dl>

<dl><dt><b>Returns:</b>
<dd>Number of credits if hub contact was successful, null otherwise.
</dl>

<dl><dt><b>Args:</b>
<dd>player: a mob, client, key, or ckey
</dl>

<p>Retrieves the number of available credits in a player's account. This
feature is intended for games that make use of the credit system, and for
security all such games must use a hub password.

<p>This proc will return null if there was no way to reach the hub. Use
isnull() to check for a null value. Contacting the hub may take a few
moments, so it is a good idea to use spawn() to avoid holding up the rest of
the game.

<p>The best time to call this proc is before a player does something that
would allow them to spend credits, and/or just afterward, so they can see
what is left in their account.

<p><b>Security note:</b> You can specify a different hub path and hub_password
by adding these as extra arguments, but this is not recommended for security
reasons. If you use this feature, it should only be on games that cannot be
downloaded by the public.

<hr>

<a name=/world/proc/GetMedal>
<h2>GetMedal proc (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/proc/SetMedal>SetMedal proc (world)</a>
<dd><a href=#/world/proc/ClearMedal>ClearMedal proc (world)</a>
<dd><a href=#/world/proc/GetScores>GetScores proc (world)</a>
<dd><a href=#/world/proc/SetScores>SetScores proc (world)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>GetMedal(medal, player)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if the medal has been earned by the player
<dd>0 if the medal has not been earned
<dd>A list of medals in list2params() format if checking all medals
<dd>null if the hub cannot be contacted
</dl>

<dl><dt><b>Args:</b>
<dd>medal: name of the medal being checked
<dd>player: a mob, client, key, or ckey
</dl>

<p>Checks to see if a medal has been awarded to the player in question. If
the medal has been awarded, the return value is 1. If not, 0.

<p>You can also use GetMedal() to read a list of all medals a player has
earned for the hub entry, by leaving the medal argument blank. If you also
leave the player argument blank, you will get a list of all medals available
to the hub entry. In both cases the result can be parsed with params2list().

<p>This proc will return null if there was no way to reach the hub or
otherwise verify the medal's status. Use isnull() to check for a null value.

<p>Whenever possible, GetMedal() will avoid contacting the hub by using the
information it was given when the user logged in. If contacting the hub is
required, the proc may take a few moments to return a result. It is a good
idea to use spawn() to avoid holding up the rest of the game.

<h3>Example:</h3>
<xmp>
turf/medal_door
  density = 1
  icon_state = "closed"
  var/medal = "Dragon slayer"

  verb/Knock()
    usr << "<b>Guard:</b> Just checking your credentials...."
    var/hasmedal = world.GetMedal(medal, usr)
    if(hasmedal)
      usr << "<b>Guard:</b> Go right in."
      icon_state = "open"
      density = 0
    else if(!isnull(hasmedal))
      usr << "<b>Guard:</b> Sorry, no admittance without a <b>[medal]</b> badge."
    else
      usr << "<b>Guard:</b> Sorry, I lost the paperwork. Try again later."
</xmp>

<p>You can add an optional hub path argument if you want to look at a medal
for a different hub entry.

<hr>

<a name=/world/proc/GetScores>
<h2>GetScores proc (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/proc/SetScores>SetScores proc (world)</a>
<dd><a href=#/world/proc/GetMedal>GetMedal proc (world)</a>
<dd><a href=#/world/proc/SetMedal>SetMedal proc (world)</a>
<dd><a href=#/world/proc/ClearMedal>ClearMedal proc (world)</a>
</dl>

<dl><dt><b>Formats:</b>
<dd>GetScores(key, fields)
<dd>GetScores(count, field)
<dd>GetScores(count, skip, field)
</dl>

<dl><dt><b>Returns:</b>
<dd>A parameter list of scores for a given entry. Use params2list() to
interpret the results.
</dl>

<dl><dt><b>Args:</b>
<dd>key: the name of the player, character, etc. for which scores have been set
<dd>fields: The data fields to retrieve
<dd>count: The number of top score records to look at
<dd>skip: The number of top score records to skip over
</dl>

<p>Retrieves information about scores that is kept on the BYOND hub.

<p>This proc will return null if there was no way to reach the hub. Use
isnull() to check for a null value. Contacting the hub may take a few
moments, so it is a good idea to use spawn() to avoid holding up the rest of
the game.

<h3>GetScores(key, fields)</h3>

<p>In this form, you can get information about individual scores. This is
the most common way to use GetScores().

<p>The key is an arbitrary text value. Usually a player's key is a good
choice, but you can also use the name of their character, or anything else
you like, as long as it is unique. The key is case-insensitive.

<p>Scores and stats use data fields, which might be things like "Score",
"Level", "Class", etc. To retrieve all the fields associated with a key,
leave the fields argument blank. To retrieve only certain fields, you can
send a separated list like "Score;Level" which is in the same format returned
by list2params().

<p>If you leave the key argument blank, you will get a complete list of keys
that have scores and stats associated with them.

<h3>Example 1:</h3>
<xmp>
mob/var/scores_found
mob/var/score = 0

mob/Login()
  ..()
  spawn()
    var/scores = world.GetScores(key)
    scores_found = !isnull(scores)
    if(scores)
      var/list/params = params2list(scores)
      if(params["Score"])
        score = text2num(params["Score"])
        src << "You have [score] point\s!"
</xmp>

<h3>GetScores(count, field)<br/>
<i>and</i> GetScores(count, skip, field)</h3>

<p>In this form, the proc gets a list of the top scores for a certain field,
and gives you the keys and scores in order. To get the top 10 players by
level, for instance, you would use GetScores(10,"level"). This returns a
parameter list with the top keys and scores, so it might be in a form like
"Bob=100;Anita=80;David=20;Charlie=5".

<p>The count and skip arguments are always numbers, not text. The count is
the number of scores to retrieve, and skip is the number to skip over to get
to them. So count=10 and skip=0 is the top 10, while count=10 and skip=5 is
#6 through #15. If you leave out skip, it's a 0.

<p>The way you set up your hub entry is how the top scores are determined.
If you told the hub that the "score" field is always sorted from highest
number to lowest, then that's what you'll get. If "birthplace" is set up to
use an alphabetical order, that's the order that GetScores() will use. If a
field cannot be sorted, this form of GetScores() will return an empty text
string.

<p>If you don't specify a field, your hub entry may have a default field to
use. For instance if your hub page displays "Score", then "Level", then the
"Score" field is the default.

<h3>Example 2:</h3>
<xmp>
mob/var/scores_found

mob/Login()
  ..()
  spawn()
    var/top_scores = world.GetScores(10, "Booty")
    scores_found = !isnull(scores)
    if(scores)
      var/list/params = params2list(scores)
      src << "<b>Top Buccaneers:</b>"
      for(var/i=1, i<params.len, ++i)
        var/player = params[i]
        var/loot = params[player]
        src << "[i]\th place: [player] with [loot] doubloon\s"
      if(params.len && params[1] == key)
        src << "Ye be master of the seas! Take thy well-earned hat."
        icon_state = "Commodore"
</xmp>

<p><b>Security note:</b> You can specify a different hub path and hub_password
by adding these as extra arguments, but this is not recommended for security
reasons. If you use this feature, it should only be on games that cannot be
downloaded by the public.

<hr>

<a name=/world/proc/Import>
<h2>Import proc (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/proc/Export>Export proc (world)</a>
<dd><a href=#/client/proc/Import>Import proc (client)</a>
<dd><a href=#/world/proc/Topic>Topic proc (world)</a>
<dd><a href=#/proc/fcopy>fcopy proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Import()
</dl>

<dl><dt><b>Returns:</b>
<dd>The file sent by the remote server.  The file will be downloaded to the
     local server's resource cache.  Note that this will cause the caller to
     sleep while waiting for the necessary data to be transfered.
</dl>

<dl><dt><b>When:</b>
<dd>Call this inside world.Topic() if you are expecting a file from the
     remote server.
</dl>

<h3>Example:</h3>
<xmp>
//sending the file
mob/proc/Export(Addr)
  var/savefile/F = new()
  F.Write(src)
  world.Export(Addr,F)

//receiving the file
world/Topic()
  var/savefile/F = new(world.Import())
  F.Read() //read the mob
</xmp>

<p>This example defines a mob proc called Export() which writes the mob to a
savefile and sends it to another server (specified by Addr).  The remote
server opens it as a savefile and creates the mob (if the same mob type is
defined on both servers and mob.Read() is compatible with the sending
server's mob.Write()).

<p>Note that another method of transferring player mobs is to use the key
savefile (accessed by client.Export() and client.Import()).  Direct server
to server communication on the other hand could transfer data (like
non-players) without the need for player involvement at all.

<p>Savefiles are the most common type of file to transfer, but world.Import()
simply returns a reference to an item in the world's .rsc file, which could be
any type of file.  This particular example demonstrates how to open such a
file as a temporary savefile.  (It gets dumped from the cache into a separate
temporary file, which is then opened as a savefile.)  Other types of files
would be handled differently.  For example, you could use fcopy() to dump the
cached item to its own separate file.

<hr>

<a name=/world/proc/IsBanned>
<h2>IsBanned proc (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/proc/GetConfig>GetConfig proc (world)</a>
<dd><a href=#/proc/params2list>params2list proc</a>
<dd><a href=#/client/var/address>address var (client)</a>
<dd><a href=#/client/var/computer_id>computer_id var (client)</a>
<dd><a href=#/client/var/connection>connection var (client)</a>
<dd><a href=#/world/var/hub>hub var (world)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>IsBanned(key,address,computer_id,type)
</dl>

<dl><dt><b>Returns:</b>
<dd>True value if user is banned from this world.  This may be a list, in which case special meaning is attributed to certain list elements as described below.
</dl>

<dl><dt><b>Args:</b>
<dd>key: BYOND key of the user.
<dd>address: current IP address of the user.
<dd>computer_id: current computer_id of the user if known.
<dd>type: type of connection if known (see <a href=#/client/var/connection>client.connection</a>)
</dl>

<p>By default, this procedure checks the "ban" configuration file.  If an
entry is found for the current world (based on the value of world.hub), the
parameter text is converted into a list (using params2list()), and the result
is returned.  Otherwise, null is returned.

<p>A ban that applies to all worlds on the host's computer will not call
IsBanned(). The connection will simply be denied.

<p>This procedure is called internally whenever a new user connects (before
client/New() is called).  If the result is true, access is denied.  If you
want to ban a user but still allow them to log in (perhaps with reduced
functionality), you can put "Login=1" in the parameter text.  If you want to
display an explanation to the user about why they are banned, you can also put
"message=X" in the parameter text, where X is the message to display to the user.
A reason for the ban can be added with a "reason=X" field.  Of course, you can
also override IsBanned() and insert these values directly into the list that is
returned.

<h2>Example</h2>
<xmp>
world/IsBanned(key,address)
   . = ..()            //check the ban lists
   if(istype(., /list))
      .["Login"] = 1   //allow banned user to login
</xmp>

<p>When you ban people from paging you, this also causes them to be added to
the keyban list.  Even if they are already connected, IsBanned() will be
re-evaluated and acted upon at that time.  When you remove pager ban, they are
removed from keyban as well.

<p>Additional data elements may be added to the ban list in the future.
The current definition includes just the following items:

<dl>

<dt>Login
<dd>true if banned user should be allowed to log in

<dt>reason
<dd>text string describing the reason or origin of the ban.  For example, when
people are banned from the pager, they are added to the "keyban" list with
reason = "pager ban".  This text is internal information only and is not
displayed to the banned user.

<dt>message
<dd>text string explaining to the user why they were banned and possibly what
they should do to be forgiven.

</dl>

<p>Since the data in the "ban" file is in
<a href=#/proc/list2params>application/x-www-form-urlencoded</a> format, it is
probably not desirable to edit the file by hand.  No built-in facilities for
editing the file have been provided (aside from automatic addition of pager
bans), but an interface could be created, using <a href=#/world/proc/GetConfig>GetConfig</a>
and <a href=#/world/proc/SetConfig>SetConfig</a> to read and write the data.
Extra features could also be added such as automatic inference of key
associations by IP address.

<hr>

<a name=/world/proc/IsSubscribed>
<h2>IsSubscribed proc (world)</h2>

<dl><dt><b>Format:</b>
<dd>IsSubscribed(player)
<dd>IsSubscribed(player, "BYOND") (to check BYOND Membership)
</dl>

<dl><dt><b>Returns:</b>
<dd>Number of days left in subscription, -1 for a lifetime subscriber, <i>or</i> null if hub contact failed
</dl>

<dl><dt><b>Args:</b>
<dd>player: a mob, client, key, or ckey
</dl>

<p>Checks a player for their subscription status to this game. This is a
simpler alternative to client.CheckPassport(), which is deprecated, and also
allows you to check even when the player has gone offline.

<p>This proc will return null if contacting the hub was required, but there
was no way to reach the hub. Contacting the hub may take a few moments, so it
is a good idea to use spawn() to avoid holding up the rest of the game.

<h3>Example:</h3>
<xmp>
mob/verb/JoinClub()
    if(!world.IsSubscribed(src))
        src << "Sorry, the club is only for subscribers."
    else
        // go to the turf with the tag "clubhouse"
        loc = locate("clubhouse")
        src << "Welcome to the clubhouse!"
</xmp>

<p><b>Security note:</b> You can specify a different hub path and hub_password
by adding these as extra arguments, but this is not recommended for security
reasons. If you use this feature, it should only be on games that cannot be
downloaded by the public.

<hr>

<a name=/world/proc/New>
<h2>New proc (world)</h2>

<dl><dt><b>Format:</b>
<dd>New()
</dl>

<dl><dt><b>When:</b>
<dd>Called after the world is initially loaded.  The only procs preceding
     this one would be in the initialization of global variables and objects
     on the map.
</dl>

<dl><dt><b>Default action:</b>
<dd>None.
</dl>

<hr>

<a name=/world/proc/OpenPort>
<h2>OpenPort proc (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/port>port var (world)</a>
<dd><a href=#/world/var/visibility>visibility var (world)</a>
</dl>

<dl><dt><b>See also:</b>
<dd>OpenPort(port=0)
</dl>

<dl><dt><b>Args:</b>
<dd>port: the network port to open
</dl>

<dl><dt><b>Returns:</b>
<dd>1 on success; 0 on failure
</dl>

<p>This causes the world to be hosted on the specified network port.  A value
of 0 or "any" requests that any available port be used.  The value "none"
causes the port to be closed so that no new connections are possible.

<p>This proc may be overridden. If it is, calling ..() is necessary to open
the port. If ..() is not called, it will not open.

<h3>Example:</h3>
<xmp>
world/OpenPort(port)
  // only allow subscribers to host
  if(host_is_subscribed)
    return ..()
</xmp>

<p>The "ports" configuration option in cfg/byond.txt can be used to control
what ports worlds may open.  The -ports command-line option may also be used.
See <a href=#/proc/startup>startup</a> for the syntax.

<hr>

<a name=/world/proc/PayCredits>
<h2>PayCredits proc (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/proc/AddCredits>AddCredits proc (world)</a>
<dd><a href=#/world/proc/GetCredits>GetCredits proc (world)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>PayCredits(player, credits, note)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if the credits were spent successfully, 0 or null otherwise.
</dl>

<dl><dt><b>Args:</b>
<dd>player: a mob, client, key, or ckey
<dd>credits: A number of credits to deduct from the player's account
<dd>note: An optional note (for author purposes) for the credit change
</dl>

<p>Removes credits from a player's account, if they have enough. The proc
will return 1 if it is successful, or 0 if the attempt failed (usually
because the player doesn't have enough credits). This feature is intended
for games that make use of the credit system, and for security all such
games must use a hub password.

<p>This proc will return null if there was no way to reach the hub. Use
isnull() to check for a null value. Contacting the hub may take a few
moments, so it is often a good idea to use spawn() to avoid holding up the
rest of the game.

<h3>Example:</h3>
<xmp>
mob/proc/ItemShop()
    var/items = list("Get credits!", "Magic sword"=10, "Skeleton key"=50)
    var/choices[0]
    var/item,price
    for(item in items)
        price = items[item]
        choices["[item]: [price] credit\s"] = item

    var/credits = world.GetCredits(key)
    if(isnull(credits))
        src << "Sorry, the item shop isn't available right now."
        return

    var/choice = input(src,\
      "You have [credits] credit\s. What would you like to purchase?",\
      "Item Shop")\
      as null|anything in choices
    if(!choice) return  // cancel

    if(choice == "Get credits")
        src << link("http://www.byond.com/games/Author/MyGame/credits")
        return

    item = choices[choice]
    price = items[item]
    if(!price) return

    src << "Contacting item shop..."
    var/result = world.PayCredits(name, price, "Item shop: [item]")

    if(isnull(result))
        src << "Sorry, the item shop isn't available right now."
    else if(!result)
        src << "You need [price-credits] more credit\s to buy [item]."
    else
        src << "You bought \a [item]!"

        // Now give the user the item and save their character
        // These procs are for you to define
        src.AddEquipment(item)
        src.SaveCharacter()
</xmp>

<p><b>Security note:</b> You can specify a different hub path and hub_password
by adding these as extra arguments, but this is not recommended for security
reasons. If you use this feature, it should only be on games that cannot be
downloaded by the public.

<hr>

<a name=/world/proc/Reboot>
<h2>Reboot proc (world)</h2>

<dl><dt><b>Format:</b>
<dd>Reboot(reason)
</dl>

<dl><dt><b>Args:</b>
<dd>reason: the reason <tt>Reboot()</tt> was called:
  <ul>
    <li>0 or null: Called by game code</li>
    <li>1: By host (Ctrl+R in Dream Seeker)</li>
    <li>2: By <a href="#/world/proc/Topic">world.Topic()</a></li>
    <li>3: By SIGUSR1 in UNIX</li>
  </ul>
</dl>

<dl><dt><b>Default action:</b>
<dd></dl>

<p>Reload the world from scratch.  Any connected players will automatically
relogin.  This would be useful if you needed to recompile the world after
changing some code.

<p>In a UNIX environment, you can cause a running server to reboot by
sending it the signal SIGUSR1.

<p>If you override this proc, you must call ..() if you want the reboot to
complete normally.

<p>For reboots initiated by Dream Seeker, usr will be the mob belonging to
the player who sent the command.

<hr>

<a name=/world/proc/Repop>
<h2>Repop proc (world)</h2>

<dl><dt><b>Format:</b>
<dd>Repop()
</dl>

<dl><dt><b>Default action:</b>
<dd>Reload the obj and mob instances defined in the world map.  This
    "repopulates" a world to its initial state.  Only objects that were
    destroyed will be recreated.
</dl>

<hr>

<a name=/world/proc/SetConfig>
<h2>SetConfig proc (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/proc/GetConfig>GetConfig proc (world)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>SetConfig(config_set,param,value)
</dl>

<dl><dt><b>Args:</b>
<dd>config_set: name of the configuration set (see below)
<dd>param: name of the configuration parameter
<dd>value: data to store (or null to delete this entry)
</dl>

<p>This command is for storing configuration information that is shared by
applications installed on the same system.  The configuration data is
accessed by specifying the configuration "set" and the parameter within that
set.

<p>For more information, see <a href=#/world/proc/GetConfig>GetConfig</a>.

<hr>

<a name=/world/proc/SetMedal>
<h2>SetMedal proc (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/proc/GetMedal>GetMedal proc (world)</a>
<dd><a href=#/world/proc/ClearMedal>ClearMedal proc (world)</a>
<dd><a href=#/world/proc/GetScores>GetScores proc (world)</a>
<dd><a href=#/world/proc/SetScores>SetScores proc (world)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>SetMedal(medal, player)
</dl>

<dl><dt><b>Returns:</b>
<dd>1 if the medal was awarded successfully, 0 or null otherwise.
</dl>

<dl><dt><b>Args:</b>
<dd>medal: name of the medal being awarded
<dd>player: a mob, client, key, or ckey
</dl>

<p>Awards a medal to a player. The proc will return 1 if it is successful, or
0 if the medal was already awarded. If the world already knows this medal was
earned before, the hub will not be contacted.

<p>This proc will return null if there was no way to reach the hub. Use
isnull() to check for a null value. Contacting the hub may take a few
moments, so it is a good idea to use spawn() to avoid holding up the rest of
the game.


<h3>Example:</h3>
<xmp>
mob/monster/dragon
   Die(mob/killer)  // assume Die() is a proc all mobs have
      spawn()
         if(ismob(killer) && killer.key)
            world.SetMedal("Dragon slayer", killer)
</xmp>

<p><b>Security note:</b> You can specify a different hub path and hub_password
by adding these as extra arguments, but this is not recommended for security
reasons. If you use this feature, it should only be on games that cannot be
downloaded by the public.

<hr>

<a name=/world/proc/SetScores>
<h2>SetScores proc (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/proc/GetScores>GetScores proc (world)</a>
<dd><a href=#/world/proc/GetMedal>GetMedal proc (world)</a>
<dd><a href=#/world/proc/SetMedal>SetMedal proc (world)</a>
<dd><a href=#/world/proc/ClearMedal>ClearMedal proc (world)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>SetScores(key, fields)
</dl>

<dl><dt><b>Returns:</b>
<dd>The key, if the scores were successfully updated; null otherwise.
</dl>

<dl><dt><b>Args:</b>
<dd>key: the name of the player, character, etc. for which scores should be set
<dd>fields: The data fields to set
</dl>

<p>Updates scores that are kept on the BYOND hub.

<p>The key is an arbitrary text value. Usually a player's key is a good
choice, but you can also use the name of their character, or anything else
you like, as long as it is unique. The key is case-insensitive.

<p>Scores and stats use data fields, which might be things like "Score",
"Level", "Class", etc. Use list2params() to set the fields that you want to
change. Fields that you do not include in the list will not be changed. A
field with a blank value will be deleted.

<p>Sending an empty text string for the fields will erase the scores for that
key.

<p>This proc will return null if there was no way to reach the hub. Use
isnull() to check for a null value. Contacting the hub may take a few
moments, so it is a good idea to use spawn() to avoid holding up the rest of
the game.

<h3>Example:</h3>
<xmp>
var/params

// Change the Score and Pet fields
params = list("Score"=123, "Pet"="Dog")
world.SetScores("Tom", list2params(params))

// Delete the Pet field
params = list("Pet"="")
world.SetScores("Tom", list2params(params))

// Delete Tom's scores entirely
world.SetScores("Tom", "")
</xmp>

<p><b>Security note:</b> You can specify a different hub path and hub_password
by adding these as extra arguments, but this is not recommended for security
reasons. If you use this feature, it should only be on games that cannot be
downloaded by the public.

<hr>

<a name=/world/proc/Topic>
<h2>Topic proc (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/proc/Del>Del proc (world)</a>
<dd><a href=#/world/proc/Export>Export proc (world)</a>
<dd><a href=#/client/proc/Import>Import proc (client)</a>
<dd><a href=#/world/proc/Import>Import proc (world)</a>
<dd><a href=#/world/proc/Reboot>Reboot proc (world)</a>
</dl>
<dl><dt><b>Format:</b>
<dd>Topic(T,Addr,Master,Keys)
</dl>

<dl><dt><b>When:</b>
<dd>Called when a message is received from another server by using
    world.Export().  If a file is expected, world.Import() may be called to
    get it.  The return value of Topic() will be passed back to the remote
    server.
</dl>

<dl><dt><b>Args:</b>
<dd>T: The topic text string specified by the remote server (everything following ? in the URL).
<dd>Addr: The address of the remote server.
<dd>Master: 1 if remote server is the server which started this one.
<dd>Keys: List of keys belonging to users who are logged in on the remote server
</dl>

<dl><dt><b>Default action:</b>
<dd>The topic "ping" returns a true value (number of players plus one),
     which may be useful for telling if a server is alive.  The topics
     "Reboot" and "Del" will call world.Reboot() and world.Del()
     respectively if the message was sent by the master server.
</dl>

<h3>Example:</h3>
<xmp>
world/Topic(T)
  if(findtext(T,"shout:") == 1)
    world << copytext(T,7)
</xmp>

<p>This example allows other servers to send this server topic text of the
form "shout:msg" and will broadcast the message to all the players in this
world.

<p>The Keys argument is either null, or a list of user keys. Any keys in the
list are logged in to the remote server.

<hr>

<a name=/world/var>
<h2>vars (world)</h2>

<p>Built-in world vars:

<dl><dt>world/var
<dd><a href=#/world/var/address>address</a>
<dd><a href=#/world/var/area>area</a>
<dd><a href=#/world/var/cache_lifespan>cache_lifespan</a>
<dd><a href=#/world/var/contents>contents</a>
<dd><a href=#/world/var/cpu>cpu</a>
<dd><a href=#/world/var/executor>executor</a>
<dd><a href=#/world/var/fps>fps</a>
<dd><a href=#/world/var/game_state>game_state</a>
<dd><a href=#/world/var/host>host</a>
<dd><a href=#/world/var/hub>hub</a>
<dd><a href=#/world/var/hub_password>hub_password</a>
<dd><a href=#/world/var/icon_size>icon_size</a>
<dd><a href=#/world/var/internet_address>internet_address</a>
<dd><a href=#/world/var/log>log</a>
<dd><a href=#/world/var/loop_checks>loop_checks</a>
<dd><a href=#/world/var/map_format>map_format</a>
<dd><a href=#/world/var/maxx>maxx</a>
<dd><a href=#/world/var/maxy>maxy</a>
<dd><a href=#/world/var/maxz>maxz</a>
<dd><a href=#/world/var/mob>mob</a>
<dd><a href=#/world/var/name>name</a>
<dd><a href=#/world/var/params>params</a>
<dd><a href=#/world/var/port>port</a>
<dd><a href=#/world/var/realtime>realtime</a>
<dd><a href=#/world/var/reachable>reachable</a>
<dd><a href=#/world/var/sleep_offline>sleep_offline</a>
<dd><a href=#/world/var/status>status</a>
<dd><a href=#/world/var/system_type>system_type</a>
<dd><a href=#/world/var/tick_lag>tick_lag</a>
<dd><a href=#/world/var/tick_usage>tick_usage</a>
<dd><a href=#/world/var/turf>turf</a>
<dd><a href=#/world/var/time>time</a>
<dd><a href=#/world/var/timeofday>timeofday</a>
<dd><a href=#/world/var/url>url</a>
<dd><a href=#/world/var/version>version</a>
<dd><a href=#/world/var/view>view</a>
<dd><a href=#/world/var/visibility>visibility</a>
</dl>

<hr>

<a name=/world/var/address>
<h2>address var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/port>port var (world)</a>
<dd><a href=#/world/var/url>url var (world)</a>
<dd><a href=#/world/var/internet_address>internet_address var (world)</a>
</dl>

<p>This is the network address of the machine hosting the world.  If it
cannot be determined, it will be null.

<p>The full network address of the world may be formed by concatenating the
world address and port: "byond://[address]:[port]".

<p>In CGI mode, this is the web address of the world.

<p>This is the local address only. If the world is hosted via a router, the
external IP address may be different. Use <tt>internet_address</tt> to find
the external address, if available.

<hr>

<a name=/world/var/area>
<h2>area var (world)</h2>

<dl><dt><b>Default value:</b>
<dd>/area.
</dl>

<p>This is the default area type to be placed on the map wherever no area is
specified.  A value of 0 turns off the default area.

<hr>

<a name=/world/var/byond_version>
<h2>byond_version var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/preprocessor/DM_VERSION>DM_VERSION macro</a>
<dd><a href=#/client/var/byond_version>byond_version var (client)</a>
<dd><a href=#/world/var/system_type>system_type var (world)</a>
</dl>

<p>This is the version of BYOND at run-time.  A game designed to work around
known bugs in older versions could use this to adapt its behavior accordingly.

<hr>

<a name=/world/var/cache_lifespan>
<h2>cache_lifespan var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/DM/cache>cache</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>30 (days)
</dl>

<p>Number of days items that are not in use will be saved in the resource
cache (.rsc file).  Files uploaded by players are stored in the world's .rsc
file for future use.  If the file is not used for the specified amount of
time, it will be removed to save space.

<p>Setting this value to 0 causes items to be saved for the current session
only.  This is used by the CGI library, because web browsers cannot make use
of server-side caches when uploading files anyway.

<p>This value must be a whole number.

<hr>

<a name=/world/var/contents>
<h2>contents list var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/list>list</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>List of all areas, turfs, mobs, and objs initially in the world.
</dl>

<p>This is a list of every object in the world.  Objects in this list are in
no particular order.

<h3>Example:</h3>
<xmp>
proc/ListAreas(mob/M)
  var/area/A
  M << "Areas:"
  for (A in world.contents)
    M << A
</xmp>

<p>This example displays a list of every area in existence.  As a convenient
short-hand, one may simply write for(A) or for(A in world) instead of the
full for(A in world.contents).

<hr>

<a name=/world/var/cpu>
<h2>cpu var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/tick_lag>tick_lag var (world)</a>
<dd><a href=#/world/var/tick_usage>tick_usage var (world)</a>
</dl>

<p>This is the percentage of a server tick that the server spends processing
running procs.  A value of 0 would indicate very little cpu usage.  A value
of 100 would indicate full cpu usage, which could mean that the server
cannot complete all the necessary computations during a tick to finish in
time for the next tick.  In this case, timed events (such as sleep) may take
longer than requested.

<p>When deciding on a value for tick_lag, one could use this value to
determine if the CPU is fast enough to tick at a higher rate.

<hr>

<a name=/world/var/executor>
<h2>executor var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/startup>startup proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>executor = "/usr/local/byond/bin/DreamDaemon [params]"
</dl>

<p>This option is for direct execution of <code>.dmb</code> files in UNIX.
The most common use is for writing CGI programs that are executed by the web
server.

<p>The first parameter in the <var>executor</var> text string is the path to
DreamDaemon.  The one listed above is the standard UNIX location.

<p>Optional parameters may follow.  The most common are -CGI and -logself.

<h3>Example:</h3>
<xmp>
world/executor = "/usr/local/byond/bin/DreamDaemon -CGI -logself"
</xmp>

<p>This example creates a CGI program to be executed by a web server.  It
puts its error output in the file <code><var>projname</var>.log</code>.

<p>All of this is configured for you when you include
<code>html/CGI.dm</code> from the html library.

<hr>

<a name=/world/var/fps>
<h2>fps var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/tick_lag>tick_lag var (world)</a>
<dd><a href=#/client/var/fps>fps var (client)</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>10
</dl>

<p>The value of world.fps defines the speed of the world in frames (server
ticks) per second. By default this is 10 fps, which is a good speed if all
objects move in full tiles. Higher values yield smoother results, but at a
cost to performance. Timing of many events may be limited by the system
clock, so fps values beyond 40 or 50 may cause unwanted effects like jitter
even for projects that are not very demanding in terms of performance.

<p>For projects making use of pixel movement, higher fps is usually desired.
40 seems to be a good value for general use, but in worlds that have a large
number of players, you may wish to lower the value and give players a higher
step_size per tick instead.

<p>This var exists for convenience; it is calculated by 10 / world.tick_lag.
The value of world.tick_lag is actually more accurate, but it is easier to
think of world speed in terms of frames per second. The actual tick rate has
a resolution of 1ms.

<p>When reading world.fps, the result is always given as a whole number to
gloss over rounding error.

<p>If you set client.tick_lag or client.fps to a value other than 0, you can
make the client tick at a different (usually faster) rate.

<hr>

<a name=/world/var/game_state>
<h2>game_state var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/name>name var (world)</a>
<dd><a href=#/world/var/status>status var (world)</a>
<dd><a href=#/world/var/visibility>visibility var (world)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>At runtime, this value may be changed to let the BYOND hub know about
certain changes in the game's status. An example for using this value is if
the number of players in the game gets too high and most new logins are
rejected, you can set game_state to 1 to let the hub know this server is
full.

<p>The following values are accepted:

<dl>
<dt>0</dt><dd>Normal status</dd>
<dt>1</dt><dd>Server is full -- do not trigger waiting-list alerts for this server</dd>
</dl>

<p>Note that this value does not affect how your world reacts to new players
logging in.


<hr>

<a name=/world/var/host>
<h2>host var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/game_state>game_state var (world)</a>
<dd><a href=#/world/var/name>name var (world)</a>
<dd><a href=#/world/var/status>status var (world)</a>
<dd><a href=#/world/var/visibility>visibility var (world)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>null
</dl>

<p>If the information is made available by the pager, this will provide the
key of the world's host. If the host is not known, this value will be either
null or an empty string.

<hr>

<a name=/world/var/hub>
<h2>hub var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/hub_password>hub_password var (world)</a>
<dd><a href=#/world/var/name>name var (world)</a>
<dd><a href=#/world/var/status>status var (world)</a>
<dd><a href=#/world/var/game_state>game_state var (world)</a>
<dd><a href=#/world/var/version>version var (world)</a>
<dd><a href=#/world/var/visibility>visibility var (world)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>null
</dl>

<p>This is a registered <a href=http://www.byond.com/hub/>BYOND hub</a> path.
The default value of null is for unregistered games.  Registered games (don't
worry, it's free!) have their own hub page showing a brief description of the
game, the author, an optional installation package, and links to online games.
The hub path is a string of the form "YourName.GameName" and can be found in your
<a href="https://secure.byond.com/members/?command=edit_hub">hub console</a>.

<p>Even unregistered games show up in the hub when they are live (that is
online with people connected).  It just doesn't show any of the extra info
like a description, and there is no way for people to find out about it when
nobody is logged in.

<p>If you do not want your game to show up in the hub (like while you are in
the initial stages of development), just compile with
<code>visibility=0</code>.  Either that, or turn off your pager or your BYOND
locator when you are connected to it.

<p>You (or the players) might also wish to turn off the notice of a live
game in the hub when there is no longer any room for new players or if it is
too late in the game for new people to join.  At such times, you can simply
set the visibility to 0.

<h3>Example:</h3>
<xmp>
world
   hub = "Dan.PipeStock"   //registered hub path

mob/verb/start_game()
   world.visibility = 0
   //...
</xmp>

<p>If you configure your hub page to require a hub password, you must also
specify <code>world.hub_password</code>.

<hr>

<a name=/world/var/hub_password>
<h2>hub_password var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/hub>hub var (world)</a>
<dd><a href=#/world/var/visibility>visibility var (world)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>null
</dl>

<p>If <code>world.hub</code> is set, any live session of the game will be
attached to the specified BYOND Hub page.  Under the default settings,
any game can set <code>world.hub</code> and attach itself to any BYOND
Hub page.</p>

<p>To beef up security, you can set a hub password in your hub's
configuration page via the BYOND website.  This will ensure that
only authorized copies of your game can attach themselves to your
hub page when live.  Then simply copy that password into your code as
<code>world.hub_password</code> so that your game's live broadcast will
be accepted by the hub.</p>

<h3>Example:</h3>
<xmp>
world
   hub = "Dan.PipeStock"   //registered hub path
   hub_password = "UPAggnJaeXmSBoKK"   //password for live game authentication
</xmp>

<p>Note that for security reasons, reading this variable at runtime will
return a hashed version of the value that was set.</p>

<hr>

<a name=/world/var/icon_size>
<h2>icon_size var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
<dd><a href=#/atom/movable/var/step_size>step_size var (movable atoms)</a>
<dd><a href=#/{notes}/gliding>Gliding</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>32
</dl>

<p>This is the tile size that will be used as a default for icons in the
world. It can be set to a single number that represents both the width and
height, or you can use a format like "[width]x[height]" (such as "16x48") to
specify width and height separately.

<p>This value affects several calculations, including icon operations and
gliding between turfs.

<p>Please note: If you do not use a square icon size and you are using a
topdown map format, you may experience display issues if setting client.dir
to EAST or WEST. A non-square tile with a topdown map format will also
interfere with pixel movement. For this reason, square sizes are recommended
when using any topdown-view map_format.

<hr>

<a name=/world/var/internet_address>
<h2>internet_address var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/port>port var (world)</a>
<dd><a href=#/world/var/url>url var (world)</a>
<dd><a href=#/world/var/address>address var (world)</a>
</dl>

<p>This is the network address of the machine hosting the world, as it is
seen by the outside network (from the Internet) and the hub.  If it cannot
be determined, it will be null.

<p>The full network address of the world may be formed by concatenating the
world address and port: "byond://[address]:[port]".

<p>This var exists because <tt>world.address</tt> may not be accurate if the
world is hosted on a machine behind a router using NAT. The value returned
by <tt>internet_address</tt> can be given to other players who wish to log
in.

<hr>

<a name=/world/var/log>
<h2>log var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/file>file proc</a>
<dd><a href=#/proc/startup>startup proc</a>
</dl>

<p>Sending output to world.log may be useful for debugging purposes.  The
output goes to the same place run-time proc errors are displayed.

<h3>Example:</h3>
<xmp>
if(1+1 != 2)
  world.log << "Uh oh."
</xmp>

<p>You can assign world.log to a file name or file() object to redirect output
to that file.  (There is also a command-line option to Dream Daemon that does
this.)

<h3>Example:</h3>
<xmp>
world.log = file("mylog.txt")
</xmp>

<hr>

<a name=/world/var/loop_checks>
<h2>loop_checks var (world)</h2>

<dl><dt><b>Default value:</b>
<dd>1
</dl>

<p>Setting this to 0 disables the very long loop protection.  By default,
loops in the code which undergo a very large number of iterations or
recursions are aborted (by crashing the proc).  This prevents the proc from
locking up the server for too long.

<p>You may need to disable this feature if your code has some very long loops
in it.  Before doing that, make sure it's not <em>infinitely</em> long!  Your
program will utterly crash if it runs out of system stack space, which can
happen in a very deep or infinite recursion.

<hr>

<a name=/world/var/map_format>
<h2>map_format var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/icon_size>icon_size var (world)</a>
<dd><a href=#/world/var/view>view var (world)</a>
<dd><a href=#/client/var/view>view var (client)</a>
<dd><a href=#/atom/movable/var/screen_loc>screen_loc var (movable atoms)</a>
<dd><a href=#/{notes}/topdown>Topdown maps</a>
<dd><a href=#/{notes}/isometric>Isometric maps</a>
<dd><a href=#/{notes}/side>Side-view maps</a>
<dd><a href=#/{notes}/big-icons>Big icons</a>
<dd><a href=#/{notes}/tiled-icons>Tiled icons</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>TOPDOWN_MAP
</dl>

<dl><dt><b>Possible values:</b>
<dd><ul>
<li>TOPDOWN_MAP
<li>ISOMETRIC_MAP
<li>SIDE_MAP
<li>TILED_ICON_MAP
</ul>
</dl>

<p>This value says how the world will display maps. In a normal overhead
tiled map the value is TOPDOWN_MAP for the top-down format. For older games
that predate this feature, the value is TILED_ICON_MAP.

<p>If you use a map format other than top-down, the HUD will still use a
tile format like it would in top-down display. HUD objects are not projected
into whatever map_format you use and they are not affected by changing
client.dir. The size of the HUD is rounded up to the nearest number of full
screen tiles; the size of each tile is defined by world.icon_size.

<h3>Top-down format</h3>

(See more at <a href=#/{notes}/topdown>Topdown maps</a>.)

<p>This is the default map format. Icons are drawn in a tile form and viewed
from overhead. In this layout, the layer assigned to each atom is very
important. The number of tiles shown is set by client.view or world.view.

<p>Because this format is familiar and easy to understand, it is the default
setting. Most of the vars related to maps and atoms are designed and
documented with this format in mind.

<h3>Tiled icon format</h3>

(See more at <a href=#/{notes}/tiled-icons>Tiled icons</a>.)

In BYOND 4.0 a new feature was introduced for using "big" icons, bigger than
the standard tile size, by splitting them up into states like "0,0", "1,0",
and so on. This functionality is no longer needed since BYOND now has the
ability to display icons in their natural size. Some games that were designed
before this, however, may still need to make use of this splitting feature
that breaks icons into smaller tile-sized pieces.

When an icon is broken into chunks, each state in the icon is given a
thumbail version of the full image, and then new states are added to show
each chunk. For instance if world.icon_size is the default 32&times;32, and
the icon is 64&times;64, then the "door" state would become a thumbnail of
the full door image while "door 0,0" (the lower left corner), "door 1,0",
"door 0,1", and "door 1,1" were created to show each smaller section of the
image. If the default "" state is broken into chunks, those chunks are just
named "0,0" and so on without a space.

This format is deprecated. It exists to support older games and allow them to
be compiled without causing them to break, until they can be redesigned for
one of the newer formats.

<h3>Isometric format</h3>

(See more at <a href=#/{notes}/isometric>Isometric maps</a>.)

<p>If map_format is set to ISOMETRIC_MAP, the map is displayed in isometric
form. Isometric tiles are displayed in a foreshortened diagonal perspective,
where the "north" direction actually displays as northeast on the player's
screen, and "east" shows up as southeast. The value of client.view or
world.view is used to calculate the <i>minimum</i> number of tiles to
display, and extra tiles to each side will be shown to fill in the corners.

<p>In an isometric map, the tile width set in world.icon_size is the most
important factor. This should be a multiple of 4 for best results. The
minimum tile height is half that value, and any extra height is used to show
vertical structures that "stick up" off the map surface. When you draw an
isometric tile icon, start with a flattened diamond shape at the bottom that
is only half as high as it is wide.

<p>Isometric maps behave differently during drawing than top-down maps. In
isometric, tiles that are nearer to the viewer's perspective are drawn in
front of tiles farther back, regardless of layer. Layers only count within an
individual tile. This means that if you want to have a vertical structure
"stick up" to partially hide something behind it, the icon sticking up should
always be on a tile forward from the one being partly covered. E.g. if you
have a wall taking up part of your tile, it needs to be at the "back" end of
the tile to properly hide anything on the tiles behind it.

<p>The pixel_x and pixel_y values, step_x and step_y values, and the gliding
that happens when moving between tiles, are based on the width set by
world.icon_size. If you set world.icon_size="64x128" to show tall buildings,
only the 64 matters for pixel offsets. Use atom.pixel_w and atom.pixel_z to
adjust the position of atoms horizontally or vertically, without respect to
client.dir or the map format. A positive pixel_z value for instance makes an
object look higher up. The client also has pixel_w and pixel_z vars.
(<b>Note:</b> Offsets for x and y also affect the layering order used to draw
the icons. Any object with a pixel offset onto another tile is considered
part of whichever tile is closer.)

<p>If you use an icon wider than one tile, the "footprint" of the isometric
icon (the actual map tiles it takes up) will always be a square. That is, if
your normal tile size is 64 and you want to show a 128x128 icon, the icon is
two tiles wide and so it will take up a 2&times;2-tile area on the map. The
height of a big icon is irrelevant--any excess height beyond width/2 is used
to show vertical features. To draw this icon properly, other tiles on that
same ground will be moved behind it in the drawing order.

<p>One important warning about using big icons in isometric mode is that you
should only do this with dense atoms. If part of a big mob icon covers the
same tile as a tall building for instance, the tall building is moved back
and it could be partially covered by other turfs that are actually behind it.
A mob walking onto a very large non-dense turf icon would experience similar
irregularities.

<h3>Side-view format</h3>

(See more at <a href=#/{notes}/side>Side-view maps</a>.)

<p>The SIDE_MAP format is like a cross between TOPDOWN_MAP and ISOMETRIC_MAP.
It looks very similar to a top-down view but it is intended for more of a 3/4
perspective, where tiles lower on the screen are considered closer to the
viewer. Because this impacts the way layers work, most of the layering behavior
is the same as with isometric.

<p>In a 3/4 perspective the tiles are often foreshortened, so pixel offsets
are adjusted to account for this. For example, you may set world.icon_size to
"32x24", but the tile is considered to be a perfect square if you look
at it from the top down. Because the width is 32 pixels, the virtual height is
also 32, so if you use pixel_y=32 the atom will appear one tile further back
than it normally is. (This adjustment doesn't affect screen objects or pixel_z.)

<p>Changing client.dir preserves the same tile size regardless of orientation.

<hr>

<a name=/world/var/maxx>
<h2>maxx var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/area>area var (world)</a>
<dd><a href=#/world/var/maxy>maxy var (world)</a>
<dd><a href=#/world/var/maxz>maxz var (world)</a>
<dd><a href=#/world/var/turf>turf var (world)</a>
<dd><a href=#/map>Map</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>The world map is a three-dimensional block of turfs with coordinates
ranging from (1,1,1) to (maxx,maxy,maxz).  If set at compile time, it
provides a lower bound and will be increased as needed by the map files.

<p>The default value is 0, indicating no map.  If any of the map dimensions
are set to non-zero values at compile time, the others will default to 1.

<p>New territory created by increasing the map boundaries is filled in with
the default turf and area (world.turf, and world.area).

<hr>

<a name=/world/var/maxy>
<h2>maxy var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/area>area var (world)</a>
<dd><a href=#/world/var/maxx>maxx var (world)</a>
<dd><a href=#/world/var/maxz>maxz var (world)</a>
<dd><a href=#/world/var/turf>turf var (world)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>The world map is a three-dimensional block of turfs with coordinates
ranging from (1,1,1) to (maxx,maxy,maxz).  If set at compile time, it
provides a lower bound and will be increased as needed by the map files.

<p>The default value is 0, indicating no map.  If any of the map dimensions
are set to non-zero values at compile time, the others will default to 1.

<p>New territory created by increasing the map boundaries is filled in with
the default turf and area (world.turf, and world.area).

<hr>

<a name=/world/var/maxz>
<h2>maxz var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/area>area var (world)</a>
<dd><a href=#/world/var/maxx>maxx var (world)</a>
<dd><a href=#/world/var/maxy>maxy var (world)</a>
<dd><a href=#/world/var/turf>turf var (world)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>The world map is a three-dimensional block of turfs with coordinates
ranging from (1,1,1) to (maxx,maxy,maxz).  If set at compile time, it
provides a lower bound and will be increased as needed by the map files.

<p>The default value is 0, indicating no map.  If any of the map dimensions
are set to non-zero values at compile time, the others will default to 1.

<p>New territory created by increasing the map boundaries is filled in with
the default turf and area (world.turf, and world.area).

<hr>

<a name=/world/var/mob>
<h2>mob var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/proc/New>New proc (client)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>/mob.
</dl>

<p>When a player connects to the world, the world is searched for a mob with
the player's key.  If one is found, the player is connected to that mob.  If
none is found, a new mob of type world.mob is created and the player is
connected to this new mob.

<p>The default value is /mob.  Setting world.mob to 0 prevents the creation
of default mobs.

<h3>Example:</h3>
<xmp>
world
  mob = /mob/newbie

mob/newbie
  Login()
    src << "Welcome, [name]."
    ..()
</xmp>

<p>This example will connect new players to mobs of type /mob/newbie.  They
are welcomed when they connect.

<hr>

<a name=/world/var/name>
<h2>name var (world)</h2>

<dl><dt><b>Default value:</b>
<dd>The &lt;world&gt; part of the &lt;world&gt;.dmb file.
</dl>

<p>This is the name of the world.

<h3>Example:</h3>
<xmp>
world
  name = "The Void"
</xmp>

<hr>

<a name=/world/var/params>
<h2>params var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/list/associations>list associations</a>
<dd><a href=#/proc/params2list>params2list proc</a>
<dd><a href=#/proc/startup>startup proc</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>null
</dl>

<p>This is a list of parameters passed to the world from the command-line
-params option when the server was started.  The parameter text is passed
through params2list() to generate the world.params list.

<h3>Example:</h3>
<xmp>
world/New()
   var/p
   if(params.len) world.log << "Command-line parameters:"
   for(p in params)
      world.log << "[p] = [params[p]]"
</xmp>

<p>This example displays the value of each parameter.

<hr>

<a name=/world/var/port>
<h2>port var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/proc/OpenPort>OpenPort proc (world)</a>
<dd><a href=#/world/var/address>address var (world)</a>
<dd><a href=#/world/var/reachable>reachable var (world)</a>
<dd><a href=#/world/var/visibility>visibility var (world)</a>
</dl>

<p>This is the network port of the world.  If the world does not have an
open network port, this is 0.

<hr>

<a name=/world/var/realtime>
<h2>realtime var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/time>time var (world)</a>
<dd><a href=#/world/var/timeofday>timeofday var (world)</a>
<dd><a href=#/proc/time2text>time2text proc</a>
</dl>

<p>This is the time (in 1/10 seconds) since 00:00:00 GMT, January 1, 2000
(also known as the BYOND era).

<p>Because this is a large number, BYOND's number system isn't capable of
enough precision to deliver the exact number of 1/10 second ticks. It usually
rounds off to the nearest several seconds. For more accurate readings use
<code>world.timeofday</code>.

<hr>

<a name=/world/var/reachable>
<h2>reachable var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/port>port var (world)</a>
<dd><a href=#/world/proc/OpenPort>OpenPort proc (world)</a>
</dl>

<p>Returns 1 if the world is currently hosted and the port can be reached by
players (as determined by the BYOND hub), 0 if not.

<p>If the port is not reachable, there may be a brief period during which the
hub is still attempting to make contact; during that time the port is assumed
to be reachable. Currently, the reachability test times out and fails after
30 seconds.

<hr>

<a name=/world/var/sleep_offline>
<h2>sleep_offline var (world)</h2>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>Setting this to 1 causes the world to be suspended when there are no
players, even if you have sleeping procs waiting to happen.  The default
value is 0, which means the server will only sleep if there are no players
and no procs waiting to happen.  The main purpose of the variable is to save
the cpu from doing work when there is nobody around to appreciate it.  On the
other hand, that doesn't give the poor NPC's a break from the nasty humans.

<hr>

<a name=/world/var/status>
<h2>status var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/hub>hub var (world)</a>
<dd><a href=#/world/var/game_state>game_state var (world)</a>
<dd><a href=#/world/var/visibility>visibility var (world)</a>
</dl>

<p>This is a short text string used in BYOND hub to describe the state of a
game in progress.  For example, you might want to indicate if new players
will be able to actively play, or whether they would have to join as
spectators.

<h3>Example:</h3>
<xmp>
world
   status = "accepting players"
mob/verb/start_game()
   world.status = "accepting spectators"
   //...
</xmp>

<hr>

<a name=/world/var/system_type>
<h2>system_type var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/byond_version>byond_version var (world)</a>
<dd><a href=#/proc/shell>shell proc</a>
</dl>

<p>This variable indicates the operating system type at run-time.  It will be
one of the following constants:

<ul>
<li>MS_WINDOWS
<li>UNIX
</ul>

<hr>

<a name=/world/var/tick_lag>
<h2>tick_lag var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/fps>fps var (world)</a>
<dd><a href=#/client/var/tick_lag>tick_lag var (world)</a>
<dd><a href=#/world/var/tick_usage>tick_usage var (world)</a>
<dd><a href=#/proc/sleep>sleep proc</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>1
</dl>

<p>This is the smallest unit of time (one server tick) measured in 1/10
seconds.  The duration of events that take some finite amount of time (like
sleep) will be rounded to a whole number of ticks.

<p>Players are limited to one command (including movements) per server tick,
so this value can be used to adjust the responsiveness of the game.  If the
network is too slow to keep up with players, their commands will get queued
up, which can be annoying when trying to move.  In this case, tick_lag
should be increased so that the stored up movement commands are discarded.
On the other hand, if you have a very fast network, you may wish to decrease
tick_lag to speed up the response time to player commands.

<p>Often it is more convenient to set world.fps instead of world.tick_lag,
since fps (frames per second) is an easier way to think of server ticks.
world.tick_lag is 10 / world.fps and vice-versa, so a tick_lag of 0.25 is
equal to 40 fps.

<p>If you set client.tick_lag or client.fps to a value other than 0, you can
make the client tick at a different (usually faster) rate.

<hr>

<a name=/world/var/tick_usage>
<h2>tick_usage var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/cpu>cpu var (world)</a>
<dd><a href=#/world/var/tick_lag>tick_lag var (world)</a>
</dl>

<p>This is the approximate percentage of the server tick that has been used
already.  A value under 100 means there's time to do more calculations, which
can include any pending procs that are still waiting to run on this tick.
When the value is over 100, the tick is running long and your world will
experience lag.

<hr>

<a name=/world/var/time>
<h2>time var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/realtime>realtime var (world)</a>
<dd><a href=#/world/var/tick_lag>tick_lag var (world)</a>
</dl>

<p>This gives the amount of time (in 1/10 seconds) that the world has been
running.  In actual fact, it is the number of server ticks that have passed
multiplied by world.tick_lag.  Therefore if the server sleeps (when no
players are connected) this time is not counted.  Also, if the server runs
overtime during a tick (because procs take longer than tick_lag to finish)
this still only counts as one tick.  This value is therefore a measure of
"game time" rather than real time.

<hr>

<a name=/world/var/timeofday>
<h2>timeofday var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/realtime>realtime var (world)</a>
<dd><a href=#/world/var/time>time var (world)</a>
<dd><a href=#/proc/time2text>time2text proc</a>
</dl>

<p>This is the time (in 1/10 seconds) since 00:00:00 GMT today. It is
basically identical to <code>world.realtime</code> but doesn't include any
information about the date. This is a much smaller number; hence it is more
accurate.

<hr>

<a name=/world/var/turf>
<h2>turf var (world)</h2>

<dl><dt><b>Default value:</b>
<dd>/turf.
</dl>

<p>This is the default turf type to be placed on the map wherever no turf is
specified.  A value of 0 turns off the default turf.

<hr>

<a name=/world/var/url>
<h2>url var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/address>address var (world)</a>
</dl>

<p>This is the full network address of the world.  (For example,
byond://dan.byond.com:6005.)

<hr>

<a name=/world/var/version>
<h2>version var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/hub>hub var (world)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>0
</dl>

<p>If you are distributing your game to players, you can use this variable
to automatically notify them of new releases.  To do so, you will first need
to set <a href=#/world/var/hub><code>world.hub</code></a> to the hub
path of your game.  You can then advertise the current version by
configuring that value in your
<a href=https://secure.byond.com/members/?command=edit_hub>hub console</a>.

<p>When players boot up an outdated version of your game (as indicated by
comparing <code>world.version</code> with the version advertised by BYOND
hub), they will be notified of the new release.

<hr>

<a name=/world/var/view>
<h2>view var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/client/var/lazy_eye>lazy_eye var (client)</a>
<dd><a href=#/client/var/show_map>show_map var (client)</a>
<dd><a href=#/proc/view>view proc</a>
<dd><a href=#/client/var/view>view var (client)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>5
</dl>

<dl><dt><b>Possible values:</b>
<dd>-1 to 34 or "WIDTHxHEIGHT"
</dl>

<p>This is the default map viewport range.  The default value of 5 produces an
11x11 viewport.  A value of -1 turns off the map display altogether.  The client may automatically
scale down icons in order to conveniently fit the map on the player's screen.

<p>For non-square views, you can assign this to a text string of the form
"WIDTHxHEIGHT".  For example, "11x11" is equivalent to a view depth of 5, but
you could make it wider like this: "13x11".

<p>This setting also affects the default range of the <code>view()</code>,
<code>oview()</code>, <code>range()</code>, and <code>orange()</code>
procedures.

<p>If the entire map is small enough to fit on one screen 
(arbitrarily defined to be 21x21 or less),
the default <code>view</code> is automatically adjusted to fit the map.  In
this case, <code>client.lazy_eye</code> is also automatically turned on by
default, since you probably don't want the map to scroll around.

<hr>

<a name=/world/var/visibility>
<h2>visibility var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/proc/OpenPort>OpenPort proc (world)</a>
<dd><a href=#/world/var/hub>hub var (world)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>1 (visible)
</dl>

<p>This controls whether the world advertises itself in the
<a href=http://www.byond.com/games/>BYOND Hub</a> when it has an open network
port for accepting players.  The visibility of the world still depends on
whether any of the connected players has their location reporter turned on,
and that in turn relies on the pager being turned on.

<hr>

<a name=/{notes} toc="Special notes">
<h2>Special notes</h2>

<p>This section of the reference should help explain some concepts that
may be harder to understand or that can use more clarification.

<dl>
<dd><a href=#/{notes}/big-icons>Big icons</a>
<dd><a href=#/{notes}/color-matrix>Color matrix</a>
<dd><a href=#/{notes}/gliding>Gliding</a>
<dd><a href=#/{notes}/HUD>HUD / screen objects</a>
<dd><a href=#/{notes}/isometric>Isometric maps</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
<dd><a href=#/{notes}/regex>Regular expressions</a>
<dd><a href=#/{notes}/side>Side-view maps</a>
<dd><a href=#/{notes}/tiled-icons>Tiled icons</a>
<dd><a href=#/{notes}/topdown>Topdown maps</a>
<dd><a href=#/{notes}/BACKGROUND_LAYER>BACKGROUND_LAYER</a>
<dd><a href=#/{notes}/EFFECTS_LAYER>EFFECTS_LAYER</a>
<dd><a href=#/{notes}/TOPDOWN_LAYER>TOPDOWN_LAYER</a>
</dl>

<hr>

<a name=/{notes}/BACKGROUND_LAYER>
<h2>BACKGROUND_LAYER</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/layer>layer var (atom)</a>
<dd><a href=#/atom/var/plane>plane var (atom)</a>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
<dd><a href=#/{notes}/EFFECTS_LAYER>EFFECTS_LAYER</a>
<dd><a href=#/{notes}/TOPDOWN_LAYER>TOPDOWN_LAYER</a>
</dl>

<p>This is mostly deprecated.  Anegative value for plane is the preferred way
to do show objects in the background.  It can still be used however when you
want to rearrange objects in the same plane when using PLANE_MASTER for visual
effects (see <a href=#/atom/var/appearance_flags>appearance_flags</a>).

<p>BACKGROUND_LAYER is a special high value that can be added to the regular
layer of any atom.

<p>The purpose of this value is to make an atom appear below any regular
atoms. In an isometric map for instance, HUD objects will always appear above
the map, but makeing a HUD object appear behind the map is basically
impossible without this feature.

<p>When using this special layer, it should be added to the layer an atom
normally uses. For instance an obj should have a layer of BACKGROUND_LAYER +
OBJ_LAYER.

<p>This can be mixed with TOPDOWN_LAYER and EFFECTS_LAYER, but it will take
precedence over both. Anything with BACKGROUND_LAYER will always appear below
anything without it.

<p>Images or overlays with FLOAT_LAYER can be left alone. They will
automatically have the same layer as whatever atom they are attached to.

<hr>

<a name=/{notes}/big-icons toc="Big icons">
<h2>Big icons</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/icon>icon</a>
<dd><a href=#/icon/proc>icon procs</a>
<dd><a href=#/icon/proc/Blend>Blend proc (icon)</a>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
<dd><a href=#/world/var/icon_size>icon_size var (world)</a>
<dd><a href=#/{notes}/tiled-icons>Tiled icons</a>
<dd><a href=#/{notes}/isometric>Isometric maps</a>
<dd><a href=#/{notes}/side>Side-view maps</a>
</dl>

<p>BYOND allows you to use icons that are not the same size as the tile size
defined in world.icon_size. These icons can be manipulated with the /icon datum
using their raw, native size, and shown on the map in full size. To use the old
behavior where an atom can display only an icon of the normal tile size, use
the TILED_ICON_MAP value for map_format instead.

<p>When you use an icon of non-standard size on an atom, the icon is "anchored"
to the southwest corner of the atom. If you are using a top-down view
(world.map_format=TOPDOWN_MAP), the icon will appear to spread out further to
the east and north. In an isometric map (world.map_format=ISOMETRIC_MAP), the
icon will cover additional tiles north and east as well. The "footprint" of an
isometric icon--the actual map tiles it covers--is always square, so if your
tile size is 64x64 and you use a 128x64 icon, the 128-pixel width means the
icon will cover a 2x2 section of map tiles.

<p>It is important to remember that using a big icon is a visual effect
<i>only</i>. It will not affect how the atom bumps into other atoms or
vice-versa.

<p>Big icons will affect layering--the order in which icons are drawn. In
general, because a big icon is covering more than one tile of the map, it will
try to draw above any other tiles in that space that are on the same layer.
This way, you can set a turf to use a big icon without having to change the
turfs to the north and east. If an atom has a big icon, any overlays and
underlays attached to it will be pulled forward as well, so they will draw in
front of anything on their same layer. In isometric mode this is about the same,
except that the layer isn't that important--anything in the way will just be
moved back behind the big icon. (<b>Note:</b> Big overlays will not "pull
forward" on their own. If the main atom uses a single-tile icon, a big overlay
attached to it will not try to draw in front of other icons on the same layer.
This is so that name labels, health bar overlays, etc. will not cause any odd
behavior. To be safe, you should always specify a layer when adding an overlay.)

<p>In isometric mode, layering is affected by the "distance" between the atom
and the viewer, so putting a regular-sized icon and part of a big icon on the
same tile could cause layering oddities. Tiles that are covered by a big icon
will tend to be drawn behind the big icon as mentioned above. For this reason,
any atoms whose icons cover more than one tile (the extra height of an
isometric icon doesn't count) should always be dense, and you should block
movement onto any tile covered by them.

<p>When manipulating icons with the /icon datum, you can still use Blend() to
combine icons of different sizes. By default, the icons will be lined up at
their southwest corners. You can change the position at which the second icon
is blended.

<hr>

<a name=/{notes}/color-matrix toc="Color matrix">
<h2>Color matrix</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/color>color var (atom)</a>
<dd><a href=#/client/var/color>color var (client)</a>
<dd><a href=#/icon/proc/MapColors>MapColors proc (icon)</a>
</dl>

<p>A color matrix is used to transform colors, in the same way that a matrix
represented by the /matrix datum is used to transform 2D coordinates.  A
transformation matrix is 3x3, of which only 6 values are needed because the
last column is always the same.  A color matrix, because it transforms four
different numbers instead of two, is 5x5.

<pre>
                |rr rg rb ra 0|
                |gr gg gb ga 0|
[r g b a 255] x |br bg bb ba 0| = [r' g' b' a' 255]
                |ar ag ab aa 0|
                |cr cg cb ca 1|
</pre>

<p>In easier-to-understand terms, this is how the result is calculated:

<xmp>
new_red   = red * rr + green * gr + blue * br + alpha * ar + 255 * cr
new_green = red * rg + green * gg + blue * bg + alpha * ag + 255 * cg
new_blue  = red * rb + green * gb + blue * bb + alpha * ab + 255 * cb
new_alpha = red * ra + green * ga + blue * ba + alpha * aa + 255 * ca
</xmp>

<p>It is helpful to think of each row in the matrix as what each component of
the original color will become. The first row of the matrix is the rgba value
you'll get for each unit of red; the second is what each green becomes, and so
on.

<p>Because the fifth column of the matrix is always the same, only 20 of the
values need to be provided.  You can use a color matrix with atom.color or
client.color in any of the following ways:

<dl>
<dt>RGB-only (9 to 12 values)
<dd>list(rr,rg,rb, gr,gg,gb, br,bg,bb, cr,cg,cb)
<dt>RGBA (16 to 20 values)
<dd>list(rr,rg,rb,ra, gr,gg,gb,ga, br,bg,bb,ba, ar,ag,ab,aa, cr,cg,cb,ca)
<dt>Row-by-row (3 to 5 rgb() values)
<dd>list(red_row, green_row, blue_row, alpha_row, constant_row)
</dl>

<p>Reading a color var that has been set to a matrix will return the full
20-item list, where every 4 items represent a row in the matrix (without the
fifth column).

<p>In the MapColors() icon proc, the values are sent as arguments, not as a
list.

<hr>

<a name=/{notes}/EFFECTS_LAYER>
<h2>EFFECTS_LAYER</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/layer>layer var (atom)</a>
<dd><a href=#/atom/var/plane>plane var (atom)</a>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
<dd><a href=#/{notes}/BACKGROUND_LAYER>BACKGROUND_LAYER</a>
<dd><a href=#/{notes}/TOPDOWN_LAYER>TOPDOWN_LAYER</a>
</dl>

<p>This is mostly deprecated.  Anegative value for plane is the preferred way
to do show objects in the foreground.  It can still be used however when you
want to rearrange objects in the same plane when using PLANE_MASTER for visual
effects (see <a href=#/atom/var/appearance_flags>appearance_flags</a>).

<p>EFFECTS_LAYER is a special high value that can be added to the regular
layer of any atom.

<p>The purpose of this value is to make an atom appear above any regular
atoms. For instance, in an isometric map if you want to display a character's
name below them, it does not make much sense to have nearer objects cover up
that name, so you can tell the name overlay to use EFFECTS_LAYER + MOB_LAYER
and it will show up on top of all the normal icons on the map.

<p>When using this special layer, it should be added to the layer an atom
normally uses. For instance an obj should have a layer of EFFECTS_LAYER +
OBJ_LAYER.

<p>This can be mixed with TOPDOWN_LAYER. Anything in TOPDOWN_LAYER will
display on top of EFFECTS_LAYER, and TOPDOWN_LAYER + EFFECTS_LAYER will be
above both.

<p>This can also be mixed with BACKGROUND_LAYER, which takes priority over
everything else.

<p>Images or overlays with FLOAT_LAYER can be left alone. They will
automatically have the same layer as whatever atom they are attached to.

<hr>

<a name=/{notes}/gliding toc="Gliding">
<h2>Gliding</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
<dd><a href=#/atom/movable/var/animate_movement>animate_movement var (movable atom)</a>
<dd><a href=#/atom/var/appearance_flags>appearance_flags var (atom)</a>
<dd><a href=#/atom/movable/var/glide_size>glide_size var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_x>bound_x var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_y>bound_y var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_width>bound_width var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_height>bound_height var (movable atom)</a>
<dd><a href=#/atom/movable/var/step_size>step_size var (movable atom)</a>
<dd><a href=#/atom/movable/var/step_x>step_x var (movable atom)</a>
<dd><a href=#/atom/movable/var/step_y>step_y var (movable atom)</a>
<dd><a href=#/client/var/fps>fps var (client)</a>
</dl>

<p>Gliding is a "glitz" effect applied by BYOND to cover up the visual sins
of tile-based movement, by making objects and the map appear to move smoothly
from one tile to another instead of immediately jumping. Because pixel
movement is now an option, it is usually preferred over gliding.

<p>To control the gliding speed of an atom, set <code>glide_size</code> to the
value of your choice. If this is not set, the client will attempt to adjust
the speed manually.  <code>glide_size</code> is measured in server ticks, so
if <code>client.fps</code> is set to a value greater than <code>world.fps</code>,
it will be scaled appropriately.

<p>The animate_movement var can be used to control the way in which an object
glides, or suppress gliding altogether.

<p>By using the LONG_GLIDE flag in appearance_flags, a diagonal glide will
take just as long as a cardinal-direction glide by moving a full glide_size
pixels in the dominant X or Y direction. Otherwise, gliding tries to move by
that many pixels in strict Euclidean distance (a straight line) and diagonal
glides take longer.

<p>Because gliding interferes with pixel movement, gliding is turned off if
you set any of the bound or step vars for an atom to a non-default value.

<hr>

<a name=/{notes}/HUD toc="HUD / screen objects">
<h2>HUD / screen objects</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/movable/var/screen_loc>screen_loc var (movable atoms)</a>
<dd><a href=#/client/var/screen>screen var (client)</a>
<dd><a href=#/client/var/view>view var (client)</a>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
<dd><a href=#/world/var/icon_size>icon_size var (world)</a>
<dd><a href=#/atom/var/layer>layer var (atom)</a>
<dd><a href=#/image>image objects</a>
</dl>

<p>HUD stands for Heads-Up Display, and refers to any atoms that appear on
the screen but don't move when the player moves. Any movable atom can be
added to the HUD by setting its screen_loc var, and adding it to client.screen
for each user who is supposed to see it. These atoms are called screen objects.
This can be used to display a character's vital stats, scores, etc.

<p>If you want to have something like a health meter or name attached to a
moving atom, use overlays or /image objects instead. An /image object is
similar to a screen object in that it can be shown to only certain players
instead of being shown to everyone.

<p>The size of the screen depends on client.view (or world.view),
world.map_format, and world.icon_size. In a normal TOPDOWN_MAP map format,
client.view is the same as the screen size. In other map formats the screen
might be a different size.

<p>The screen_loc var can be set to a value like "1,1" (the southwest tile of
the screen), "4,NORTH" (fourth tile from the west, along the north side of the
screen), "SOUTHEAST", and so on. Pixel offsets for screen objects can be set
using a colon followed by the pixel position. That is, "1:8,2:-8" means the
object will be on the left-hand side of the screen, one tile up from the
bottom, and then shifted 8 pixels to the rigth and 8 down.

<p>screen_loc can also be used to stretch the bounds of the HUD. A screen_loc
of 0,0 will cause the atom to appear to the southwest of the southwest-most
tile on the visible map, outside of the regular map bounds. Using HUDs in this
way you can provide a nice decorative "frame" for your map.

<p>You can use HUDs in other map controls as well, by preceding screen_loc with
the name of the map you will use followed by a colon. For instance,
screen_loc="map2:1,1" will show an icon in the southwest corner of the map2
control. The actual size of a secondary HUD is based on how far out the icons
in it extend in any direction. If you have one icon at "map2:1,1" and another
at "map2:4,3", then that HUD will be four tiles wide and three high.

<hr>

<a name=/{notes}/isometric toc="Isometric maps">
<h2>Isometric maps</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
<dd><a href=#/world/var/icon_size>icon_size var (world)</a>
<dd><a href=#/client/var/dir>dir var (client)</a>
<dd><a href=#/atom/var/pixel_w>pixel_w var (atom)</a>
<dd><a href=#/atom/var/pixel_z>pixel_z var (atom)</a>
<dd><a href=#/atom/movable/var/screen_loc>screen_loc var (movable atoms)</a>
<dd><a href=#/{notes}/big-icons>Big icons</a>
<dd><a href=#/{notes}/side>Side-view maps</a>
<dd><a href=#/{notes}/topdown>Topdown maps</a>
<dd><a href=#/{notes}/HUD>HUD</a>
<dd><a href=#/{notes}/BACKGROUND_LAYER>BACKGROUND_LAYER</a>
<dd><a href=#/{notes}/EFFECTS_LAYER>EFFECTS_LAYER</a>
<dd><a href=#/{notes}/topdown_layer>TOPDOWN_LAYER</a>
</dl>

<p>Isometric projection is a form of pseudo-3D in which the 2D icons used by
BYOND can be arranged in a way to give the appearance of three dimensions. If
you look at a map top-down, each tile on the map is a square. The map is
rotated 45&deg; clockwise and then tilted at an angle (30&deg;) so that each
square now looks like a foreshortened diamond from the viewer's perspective.
What was once north now points to the northeast end of the viewer's screen;
what was once east now points southeast to the viewer. Tiles that are more to
the south or east are "nearer" to the viewer, and tiles that are north or west
are "farther". The actual direction the map faces can be changed by using
client.dir.

<div class="figure">
<img src="data:image/png;charset=utf-8;base64,iVBORw0KGgoAAAANSUhEUgAAANIAAAB4CAAAAACidfMWAAAGcklEQVR4XtzGoQ2AMBQE0BO/vpuwQi2qsiEoBsHWd4cuwQisg0OQ4ycsAOYETz3wd0CBmvIydYoYBMb1AgpU+MIxuP158578ZosIM1XsbubuY6qs4gCO/y4koFSmU7IxHdWYY8iI0cocLE3KJEsqyLDYBYKKEWkEEqSc+yAvYjfCjBmBehm+oZjELGeZL9HKuZI9KXPWLKpZrZxComR4721jc7/F5d77POece875/el2xj7z+sj3ueccI2ynDgC5J0MAAH7TAVxgZg6RK9qq8CYQNUFgdPpqgWaOJBe/3vtqqmOyMJKJf0u16XNMg46RCyTdArB5Cij4twQjLzhNgnoeKij4LsMCAChSiPQowIlGU6CvHs7PO70Mf4BypIVPA1SeMw46vijb2rccQQqShpumwtV8t0HQidSs5WeeDwZQmeS8vRHgSKsh0LdLMjPOWBGkKAkg6zGA0vP+F/Q+kZ52Nmfso1TXFXyIQ3Ps4GBhoh+Qbuut2DthLPNnGIA2sCpHirTnw0cXfYJO2b4p7wjxBPUDQBSilCFBXsch6PEB6tO+fmNH6PggQJRKJGiJG/IOOqN9WdbuHYQopUhRdUXeQGerjpY6wnyCEKUQCQp3j//B+6Hq85LWiX5BiFKHZNkcP+wJOrf2YHHzJC8g4SiLG1jnx+oDK18JNwbC6QerqqT+6v0rim42BUKUiqRfarqKVtxCAUKUWqRfaz8sXHkrFQhRKpHO1+0ueO02ahCiVCH9XrfrpeIpjCBEySf9Ub89r2QqMwhRskl/1rfnlkyjAAlBUbxt/Wt9m7VvukdUIICKpEO8LNIF+5as0xHj9VA/3AMDVKCjkA39mB5iP3gX7a3Plc3wkg+IogDhx08o6VJD87Pld3gBIYoOhChxpIF3Nj1THukDhCgaEKJEkf5ubHqqYqYfEKJoQIgSQbq8YWPam7MMgBBFA0JUoElDGzcsWR1lEIQoGhCiAkm68l7j4tV3mQAhigaEqECRrjY1LFpzt0kQouhAiOJPGt5kX1gZTQFCFA0IUbxJ/7z/1vzK2ZQgRNGAEMWTdO2D+iQSwwBCFA0IUbxI11rXPUBiGUGIogMhip3075a6e21xHECIQhANipU0srU2wRbPt4cA5rP1FEtcXHfUxO1L4N1DaTAgpKeQhKD26pjOxAD0EI+eookL57bqaNt93HtIVE95kpw7q+7U5nLvIcE9hSRw7aqaqc3j3kOiewpJrj3aDC2Zew+J7ikkuTu1adqD3HtIdE8hyb3PNrlqAfceEt5TSOqyhWsp3HtIeE8hqdsWqj3CvYck9pQlMdi2mHsPSe0pS08S9x6S3FMWN+8ektZTSOLbQxJ7Ckmce0h+TyGJvYcU6SmMC8aeSZO73ltc6Kw9JG098SAhSmYPIYoShCQ6FIIk9xTx/1+tztpDQtcTY78Q6aw9JGw9Mf5rq87aQ0LWE3NxoQvoIbb1xHwC6gJ6iH49oQt1XUAP0a0n9K9TdA49xH89YXrphSgESe4pwvRqElEIktxThM8LZF1WDyEKQWZI+JpfS/RAyeohRCHIDAm/jNESxqLaJPcQgJXzV2aYHpT5kAbAtJ7w/WJTfk8Rvl8/y+8pwnmTgPSeIvy3csjtKSJgw43QniICtkUJ7SkiYPOa0J4iArYYCu0pImYjqLieIuK264rpKSJ3UzX/niJyt77z7ymixgEFnWcPiSThMZKyiAD0FIJEkvCwz6rp/HvKKv9IFt+eImodnGPvKaLW8Ub2niJqHUJl7ymi3lFhtp4iah7opu8pou6xewoUgpS/HAFRNCD5JLzConCSQRSCVCXhRSMFEw2gEKQyCa+DeTnMHwpB8kmNjhuA7lk+Lu15MdQ3CkHySaX2G4Dvo31erZTnBSUAhNui+E3s7lO29eW5If8nxY+iEKQSyR4LABDpCxW3V7etq8iZMA4KQYEet7EpAYAv3Ibm5ONRLSMef+pwuAVNEHCfhO7Ortlbr49ZYLVKvPKPfRL379wT0+akAEh54qV+bIx1nPxUmRks8WJG/jP3oKMtdodLJon/zPuspXVOB6JUvGuy634ACDOBSj58jKwdvTD4Eia9Yg9xijmcFLfX5X6y2y1sgiDAs6Cn4e2Edz/JHlTygzc0mgphYSZRKSmfLrvmKtymIil1FFBRA2Yn4jKMbM9YKuyJJ2AOJC/NyRwS98ETMOXlIHD+A3oxNU80orubAAAAAElFTkSuQmCC">
</div>

<p>It is important to remember that this is an illusion of 3D, not real 3D.

<p>To use isometric mapping, set world.map_format to ISOMETRIC_MAP. You should
set world.icon_size so the tile width is a multiple of 4 pixels. The width of
the tile is highly important. The height of your tiles should be at least half
that value. BYOND uses a 2:1 isometric format, meaning that the diamond base of
each tile is half as high as its width. For example if you have a 64x64 tile
size, every diamond in the map will be 64 pixels wide by 32 high, and you have
an extra 32 pixels at the top of your icon for vertical projections like
buildings. If you set the tile size to 64x80, the base is still a 64x32 diamond
and you have 48 pixels left over for vertical structures.

<p>In this mode atom.pixel_x and atom.pixel_y will offset icons along the
"ground". To adjust vertical position, use the pixel_z var. Higher values of
pixel_z put an atom higher above the ground level. The pixel_w var will
adjust horizontal position.

<h3>Layers</h3>

<p>The atom.layer var behaves differently in isometric mode. Because some tiles
are nearer to the viewer than others, the tiles that are farther back need to
be drawn first so they are behind any tiles that should go in front of them. So
in isometric mode, the back row of tiles (a diagonal line of them) is drawn
first, followed by the next row forward, and so on. The layer var only matters
within the confines of a given tile, so within a single tile OBJ_LAYER still
gets drawn above TURF_LAYER.

<p>Pixel offsets, which can be set by the atom.pixel_x or atom.pixel_y vars, or
change while an atom glides from one tile to another, have an impact on
layering as well. When an atom straddles two tiles, it is considered to be part
of the "nearer" tile for layering purposes.

<p>Using icons wider than the regular tile size can have an impact on layering
as well. See <a href=#/{notes}/big-icons>Big icons</a> for more information.

<p>Because of the order in which icons are drawn, you may want to limit the
ability of an atom to cut diagonally around corners. While moving northeast
behind a dense wall, for instance, a mob might temporarily appear in front of
the wall because its pixel offsets (from gliding) temporarily put it on the
same tile as the wall. If you do not want to limit corner-cutting, a simple
workaround for this case is to give the wall a higher layer than the mob.

<p>Screen objects (in client.screen) are always drawn on top of all isometric
tiles.

<p>Since it may be desirable in some games to use a topdown map for some
situations (like a special battle map), you can add TOPDOWN_LAYER to any atom's
layer--e.g., TOPDOWN_LAYER+TURF_LAYER--to make it appear in topdown mode.
Topdown and isometric tiles really aren't meant to be mixed, but if they do mix
you'll see topdown tiles always display above isometric tiles, just like screen
objects do. The best way to use this is to apply TOPDOWN_LAYER to every tile in
a certain part of the map that the players can't walk to.

<p>If you want to use an overlay that should not be covered by other "nearer"
icons on the map, such as a name or health meter, add EFFECTS_LAYER to the
overlay's layer. Icons with EFFECTS_LAYER will draw above regular icons. Then
objects with TOPDOWN_LAYER will draw on top of everything else.

<h3>Screen size</h3>

<p>In this mode, world.view or client.view is used to define the minimum number
of map tiles you will see, <i>not</i> the screen/HUD size which is calculated
from client.view. Extra map tiles are shown to fill out the screen size. HUD
objects use screen coordinates, so 1,1 is still the lower left.

<p>The actual HUD size is always a full number of tiles, whose size is defined
by world.icon_size. If you have a tile size of 64x64, and world.view=6 (a 13x13
map), a full 13x13 diamond of map tiles will be shown. The width of this
diamond is 13 tiles. The height is only half that, plus whatever vertical space
is needed to show the icons in that area. Then everything is rounded up to a
full tile size, so the result is a 13x7-tile screen. This is the formula you
need if you want to calculate the screen size:

<xmp>
pixel_width = round(icon_width * (view_width + view_height) / 2)
pixel_height = round(icon_width * (view_width + view_height - 2) / 4) + icon_height

screen_width = round((pixel_width + icon_width - 1) / icon_width)
screen_height = round((pixel_height + icon_height - 1) / icon_height)
</xmp>

<p>If you use TOPDOWN_LAYER, any topdown sections of the map will be limited to
this same view.

<hr>

<a name=/{notes}/pixel-movement toc="Pixel movement">
<h2>Pixel movement</h2>

<dl><dt><b>See also:</b>
<dd><i>Bounding boxes</i>
<dd><a href=#/atom/movable/var/bound_x>bound_x var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_y>bound_y var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_width>bound_width var (movable atom)</a>
<dd><a href=#/atom/movable/var/bound_height>bound_height var (movable atom)</a>
<dd><i>Speed and position</i>
<dd><a href=#/atom/movable/var/step_size>step_size var (movable atom)</a>
<dd><a href=#/atom/movable/var/step_x>step_x var (movable atom)</a>
<dd><a href=#/atom/movable/var/step_y>step_y var (movable atom)</a>
<dd><a href=#/atom/movable/var/locs>locs list var (movable atom)</a>
<dd><a href=#/atom/var/contents>contents list var (atom)</a>
<dd><a href=#/world/var/fps>fps var (world)</a>
<dd><i>Movement</i>
<dd><a href=#/atom/movable/proc/Move>Move proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Cross>Cross proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Crossed>Crossed proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Uncross>Uncross proc (movable atom)</a>
<dd><a href=#/atom/movable/proc/Uncrossed>Uncrossed proc (movable atom)</a>
<dd><i>Other topics</i>
<dd><a href=#/proc/bounds>bounds proc</a>
<dd><a href=#/proc/bounds_dist>bounds_dist proc</a>
<dd><a href=#/{notes}/gliding>Gliding</a>
</dl>

<p>Pixel movement is a concept that allows atoms to escape the constraints of
BYOND's historically tile-based movement, and move in smaller steps. In the
past this had to be done with soft code, but that was sometimes inconvenient
and it did not perform as well in projects with many objects moving.

<p>The key to understanding pixel movement is to use the bound and step vars.
You use the bound family of vars to define a bounding box for a movable atom,
instead of just making it one full tile in size. The step vars can give it a
movement speed and offset it from the corner of the tile it's standing on.

<ul><li>bound_x: The left edge of the bounding box</li>
<li>bound_y: The bottom edge of the bounding box</li>
<li>bound_width: Width of the bounding box</li>
<li>bound_height: Height of the bounding box</li>
<li>step_size: default movement speed</li>
<li>step_x: x offset from the corner of loc</li>
<li>step_y: y offset from the corner of loc</li></ul>

<p>Those are for movable atoms only; they do not apply to turfs.

<h3>Bounding boxes</h3>

<div class="figure">
<img src="data:image/png;charset=utf-8;base64,iVBORw0KGgoAAAANSUhEUgAAAVQAAACOCAYAAABuQPBIAAAckElEQVR42uydB0xUWxrH52XBt09BUdT3XMHexYoKKmVWVkWfKCAsBhRFioot4irNh/jWGiNrWwTfuruWxK7RXUvM7tpLYouxl2jsJfbe/8v/JNd3E8YZQRiYme+f/ONcptx7jzm/+c73nXPGgBLW69ev0apVK5SVTp06hfDwcHyN5syZg23btsGUpk2bhqVLl5p7zq7bb9euXUhMTERRdO7cOYwcORKWdOzYMURFRUEkslWVOFBfvXqFKlWqoKx09OhRdO7cGV+jPXv24PLlyzCl8ePHY8GCBaDOnDmDnJycQs/Zc/vxi6Zfv34oih4+fIjNmzfDkg4ePIjAwECY0tOnT5GSkgKRyGGBymjr7du3MKV79+7h3bt3KKqePXsGU3rx4gVevnypA0LJ6sGDB/j48SP00Ny4cSMjKlNAJQDssf00oJq9R/6dbWVOPNfz589NAdXkZ1+/fh0NGzaESOSQQOXwt0uXLmjWrBlmzZoFTVu2bEHt2rXZadXrpk+f/glYtWrV0nfwT8fnz59Hy5YtMXToUPj5+anHhw4dAkWoDB48WL22bdu2iImJ+SwQ3rx5g6pVq+LJkyeg8vLy1Odp6tixo4pM4+PjsXz5cm24qs7Xrl07NG/eHD179lTQ3L59O+rVqwc3Nze0adMGV65cUUAdNWqUum8vLy8Fng8fPthN+2lA7d69O+9Nvc7b2xsXLlz4BOuwsDC2hzrPkiVLQB0+fBhdu3YFRdAmJSWhRo0a6r0DBw7k9WhA5WfyS0q9vnXr1jhx4gSuXbuGFi1aoEKFCvxs1QYikcMA1WAwIDc3FxTh5eHhgZs3b+L+/fsKQMePH9eiLHZkdiSLQOBn7tu3D1R+fj6GDx8OavHixejWrZuKeCgCzRwQIiMjVWRJ9e3bl52W18hhqXpM6YFqNBoxf/58UIyoPD09zUaoBC8jS4LD19cXR44csav2I1CdnJxw9epVUJmZmZg5cyaoCRMmYOzYsVp0zYhSRdh6oK5atQqdOnVS8KUyMjL0QOV1qjwuNXv2bKSlpUmEKnJsoDo7O+uHlixisOOqyMLHxwc6MVphx7EIhLp160Jf5Gjfvj2oiIgILFq0CJr2799vFggrVqxAcnKygmNwcDA7tALj2rVrkZ6ergcqocB7UbDVxOKKOaBOnTpVf8xrs6v2I1D5JaM/7t+/PyhGjwMGDCBUaRXB7969Ww9U1bYzZsyAppMnT+qBqqJkSjsOCgoSoIocG6gVK1bE+/fvoSk0NFQNrzds2MChYCEgsKpOgHA4runu3bt6IOgr34yOtGMOGQk/fQc3CwTCkUN3XsvcuXMJEBWtDRs2DAcOHNADVd1LtWrVFJw0DRo06EtyqFr0xmMbbj/LRamdO3dqx/xMRvP8m2ZG0Xqgsp0ZfesBTqCaKkoxEuexAFUkQ/7169eDYv6LUGJUdOvWLbi4uGhDOnY2lQ/UhrBazoyaN2/eFwGBkWVISAiHloQQIyRLRSkOcRmdMu/J9zDq43uY7yw05GdOcNmyZdr1cshNSGowYT7RElDtpP0sA5VfTCNGjGC6Q5sFUSiHyvez/Rn9s70TEhK+CKiPHz9WeVeRyOGA6urqiiFDhrCoogeQ0urVq1G9enU+x39VPk8TIdakSRPV+SZOnGgRCFpek52YRQvmL6dMmWIRqIxM+VpNLMTExcVBkx6ozIESAISuv7+/PkIlhDhE5b0QzmaAag/tZxmod+7cUeeuX78+AgICEBsbWwioLAwyHcBRAotSkyZNYqrAIlCp6OhodOjQAVu3boVI5AhA1YsFFVNTexjBcEhqsgLOv3GIXVTxPXxvKYnTeMzdp7SfTo8ePbL4WSyCMSJmbrhPnz5FahPRr0pNTUXv3r0LeeHChfyS57/yvJWeZ2rOADsVix2c4qQ3C1Cism2/S5cuMcpmuoKT/VWkvGbNGoiKJXZkjhLE5cD8vzBAJLKimBMeM2YM0yeMTNU0KpEAVYAqEokEqGLNHP7bD1A5hBQVf1mtyCbFTuzwICsnZk7VPoDKaURcwcSVRKKi727VqFEjtRRVZHNiJ3Z4kEmEWgriEkVW2URFE1d2cQmuSCJUseRQKW1OKNeIq2WUIsvS5qO6u7urDWFEkkMVC1ALTcmpWbMmTp8+DZFlcQ1+dnY2RAJUsQDVpLhjPpdgMjco+rx27NjBFU1qZZZIgCoup0DNNhrK3K1qGuDjwcfiz6VHuM/qpk2bIDKv8t4/GrsbMKStuJi2DaDu/MfkMvWW3DTUquGGmeOieeyo/ixQuWF1r169ILKs8t4/fFs3xl9SB4uLbgLVClV+OwAqvTAzHu5urlg/d7wAVacbN26oQtTFixchsn2gjh3Y2+HBWE6Ayils9gtUOi7s9+jg1RD/+7sAVRO35+MuWCL7AOrK2WMdHowSoVrHBSDNQuumdZE8oIcAFVD/6XXq1FE7S4kkQnV0Sw61GF49ZxyqVq6ExdnDHBqo3AaQGzmvW7cOIsmhigWoxQfLyEh4/uCObXkZDgvUnJwc9esCIgGqWID61f4xoD3tkEC9ffu22t3/7NmzEAlQxQLUrzWjU0apjFYdDqj82Rb+JIpIgCoWoJaUmUdlPpV5VYcB6t69e/m7/upXUUUCVLFU+UvSrPiz8s8ZAHYP1KxAg/oBvJUrV0IkVX6xzEMtaXNOKuemco6q3QO1d2MDjEYjRDIPVSwRammZq6e4ioqrqewWphvnT0AlZ4PafFskEapYcqilaa7z53p/rvu3S6D28m+Hzh7yk2GSQxULUK3k8O4+CPLxsjuY5v6UAHc3F6T7CVAFqGIBqpW845dJaOD5PdITQvGfJT8hpo+/zU/+Z7GtSb1aSE8MQ7ZRgCpAFQtQreh/TktGZZfv4PGDOwwGA5bPHG3TQE0Z3AetGtfhYwGqAFUsQLWuU+P7wdnpN/jmGwMqffctG9pmYbppwUS4Va6Ev/08XIAqQBVLld+6ZqNWLIBoBWcnFZ06FYB10rBwmwVqiNEbYUGd+FiAKlV+scxDtb6352dgdHQw3FwrKqhGBXexSZjmT05CtSou+NdfUwWoMg9VLBFq2fq/S7Lwp7gQpCWE2mAhajKaN6iNiUP78liAKhFqqdsQmF2eLTlUcbFNkBKoBKsAVXKoVgNq9i6URwtQxcU2h/gc6nPIX3AsQBWgClAFqOWwWDVnQqwtXCuLUCxG8bEAVYAqQBWglrz/nZuGzKRwjIjqgcSIILURyqjoYC435TxTTuL/7Ht/maK2+FNr/VfMMj8ndU3OOMxKiVHniQs1Ij68GxIKzpc1IgJb89JL+z45PYrTpDhdSoAqQBWgClBL1ouyEtGlXVM1n9Tfuxn+GNwZ0T/6IbZvACM5tcvU9+5V8G0FJzSt9zvu4K9gODk5UkFwSKiRgOIm1CxOqaF0UuQfMHXMAPx5dBS3/lPRoFdjT55Dgde7RQNE9PBFbL9ADAzxR0zB+fy9m8O10m/h174Zr6m07pcT+DmRn48FqAJUAeqvQJUq///ZO/enqMowji8XRfOCiIAYCAMpisZIcgnUuAmERhIEQYgmqTCi5CVIQStN7KY4o046GjX2Q9NMzuQ4MU1j07/2tN9Ti7ssLAsstMt+fnjmXHjPe84Zlg/vPpfvM1/78+GwbUpNsjOdDTOuDsfvX7K7Q93Wf7jBgWFFUb5VFudba33ZRFK8TGNaakvtjaLtGqOxzvyjg0ft6d2BgPfQM2hsekqSOzVrONTvq9JSlZiq1BSgEuUHqL5AJQ91vna8pdqqSnaEnY9Tz9TdHFLtVSlkSfxEIig6BqjkoQJUVqihNYmcjHlWl+FjeiY9W0jnbK17XfJ82geoxgoVoOJDXYiKp2DGRfyz/Xj9lKq6JCANUAEqPlSAuiAW7pUbgqpWqnJNyN875/fctS1bvl/tA1SAClAB6oJYuP+CPV//5VNV8GxO0f8rvS2Wm5mmMlmAClABKkCNaqB6TNF/pXfN6v2UNZCStNbuDB3TMUAFqAAVoAJUDxyVx/r7LPpZtR/YY3XlBdoHqAAVoBLlB6hepsIDVXMF9W6Pb/RZ4uqX1K0VoAJUovzkoQLUSc+rKi5VaQX1bkU7cuxUR732ASpAJQ+VFSpAnfS8KomVzsCM73W1r82yX06R/gBABaisUPGhAtQpgCp9AYm2zJi/mpqc6OlzBVABKj5UgApQpwCqxFqkgBXwnSS2Ul26U/sAFaACVIAKUKcBqpSvJCc47ftIOlDtrX8dPQ9QASpABagANQBQJSMobdZp36e04BXrad2vfYAKUAEqQAWo0wBV8oHSZJ020DTS326b0zfY8++vAFSAClCJ8gPUAECVzqoErv2i+ddOtzl1/ukp6+zbj7t0HqACVKL85KEC1ABAlbiJugX4nFM3gJgYl6WuT7Tinbk6B1ABKnmorFAB6gxAlfK/X1K//KVxsbHmcrksYVm8k/j/x4MhgApQWaHiQwWoAYCqdirqY+XXcUAwlS13A1VtV57cvgBQlyBQXa6Q/I1oHnyoABWgqn+VmgJ6n3urYrf+QBzf6sPPT/KVf+kCVboM6pg7n9+trtc8ABWgAlQ1A1SHVe9zl3uapXfqOQaoSxio+8telcvHT4FMn4Gjhyqsp61Wmrfa6ljnJzee1PWaB6ACVIDq6af/6GrP5PcAqFEAVImLZ2xMtoK8LPnT/2s7vlKuIAegW7I2WuH2bG11rPP6ucZpvK7T9ZoHoAJUgOo29f5XX3/9YgFqFAallGM88lGH9XXU2+XeFu8VqP7Ryv2jrfcKVuM0XtfpevJQifIDVI9dPN5kyevW2K2BIwCVKP9UpclE+clDBajBJvavT1yten2+8gPUqUxlyeShskIFqMEAtaW21E7+W6cPUAEqeaj4UAHqfICqHNPr/e0AFaBSyw9QAWooEvu/OPMeQAWoU9qtgS4VfgBUgApQgyw9Ve0+QAWofvbLzbMWHxcrgRyAClABarB9+RsrdwNUgOpj0m7YlJpkMS6XxcfHqRoKoAJUgDoTUEcHj9rOLZkAFaBO2N8/OKLiWp169BzUcwygEuUHqDMB9endAVu1MgGgAlSflje1ZQWWkZbsADUmJkZdHYjyk4cKUINI7FeVlL7SAVSA6mP6Q8/PzdBnQyLj6nwbrnmo4WqsUKMRqLvzc+zr850AFaD62NmuA9awr3C2eaiYr+FDjTKgekSmASpA9bGmmuLZfC7kQ416MAJUgGpHDlXYsaZKgApQfUwqU1+d6wSoABWgzgaohxv32YfN1QAVoHqbNB6UiwpQAeqLD4zq1Me/u7gYINV9dL+IA2rnwb12/N0agApQJ+zZvUFbkbBMKVQAFaC++MCUF+bZuSMHFwOouo/uF2lAlViw2qAAVIDqo0K2NTvdvQ9QQ2iRH+V/8NkJ56vLs3ufBPwwKB9TIrq/3RnwPq9jndfPA12v+XUf3S+igCqx4DWrVmgLUAHqhF34oNHqygu0T5Q/tBb5eaiKVmZt2mCD3W/bz9/0K59OOXNO36R3akpUYudAJTczTVtHMOSvsSvaep/XOI3XdfItaR7Np3k1v+4TkaWne1/bRmI/QPXL/DgxOzeQ/qaiHowBbGnlod4c6LI9hXmO0EPC8mVOH6XyXVvtzPtv2k9fnp4Y9/zRZScvc3P6Bm117PmZxmm8rtP1mkfzaV7NH1FBqbFrvVZVssP9/EnqBwRQAaqfSv9IfzsrVHyo84/yP7l9Xo3ItJ1rlD+sTSvrnMw0626ucu8P65kBKkD1sZSktSpBxYcKUEOTNvX4Rt9CQ0YZAQpiye+q4//LACpA9bHx+5ckiOKO8H8KUAFqSIC6WGlWygxQMEv+13/YO9OYKs4oDFOWmgoKChQEA1WwrKIie5UWLLWGiixKXIK2IMgmuKBRqU1rQ5SoiURExBprbKL9YZOaYlO0P9yiJsZE4w+jxmjUuESNxn095Z10brgE3O7Mnbu8b/Llzs1FZHK/75kzc95zPgKVsgmgtiyfjbwBjglUAtVOgGruEEBSC89hCVTKcKAuLpkk45JjCVQCVTug/lRVaE3AwSmA5BaBShkO1KkT0vB8nUBlll87oGKfeg93d9WXqveA/QqOAQKVMhyoKSOGIaDAMbP89KFaDlQkiTzc3ZTGunGfhqjld3oOZN5hwyJQKcOBigv7rw1VOKYPlRGqxUBFKSZgim7lAKvede7qZIS3lUCljAQqLuyY8yhsYYTKZ6iWAhUe1IXi5uoKoJq2fsD+On/p22AF1VcoGCBQKUOB2vZjmYQG+eOYz1AJVMuBipr97SurpX3jEmxSpl6p9R4oaUUVFoFKGQrUZWV5KLkmUAlU7W1TSEz9rvaD1HegTwBKWwlUykigopUjGo4TqASq9kCNGhoszfXFesMGUTGar9DYTxkNVFj30MqRQCVQtQdqeoLufUIx0B4QlSkEKmU4UAcHDJQtP1cQqMzyaw/UgqxkvTevU3uuIkJFZysClTIMqB2d88/d3Q2veM8sP32omgIVMEVfSGsAB4kAtAtEhysClTICqIhMEaGq7+lDZYSqKVBxu4/bfmsAB24C9GBF20B0uiJQKWsDFfNdLX9mhMpnqJoDFQkpJKYYoRKozgBUZPeR5ccxn6ESqJoDFZYpWKcMfYa6ZHaufJeXIb+sKJd/t/xAoFJ6rQ9c1OFDJVAJVF2Aittw1dxvWJa/etrXKIFVGv56dI7IocGytDSPQKW0Xh+okEKlFIFKoOoAVHNzv2E+VPRKdXdzA1RRCotnrNggkECltFwfCBpQw49afgKVQNUNqKq539BKqYhPglSgwnXAW35K6/WB7lKWto/E7rlITCHbj1cAtvvg5718PszXBRBEdh6WJ7zifdfxTp9v3brVJoGqmvsNreWfO32CEj001E5TOvtPGZ/a2VKQQKU0Wx/of4o+qDh26oEdgCeMGalsYlmSn2nP60M3oGpl7jes2xQeOai7B/y5frESNY//bARu0whUSov1gQ796NTv1DBF0jfQz0eKJqbLhu9LsCMwgaoxUFVzv031Q/27dZkkxAxVdkz9p62eQKUsXR/YQwp7STl9hPpVWpzMKcxS3xOoGgNVNffbXMd+WKy+SIqRuIhQ9GolUClL1gdcJtjt1KlhCrfNsNBAAlVHoKrmfpvcUwr7pk/KSJDwkED5o6mOQKXeZ31gHsGWh/34nRKk21fNlYTYMCXxOyrqE9z6E6g6AVU199v0rqczc9Il+OOBnVCuJVCpd14fvzXOFf8B/Z3+dp8RqgVA1dbcb/y+/HAI+A3ohwYXBCr1TuujoWYqIjSngCZKuyunjUdxDJ+hagtU48397S1LZP7MbBno7SW54xIt/n31Zfni06+vrF9WTKBSb70+SiePUxOvDjlgnP/m83gEHLAf4tYeUGWWX1ugGm/uL5vyJTL12LZas9+5av508fbqi1cClXqr9YGobOG3Ex0WqFtWlMtHfT4ESDEAVUSq9KG+x4TRZET7u8jkaBzbxyge5SKeHi6SH2UzfxOBaqNAxQjqhzmDY8cdeZEu8sH/QO3fx+b+PgOAaqBqa2tlzZo1Yk86deqUBAcHS1NTk1BUb3r16pV4enrK7du3xVF18OBBCQwMlG3btomXl5eUlpaKDcp5gAqYzps3T+xNFy5ckPDwcFm+fLlQVE+6ePGiBAQEODxM8QqdPHkSzUMIVCO1c+dOKSgoEHvU9evXZeTIkVJRUSEvX74UiuqqPXv2SEZGhuPD1FwEqpE6fPiwJCcni73q7t27kp6eLoWFhfL06VOhqK53X1VVVYQpgWo9Xbp0SYKCgsSe9fjxY8nJyZGsrCx58OCBUBRUXFwsGzZsIEwJVOvp+fPn4uHhobzas/D3z5o1S4m2b926JRSVkpKCZ4qEKYFqVSFCRaTqEFndBQsWSFRUlFy+fFko55a3t7fcuHGDMCVQrStEdXiW6ihauXKlhIaGypkzZ4RyTl25ckV8fX0JUwLV+kKWH9l+R9LmzZuVSXj8+HGhnE8dHR0yduxYwpRANcbcv27dOnE07dq1S/z8/JTHGZRzaePGjTJnzhyxY2HeEqb2CFQkdBxV586dE8op5Qg2OgYD1gIqJsvw4cPFKJ0+fVry8/OlN/F8KYqyG6A+efJEyWIapRMnTkhqaqr0Jp4vZUXBwI+LLs+DQLUcMDh+9uyZ9KSbN2++1y39/fv3pSc9fPhQHj169EbA8HwpPYXv68WLF2YWKcyLrsIcwXfXg/Bv8RnPg0A1B0xDQ4OkpaVJZGSkNDY2iqr29nZ0ZAIETD8H3blzRwYNGiSq8GWo78+ePSvR0dFKhcmYMWMkJiZGjh49amacx8+ifn7GjBmvBUxeXp60trYKtG/fPpSHwifqkOeLv83f31+uXbtmdv67d+8WSluhZ0Nubi6q4mCNU6K5pKQkcXV1lbi4OFMHsrVr10pISIgy7yorK01RH+YIErCJiYnwK8O3rECpJ6EoIDY2Fp8rIz4+Xo4dO2Z357F06VKpr68XVfv375fMzEwCtfsiRv/DlpYWge7duyeDBw+Wq1evKpVCPj4+iKpMURvAcOTIkTcCBr/z0KFDAm3atEnKy8sFamtrw5dguhpWV1cDMK/1AaIbFFqnjR49GskhPc4X/49NnG9NTY3JKYFzHjJkiDLBKW21d+9eyc7OVqHUY2SH7zMiIsL0vqioCDYqE4jq6upwccfnSjXVgQMHXlu+isCgublZFi1aZJfncf78eQkLCxNVJSUlsmPHDgK1G2BQMmp2q4peiAABorXuDU/Kyspk9erVbwQMrpaqYIzHVRn6r53zdzkuDOP4rgzsSga72aIMStkoykBZDRaDREwmix0lgyg2/gKrQcikDP4A/8D19jl16TlyeN569fpxf+v0PI7nOK7nvvve1/d7X+dKJpOUotiaqjySwExCMsl2u/028YZCIQGpVMoW73K5JN67PVr1O0D61WpVDJ5TsO/z+fj/MpY3iaher5O5UQ5oHdFoVEql0oWINpuNKFA55XJZHMD8IWOEsOgZ8bZx0HWLBIMYAoEA9zCEek0wLpfLlgUhISCB6XSKhL0mGOSDRUgej0cUPJr3g2BsO+nH4/HyOpvNymAwEMV8Pn9EqDS95bNZ4Z8ebzgc/u/xItnIBvguh8NBDJ4DFEihUJBgMKhkZCMieuTSfQzJrsdut7sQEeOsIMvjcML5fCapgNjwMt82juFwKMVikQd4IGXjoTpJYIrXlQy8Xq+VZZ1OJ7p3U+pzGTgGYLVaCWDFpRktwKv5DcGMx2NJJBJMKovU0un0PYLhWjxJVmImDPV0/yTeyWTykvGqTZDL5SQWi4nBc0DGyHiwUCJjdcxRGthduvhhN/E32jcXG0aJSL13ziGpF4uFOCGfz0u325VKpSK1Wu1t4yAzxWuNx+Oy3W4Nod4iGLfbzYCzSWN5iJ1ORxSj0YinhHiPn5Y/qCDzguTIpJAJvyEY2uLRyJlNHGRxo9FwIhh8HfxHMke9H+b7h8Zrz2YgdsjY4DmYzWYQEORgLV6KZrPJ2KnHThbGHEEmI3dRDkpEbO5gz/CsP1nd3XtFIhGt9uC+LNLvFoeCDBXlanb5H4ANGnalbxEbEvdmN3vOMUn+FlzDtY/wjfGSKfj9fiurNXgSnMuIWNCYA7ZF+Ko/LkTEJibnef+r4uBR3H6/bwj1lbFer5G4tgN59G3xYjvwO5mxwctCiehWQf31uGJTfUQcKLFer6c+sCFUg9cHcqzVaonBS4NqFRTOV8WBfZDJZGS/38un4A8tC/bB5D9F8QAAAABJRU5ErkJggg==">
<b>Left:</b> The bounding box (blue) is the only part of the mob that actually collides with anything. By default, it would cover the whole turf (brown). Any turfs covered by the bounding box are in the mob's locs var. <b>Right:</b> The atom's true position (shaded) is offset from the turf by step_x and step_y.
</div>

<p>As an example, if your players' mobs have icons that only cover the center
24&times;24 pixels of a regular 32&times;32 icon, then you would set the
mobs' bound_x and bound_y to 4--because there are 4 pixels unused to the left
and bottom--and bound_width and bound_height to 24.

<p>The mob's physical location on the map depends on four things: Its loc,
its step_x/y values, its bound_x/y values, and its bound_width/height. The
lower left corner of the bounding box, relative to the turf the mob is
actually standing on, begins at step_x+bound_x on the left and step_y+bound_y
on the bottom.

<p>The physical position of the bounding box is <b>not affected</b> by the
pixel_x/y/z vars. Those are still strictly visual offsets.

<p>The turfs the mob is covering can be read from the read-only locs var. The
mob will also appear in the contents of those turfs. (Please note: This means
if an atom is in a turf's contents, its loc is <i>not necessarily</i> that
turf.)

<h3>Movement</h3>

<p>All of the step and walk procs have been upgraded to take an additional
argument, which is the speed at which the atom should move. If that argument
is left out, the atom's own step_size is used by default. The step_size
determines how fast the step_x and step_y values will change when moving.

<p>Move() has two new arguments that handle the position change gracefully.
These are the step_x and step_y values for the target location.

<p>Pixel movement changes the behavior of the Move() proc, because a lot of
things are possible that were not possible when BYOND only supported moving
one tile at a time. For starters, a Move() is either a "slide" or a "jump"
depending on the distance. A slide is when the move can be stopped partway;
a jump is strictly pass/fail. Anything greater than one tile <i>and</i> the
mover's regular step_size is considered a jump. Changing z levels is also a
jump, as is moving to/from a non-turf.

<p>If step_x and step_y aren't within a good range, the new loc and the
step_x/y values may be changed. The goal of Move() is for the southwest
corner of the mover's bounding box to be standing on loc.

<p>Enter() and Exit() can be called for several turfs and/or areas, not
just one at a time. It is also possible for them not to be called at all.
They are only called when first attempting to enter or (fully) exit. The
behavior of Enter() has also been changed; whereas in the past, it looked
at the density of itself and its contents, it will now only look at
contents that fully envelop that turf. This is because it is possible for an
atom to be standing only partly on a turf, without fully blocking it.

<p>To handle collisions between two movables, a new family of procs has been
added: Cross() and Uncross() are the equivalent of Enter() and Exit(), and
Crossed() and Uncrossed() are like Entered() and Exited().

<p>If an atom is sliding, its movement can be halted if it encounters an
obstacle partway along its route. Bump() will still be called for any
obstacles the atom runs into, but Move() will return the number of pixels
moved (the most in any direction). When sliding at a speed so fast that the
distance is bigger than the atom itself, the move will be split up into
several smaller slides to avoid skipping over any obstacles.

<p>Gliding, which was used in the past to show smooth movement between atoms,
has been deprecated. It is not used at all for atoms that use any of the
pixel movement capabilities.

<h3>Pixel procs</h3>

<p>The bounds() and obounds() procs have been added to grab a list of atoms
within a given bounding box. That box can be relative to an atom, or in
absolute coordinates.

<p>bounds_dist() tells the distance between two atoms, in pixels. If it is
positive, that is the minimum distance the atoms would have to traverse to be
touching. At 0, they are touching but not in collision. A negative value
means the two atoms are in collision.

<hr>

<a name=/{notes}/regex toc="Regular expressions">
<h2>Regular expressions</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/regex>regex datum</a>
<dd><a href=#/proc/regex>regex proc</a>
<dd><a href=#/proc/findtext>findtext proc</a>
<dd><a href=#/proc/replacetext>replacetext proc</a>
<dd><a href=#/proc/splittext>splittext proc</a>
<dd><a href=#/proc/REGEX_QUOTE>REGEX_QUOTE proc</a>
</dl>

<p>Regular expressions are patterns that can be searched for within a text
string, instead of searching for an exact match to a known piece of text.
They are much more versatile for find and replace operations, and therefore
useful for parsing, filtering, etc.

<p>Some example regular expressions are:

<table class="regex">
<tr><th>Pattern</th><th>Code</th><th>Meaning</th></tr>
<tr><td>B.*D</td><td>regex("B.*D")</td><td>Find "B", followed by any number of characters (including none), followed by a "D".</td></tr>
<tr><td>[0-3]</td><td>regex("\[0-3]")</td><td>Find any digit from 0 to 3</td></tr>
<tr><td>foo|bar</td><td>regex("foo|bar","i")</td><td>Find "foo" or "bar", case-insensitive</td></tr>
<tr><td>\d+</td><td>regex("\\d+","g")</td><td>Find all sequences of digits</td></tr>
</table>

<p>These are some of the patterns you can use. Note that any backslashes must
be escaped to make this a valid DM string, so \d would be "\\d" in your code.
If you want to use any of the operators as an actual character, it must be
escaped with <i>two</i> backslashes (once to escape it in the pattern, and one
more for the DM string).

<table class="regex">
<tr><th>Pattern</th><th>Matches</th></tr>
<tr><td><i>a</i>|<i>b</i></td><td><i>a</i> or <i>b</i></td></tr>
<tr><td>.</td><td>Any character (except a line break)</td></tr>
<tr><td>^</td><td>Beginning of text; or line if "m" flag is used</td></tr>
<tr><td>$</td><td>End of text; or line if "m" flag is used</td></tr>
<tr><td>\A</td><td>Beginning of text</td></tr>
<tr><td>\Z</td><td>End of text</td></tr>
<tr><td>[<i>chars</i>]</td><td>Any character between the brackets. Ranges can be specified with a hyphen, like 0-9. Character classes like \d and \s can also be used (see below).</td></tr>
<tr><td>[^<i>chars</i>]</td><td>Any character NOT matching the ones between the brackets.</td></tr>
<tr><td>\b</td><td>Word break</td></tr>
<tr><td>(<i>pattern</i>)</td><td>Capturing group: the pattern must match, and its contents will be captured in the group list.</td></tr>
<tr><td>(?:<i>pattern</i>)</td><td>Non-capturing group: Match the pattern, but do not capture its contents.</td></tr>
<tr><td>\1 <i>through</i> \9</td><td>Backreference; \<i>N</i> is whatever was captured in the <i>N</i>th capturing group.</td></tr>

<tr><th colspan=2>Modifiers</th></tr>
<tr><td colspan=2>Modifiers are "greedy" by default, looking for the longest match possible.  When following a word, they only apply to the last character.</td></tr>
<tr><td><i>a</i>*</td><td>Match <i>a</i> zero or more times</td></tr>
<tr><td><i>a</i>+</td><td>Match <i>a</i> one or more times</td></tr>
<tr><td><i>a</i>?</td><td>Match <i>a</i> zero or one time</td></tr>
<tr><td><i>a</i>{<i>n</i>}</td><td>Match <i>a</i>, exactly <i>n</i> times</td></tr>
<tr><td><i>a</i>{<i>n</i>,}</td><td>Match <i>a</i>, <i>n</i> or more times</td></tr>
<tr><td><i>a</i>{<i>n</i>,<i>m</i>}</td><td>Match <i>a</i>, <i>n</i> to <i>m</i> times</td></tr>
<tr><td><i>modifier</i>?</td><td>Make the previous modifier non-greedy (match as little as possible)</td></tr>

<tr><th colspan=2>Escape codes and character classes</th></tr>
<tr><td>\x<i>NN</i></td><td>Escape code for a single character, where <i>NN</i> is its hexadecimal ASCII value</td></tr>
<tr><td>\d</td><td>Any digit 0 through 9</td></tr>
<tr><td>\D</td><td>Any character except a digit or line break</td></tr>
<tr><td>\l</td><td>Any letter A through Z, case-insensitive</td></tr>
<tr><td>\L</td><td>Any character except a letter or line break</td></tr>
<tr><td>\w</td><td>Any identifier character: digits, letters, or underscore</td></tr>
<tr><td>\W</td><td>Any character except an identifier character or line break</td></tr>
<tr><td>\s</td><td>Any space character</td></tr>
<tr><td>\S</td><td>Any character except a space or line break</td></tr>

<tr><th colspan=2>Assertions</th></tr>
<tr><td>(?=<i>pattern</i>)</td><td>Look-ahead: Require this pattern to come next, but don't include it in the match</td></tr>
<tr><td>(?!<i>pattern</i>)</td><td>Look-ahead: Require this pattern NOT to come next</td></tr>
<tr><td>(?&lt;=<i>pattern</i>)</td><td>Look-behind: Require this pattern to come before, but don't include it in the match (must be a fixed length)</td></tr>
<tr><td>(?&lt;!<i>pattern</i>)</td><td>Look-behind: Require this pattern NOT to come before</td></tr>
</table>

<p>The optional flags can be any combination of these:

<table class="regex">
<tr><th>Flag</th><th>Meaning</th></tr>
<tr><td>i</td><td>Case-insensitive matching</td></tr>
<tr><td>g</td><td>Global: In Find() subsequent calls will start where this left off, and in Replace() all matches are replaced.</td></tr>
<tr><td>m</td><td>Multi-line: ^ and $ refer to the beginning and end of a line, respectively.</td></tr>
</table>

<p>After calling Find() on a /regex datum, the datum's group var will contain
a list--if applicable--of any sub-patterns found with the ( ) parentheses
operator. For instance, searching the string "123" for 1(\d)(\d) will match
"123", and the group var will be list("2","3"). Groups can also be used in
replacement expressions; see the Replace() proc for more details.

<hr>

<a name=/{notes}/side toc="Side-view maps">
<h2>Side-view maps</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
<dd><a href=#/world/var/icon_size>icon_size var (world)</a>
<dd><a href=#/client/var/dir>dir var (client)</a>
<dd><a href=#/atom/var/pixel_w>pixel_w var (atom)</a>
<dd><a href=#/atom/var/pixel_z>pixel_z var (atom)</a>
<dd><a href=#/atom/movable/var/screen_loc>screen_loc var (movable atoms)</a>
<dd><a href=#/{notes}/big-icons>Big icons</a>
<dd><a href=#/{notes}/isometric>Isometric maps</a>
<dd><a href=#/{notes}/topdown>Topdown maps</a>
<dd><a href=#/{notes}/HUD>HUD</a>
<dd><a href=#/{notes}/BACKGROUND_LAYER>BACKGROUND_LAYER</a>
<dd><a href=#/{notes}/EFFECTS_LAYER>EFFECTS_LAYER</a>
<dd><a href=#/{notes}/topdown_layer>TOPDOWN_LAYER</a>
</dl>

<p>The side-view map format is used for 3/4 perspective, where the map is
basically similar to a top-down view but is usually foreshortened. Just like
with isometric projection, tiles that are closer to the bottom of the screen
are considered to be closer to the viewer. This is a form of pseudo-3D in
which the 2D icons used by BYOND can be arranged in a way to give the
appearance of three dimensions.

<p>It is important to remember that this is an illusion of 3D, not real 3D.

<p>The atom.layer var behaves much the same way it does in ISOMETRIC_MAP mode.
Because this layout uses a concept of "near" and "far" that doesn't exist in
topdown maps, screen objects will always appear in front of the regular map
unless you also make use of BACKGROUND_LAYER. See
<a href=#/{notes}/isometric>isometric maps</a> for more information.

<p>Often when using this mode you will want to use a foreshortened
world.icon_size, like a 32x24 format instead of 32x32 for example, and use
taller icons for any vertical structures like walls or buildings. If you set
world.icon_size to use foreshortening, then pixel_y (or pixel_x, depending on
the orientation of client.dir) will be adjusted for you. For example, with
world.icon_size set to "64x32", the tile is considered to be 64x64 if you were
to look at it straight down, so you would need pixel_y=64 to offset by a whole
tile. This does not apply to screen objects, pixel_w, or pixel_z.

<hr>

<a name=/{notes}/tiled-icons toc="Tiled icons">
<h2>Tiled icons</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/icon>icon</a>
<dd><a href=#/icon/proc>icon procs</a>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
<dd><a href=#/world/var/icon_size>icon_size var (world)</a>
<dd><a href=#/{notes}/big-icons>Big icons</a>
</dl>

<p>In BYOND 3.0, any file like a large .bmp would be treated like a regular
icon that had been broken up into several tile-sized icon states. All tiles
then were 32x32 pixels. An image that was 100x100 would therefore take at
least 4x4 tiles to display. The icon was padded to the right and the top with
blank space to become an even multiple of 32x32, and then broken up into
sections. The lower left section was given an icon_state of "0,0", the next to
the right was "1,0", and so on, up to the upper right which was "3,3". Another
icon state, a 32x32 thumbnail of the big image, was also included.

<p>BYOND 4.0 expanded on this concept by allowing icons to be defined that had
individual graphics bigger than 32x32, and it would break each one up into
tiles just like 3.0 did. If an icon had a state called "open" then it might
break down into "open 0,0", "open 1,0", and so on, while the actual "open"
state would be a thumbnail image. To show the whole image, you would have to
have a separate atom or overlay for each individual tile.

<p>As of BYOND build 455, breaking big icons into tiles is no longer done by
default. Instead, icons are shown and manipulated in their
<a href=#/{notes}/big-icons>native size</a>. To use the old method of breaking
icons into tiles, set world.map_format to TILED_ICON_MAP. This is the default
for all projects compiled before version 455.

<p>When using tiled icons, there are some important things to note:

<ul>
  <li>You need to use extra atoms or overlays to show any icon bigger than a
    single tile, where each atom/overlay shows an individual tile-sized piece
    of the big icon.</li>
  <li>The icon_state names of each tile are always the original name followed
    by a space, followed by x,y tile coordinates such as 0,0 or 2,1, so the
    northeast corner of "flag" might for instance be "flag 3,2". If the
    original icon_state had no name, the space is left out and only the x,y
    coordinates are used.</li>
  <li>Every icon's size is a multiple of world.icon_size. If an icon of an
    incompatible size is used, it will be padded to the nearest full tile
    size.</li>
  <li>Crop() and Scale() always pad their results to the nearest full tile
    size.</li>
  <li>icon.Insert() can insert a single-tile icon into a multi-tiled big icon
    using the appropriate icon_state; e.g., inserting into "door 0,0" will
    replace the southwest corner of the "door" state.</li>
  <li>Using the icon() proc, you can extract a single tile from a multi-tiled
    big icon.</li>
</ul>

<p>This example shows a big icon being applied to an atom in tiled mode, as
overlays:

<h3>Example:</h3>
<xmp>
// icon is 3 tiles wide by 2 high
icon_state = "0,0"

// A temporary object used for the overlays
var/obj/O = new
O.icon = icon
O.layer = FLOAT_LAYER

for(var/tile_y=0, tile_y<2, ++tile_y)
   for(var/tile_x=0, tile_x<3, ++tile_x)
      if(tile_x && tile_y)
         O.pixel_x = tile_x * 32
         O.pixel_y = tile_y * 32
         O.icon_state = "[tile_x],[tile_y]"
         overlays += O
</xmp>

<hr>

<a name=/{notes}/topdown toc="Topdown maps">
<h2>Topdown maps</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
<dd><a href=#/world/var/icon_size>icon_size var (world)</a>
<dd><a href=#/client/var/dir>dir var (client)</a>
<dd><a href=#/atom/var/layer>layer var (atom)</a>
<dd><a href=#/atom/movable/var/screen_loc>screen_loc var (movable atoms)</a>
<dd><a href=#/{notes}/big-icons>Big icons</a>
<dd><a href=#/{notes}/HUD>HUD</a>
<dd><a href=#/{notes}/isometric>Isometric maps</a>
<dd><a href=#/{notes}/side>Side-view maps</a>
</dl>

<p>By default, BYOND displays all maps in top-down format, so world.map_format
is set to TOPDOWN_MAP unless you say otherwise. This view means players are
looking down on the map, and "north" corresponds to the top of their screen.
(This can be changed by setting client.dir.)

<p>A related map_format, used by older games, is TILED_ICON_MAP. This is also
topdown but it handles icons differently.

<p>In this form, the atom.layer var behaves exactly as you would expect: Icons
with a lower layer are drawn beneath icons with a higher layer. The only
exception is when you use <a href=#/{notes}/big-icons>big icons</a>, which will
be drawn above any other icons on the same layer. Also an atom's underlays will
be drawn behind it unless their layer is changed, and its overlays will draw in
front of it unless otherwise stated.

<p>Topdown mode also guarantees that world.view or client.view will set the
exact screen size used by the HUD, except for HUD objects that appear outside
of the normal bounds.

<p>Screen objects (HUD) can be intermixed with topdown icons. They can be made
to appear above or below any other icons, but usually they are displayed on
top. To make sure they always appear above other icons, you can give them a
high layer like 10 or 100.

<hr>

<a name=/{notes}/TOPDOWN_LAYER>
<h2>TOPDOWN_LAYER</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/layer>layer var (atom)</a>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
<dd><a href=#/{notes}/BACKGROUND_LAYER>BACKGROUND_LAYER</a>
<dd><a href=#/{notes}/EFFECTS_LAYER>EFFECTS_LAYER</a>
</dl>

<p>TOPDOWN_LAYER is a special high value that can be added to the regular layer
of any atom. This is only available when using a non-topdown world.map_format,
such as isometric mapping.

<p>The purpose of this value is to make an atom appear as if it belongs in a
top-down map, when using a map_format other than TOPDOWN_MAP or TILED_ICON_MAP.
This can be handy for title screens, or for special battle maps or the inside
of a building in an RPG.

<p>When using this special layer, it should be added to the layer an atom
normally uses. For instance a turf should have a layer of TOPDOWN_LAYER +
TURF_LAYER. Usually you will want one part of the map to have TOPDOWN_LAYER,
and for players to be unable to walk to there from the regular map. Mixing
topdown icons and icons in the normal map_format in view of each other could
look very strange. For safety's sake, the easiest thing to do is to keep them
on separate z layers.

<p>This can be mixed with EFFECTS_LAYER. Anything in TOPDOWN_LAYER will
display on top of EFFECTS_LAYER, and TOPDOWN_LAYER + EFFECTS_LAYER will be
above both.

<p>This can also be mixed with BACKGROUND_LAYER, which takes priority over
everything else.

<p>Images or overlays with FLOAT_LAYER can be left alone. They will
automatically have the same layer as whatever atom they are attached to.

<hr>

</div></body>
</html>
